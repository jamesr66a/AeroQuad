   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"AeroQuadMain.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.systick_get_count,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	systick_get_count:
  25              	.LFB53:
  26              		.file 1 "../Libmaple/libmaple/libmaple/systick.h"
   1:../Libmaple/libmaple/libmaple/systick.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/systick.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/systick.h ****  *
   4:../Libmaple/libmaple/libmaple/systick.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/systick.h ****  *
   6:../Libmaple/libmaple/libmaple/systick.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/systick.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/systick.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/systick.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/systick.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/systick.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/systick.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/systick.h ****  *
  14:../Libmaple/libmaple/libmaple/systick.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/systick.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/systick.h ****  *
  17:../Libmaple/libmaple/libmaple/systick.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/systick.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/systick.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/systick.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/systick.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/systick.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/systick.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/systick.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/systick.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/systick.h **** 
  27:../Libmaple/libmaple/libmaple/systick.h **** /**
  28:../Libmaple/libmaple/libmaple/systick.h ****  * @file systick.h
  29:../Libmaple/libmaple/libmaple/systick.h ****  *
  30:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Various system timer definitions
  31:../Libmaple/libmaple/libmaple/systick.h ****  */
  32:../Libmaple/libmaple/libmaple/systick.h **** 
  33:../Libmaple/libmaple/libmaple/systick.h **** #ifndef _SYSTICK_H_
  34:../Libmaple/libmaple/libmaple/systick.h **** #define _SYSTICK_H_
  35:../Libmaple/libmaple/libmaple/systick.h **** 
  36:../Libmaple/libmaple/libmaple/systick.h **** #include "libmaple_types.h"
  37:../Libmaple/libmaple/libmaple/systick.h **** #include "util.h"
  38:../Libmaple/libmaple/libmaple/systick.h **** 
  39:../Libmaple/libmaple/libmaple/systick.h **** #ifdef __cplusplus
  40:../Libmaple/libmaple/libmaple/systick.h **** extern "C"{
  41:../Libmaple/libmaple/libmaple/systick.h **** #endif
  42:../Libmaple/libmaple/libmaple/systick.h **** 
  43:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map type */
  44:../Libmaple/libmaple/libmaple/systick.h **** typedef struct systick_reg_map {
  45:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CSR;            /**< Control and status register */
  46:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 RVR;            /**< Reload value register */
  47:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CNT;            /**< Current value register ("count") */
  48:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CVR;            /**< Calibration value register */
  49:../Libmaple/libmaple/libmaple/systick.h **** } systick_reg_map;
  50:../Libmaple/libmaple/libmaple/systick.h **** 
  51:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map base pointer */
  52:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_BASE                    ((struct systick_reg_map*)0xE000E010)
  53:../Libmaple/libmaple/libmaple/systick.h **** 
  54:../Libmaple/libmaple/libmaple/systick.h **** /*
  55:../Libmaple/libmaple/libmaple/systick.h ****  * Register bit definitions.
  56:../Libmaple/libmaple/libmaple/systick.h ****  */
  57:../Libmaple/libmaple/libmaple/systick.h **** 
  58:../Libmaple/libmaple/libmaple/systick.h **** /* Control and status register */
  59:../Libmaple/libmaple/libmaple/systick.h **** 
  60:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_COUNTFLAG           BIT(16)
  61:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE           BIT(2)
  62:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_EXTERNAL  0
  63:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_CORE      BIT(2)
  64:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT             BIT(1)
  65:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_PEND        BIT(1)
  66:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_NO_PEND     0
  67:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE              BIT(0)
  68:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_MULTISHOT    BIT(0)
  69:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_DISABLED     0
  70:../Libmaple/libmaple/libmaple/systick.h **** 
  71:../Libmaple/libmaple/libmaple/systick.h **** /* Calibration value register */
  72:../Libmaple/libmaple/libmaple/systick.h **** 
  73:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_NOREF               BIT(31)
  74:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_SKEW                BIT(30)
  75:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_TENMS               0xFFFFFF
  76:../Libmaple/libmaple/libmaple/systick.h **** 
  77:../Libmaple/libmaple/libmaple/systick.h **** /** System elapsed time, in milliseconds */
  78:../Libmaple/libmaple/libmaple/systick.h **** extern volatile uint32 systick_uptime_millis;
  79:../Libmaple/libmaple/libmaple/systick.h **** 
  80:../Libmaple/libmaple/libmaple/systick.h **** /**
  81:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the system uptime, in milliseconds.
  82:../Libmaple/libmaple/libmaple/systick.h ****  */
  83:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_uptime(void) {
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  85:../Libmaple/libmaple/libmaple/systick.h **** }
  86:../Libmaple/libmaple/libmaple/systick.h **** 
  87:../Libmaple/libmaple/libmaple/systick.h **** 
  88:../Libmaple/libmaple/libmaple/systick.h **** void systick_init(uint32 reload_val);
  89:../Libmaple/libmaple/libmaple/systick.h **** void systick_disable();
  90:../Libmaple/libmaple/libmaple/systick.h **** void systick_enable();
  91:../Libmaple/libmaple/libmaple/systick.h **** 
  92:../Libmaple/libmaple/libmaple/systick.h **** /**
  93:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the current value of the SysTick counter.
  94:../Libmaple/libmaple/libmaple/systick.h ****  */
  95:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_get_count(void) {
  27              		.loc 1 95 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  96:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CNT;
  32              		.loc 1 96 0
  33 0000 014B     		ldr	r3, .L2
  34 0002 9868     		ldr	r0, [r3, #8]
  97:../Libmaple/libmaple/libmaple/systick.h **** }
  35              		.loc 1 97 0
  36 0004 7047     		bx	lr
  37              	.L3:
  38 0006 00BF     		.align	2
  39              	.L2:
  40 0008 10E000E0 		.word	-536813552
  41              		.cfi_endproc
  42              	.LFE53:
  44              		.section	.text._ZL6millisv,"ax",%progbits
  45              		.align	1
  46              		.thumb
  47              		.thumb_func
  49              	_ZL6millisv:
  50              	.LFB55:
  51              		.file 2 "../Libmaple/libmaple/wirish/wirish_time.h"
   1:../Libmaple/libmaple/wirish/wirish_time.h **** /******************************************************************************
   2:../Libmaple/libmaple/wirish/wirish_time.h ****  * The MIT License
   3:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   4:../Libmaple/libmaple/wirish/wirish_time.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   6:../Libmaple/libmaple/wirish/wirish_time.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/wirish/wirish_time.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/wirish/wirish_time.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/wirish/wirish_time.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/wirish/wirish_time.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/wirish/wirish_time.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/wirish/wirish_time.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  14:../Libmaple/libmaple/wirish/wirish_time.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/wirish/wirish_time.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  17:../Libmaple/libmaple/wirish/wirish_time.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/wirish/wirish_time.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/wirish/wirish_time.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/wirish/wirish_time.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/wirish/wirish_time.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/wirish/wirish_time.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/wirish/wirish_time.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/wirish/wirish_time.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/wirish/wirish_time.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/wirish/wirish_time.h **** 
  27:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  28:../Libmaple/libmaple/wirish/wirish_time.h ****  * @file wirish_time.h
  29:../Libmaple/libmaple/wirish/wirish_time.h ****  * @brief Timing and delay functions.
  30:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  31:../Libmaple/libmaple/wirish/wirish_time.h **** 
  32:../Libmaple/libmaple/wirish/wirish_time.h **** #ifndef __WIRISH_TIME_H_
  33:../Libmaple/libmaple/wirish/wirish_time.h **** #define __WIRISH_TIME_H_
  34:../Libmaple/libmaple/wirish/wirish_time.h **** 
  35:../Libmaple/libmaple/wirish/wirish_time.h **** #include "libmaple.h"
  36:../Libmaple/libmaple/wirish/wirish_time.h **** #include "nvic.h"
  37:../Libmaple/libmaple/wirish/wirish_time.h **** #include "systick.h"
  38:../Libmaple/libmaple/wirish/wirish_time.h **** #include "boards.h"
  39:../Libmaple/libmaple/wirish/wirish_time.h **** 
  40:../Libmaple/libmaple/wirish/wirish_time.h **** #define US_PER_MS               1000
  41:../Libmaple/libmaple/wirish/wirish_time.h **** 
  42:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  43:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in milliseconds) since the beginning of program
  44:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution. On overflow, restarts at 0.
  45:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see micros()
  46:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  47:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 millis(void) {
  52              		.loc 2 47 0
  53              		.cfi_startproc
  54              		@ args = 0, pretend = 0, frame = 0
  55              		@ frame_needed = 0, uses_anonymous_args = 0
  56              		@ link register save eliminated.
  57              	.LBB5:
  58              	.LBB6:
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  59              		.loc 1 84 0
  60 0000 014B     		ldr	r3, .L5
  61 0002 1868     		ldr	r0, [r3, #0]
  62              	.LBE6:
  63              	.LBE5:
  48:../Libmaple/libmaple/wirish/wirish_time.h ****     return systick_uptime();
  49:../Libmaple/libmaple/wirish/wirish_time.h **** }
  64              		.loc 2 49 0
  65 0004 7047     		bx	lr
  66              	.L6:
  67 0006 00BF     		.align	2
  68              	.L5:
  69 0008 00000000 		.word	systick_uptime_millis
  70              		.cfi_endproc
  71              	.LFE55:
  73              		.section	.text._ZL6microsv,"ax",%progbits
  74              		.align	1
  75              		.thumb
  76              		.thumb_func
  78              	_ZL6microsv:
  79              	.LFB56:
  50:../Libmaple/libmaple/wirish/wirish_time.h **** 
  51:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  52:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in microseconds) since the beginning of program
  53:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution.  On overflow, restarts at 0.
  54:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see millis()
  55:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  56:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 micros(void) {
  80              		.loc 2 56 0
  81              		.cfi_startproc
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 0, uses_anonymous_args = 0
  84 0000 38B5     		push	{r3, r4, r5, lr}
  85              	.LCFI0:
  86              		.cfi_def_cfa_offset 16
  87              		.cfi_offset 14, -4
  88              		.cfi_offset 5, -8
  89              		.cfi_offset 4, -12
  90              		.cfi_offset 3, -16
  91              	.L8:
  92              	.LBB10:
  57:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 ms;
  58:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 cycle_cnt;
  59:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 res;
  60:../Libmaple/libmaple/wirish/wirish_time.h **** 
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
  62:../Libmaple/libmaple/wirish/wirish_time.h ****         ms = millis();
  93              		.loc 2 62 0 discriminator 1
  94 0002 FFF7FEFF 		bl	_ZL6millisv
  95 0006 0446     		mov	r4, r0
  96              	.LVL0:
  63:../Libmaple/libmaple/wirish/wirish_time.h ****         cycle_cnt = systick_get_count();
  97              		.loc 2 63 0 discriminator 1
  98 0008 FFF7FEFF 		bl	systick_get_count
  99              	.LVL1:
 100 000c 0546     		mov	r5, r0
  64:../Libmaple/libmaple/wirish/wirish_time.h ****         asm volatile("nop"); //allow interrupt to fire
 101              		.loc 2 64 0 discriminator 1
 102              	@ 64 "../Libmaple/libmaple/wirish/wirish_time.h" 1
 103 000e 00BF     		nop
 104              	@ 0 "" 2
  65:../Libmaple/libmaple/wirish/wirish_time.h ****         asm volatile("nop");
 105              		.loc 2 65 0 discriminator 1
 106              	@ 65 "../Libmaple/libmaple/wirish/wirish_time.h" 1
 107 0010 00BF     		nop
 108              	@ 0 "" 2
  66:../Libmaple/libmaple/wirish/wirish_time.h ****     } while (ms != millis());
 109              		.loc 2 66 0 discriminator 1
 110              		.thumb
 111 0012 FFF7FEFF 		bl	_ZL6millisv
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
 112              		.loc 2 61 0 discriminator 1
 113 0016 8442     		cmp	r4, r0
 114 0018 F3D1     		bne	.L8
 115              	.LBB11:
 116              	.LBB12:
  98:../Libmaple/libmaple/libmaple/systick.h **** 
  99:../Libmaple/libmaple/libmaple/systick.h **** /**
 100:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Check for underflow.
 101:../Libmaple/libmaple/libmaple/systick.h ****  *
 102:../Libmaple/libmaple/libmaple/systick.h ****  * This function returns 1 if the SysTick timer has counted to 0 since
 103:../Libmaple/libmaple/libmaple/systick.h ****  * the last time it was called.  However, any reads of any part of the
 104:../Libmaple/libmaple/libmaple/systick.h ****  * SysTick Control and Status Register SYSTICK_BASE->CSR will
 105:../Libmaple/libmaple/libmaple/systick.h ****  * interfere with this functionality.  See the ARM Cortex M3 Technical
 106:../Libmaple/libmaple/libmaple/systick.h ****  * Reference Manual for more details (e.g. Table 8-3 in revision r1p1).
 107:../Libmaple/libmaple/libmaple/systick.h ****  */
 108:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_check_underflow(void) {
 109:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CSR & SYSTICK_CSR_COUNTFLAG;
 117              		.loc 1 109 0
 118 001a 0948     		ldr	r0, .L11
 119 001c 0368     		ldr	r3, [r0, #0]
 120              	.LBE12:
 121              	.LBE11:
  67:../Libmaple/libmaple/wirish/wirish_time.h **** 
  68:../Libmaple/libmaple/wirish/wirish_time.h ****     if(systick_check_underflow()) {
 122              		.loc 2 68 0
 123 001e DB03     		lsls	r3, r3, #15
 124 0020 03D5     		bpl	.L9
  69:../Libmaple/libmaple/wirish/wirish_time.h ****     	ms++;
  70:../Libmaple/libmaple/wirish/wirish_time.h ****     	cycle_cnt = systick_get_count();
 125              		.loc 2 70 0
 126 0022 FFF7FEFF 		bl	systick_get_count
  69:../Libmaple/libmaple/wirish/wirish_time.h ****     	ms++;
 127              		.loc 2 69 0
 128 0026 0134     		adds	r4, r4, #1
 129              	.LVL2:
 130              		.loc 2 70 0
 131 0028 0546     		mov	r5, r0
 132              	.LVL3:
 133              	.L9:
  71:../Libmaple/libmaple/wirish/wirish_time.h ****     }
  72:../Libmaple/libmaple/wirish/wirish_time.h **** 
  73:../Libmaple/libmaple/wirish/wirish_time.h ****     /* SYSTICK_RELOAD_VAL is 1 less than the number of cycles it
  74:../Libmaple/libmaple/wirish/wirish_time.h ****        actually takes to complete a SysTick reload */
  75:../Libmaple/libmaple/wirish/wirish_time.h ****     res = (ms * US_PER_MS) +
  76:../Libmaple/libmaple/wirish/wirish_time.h ****         (SYSTICK_RELOAD_VAL + 1 - cycle_cnt) / CYCLES_PER_MICROSECOND;
 134              		.loc 2 76 0
 135 002a C5F52435 		rsb	r5, r5, #167936
 136              	.LVL4:
 137 002e 4035     		adds	r5, r5, #64
 138 0030 A822     		movs	r2, #168
 139 0032 B5FBF2F5 		udiv	r5, r5, r2
 140              	.LBE10:
  77:../Libmaple/libmaple/wirish/wirish_time.h **** 
  78:../Libmaple/libmaple/wirish/wirish_time.h ****     return res;
  79:../Libmaple/libmaple/wirish/wirish_time.h **** }
 141              		.loc 2 79 0
 142 0036 4FF47A71 		mov	r1, #1000
 143 003a 01FB0450 		mla	r0, r1, r4, r5
 144 003e 38BD     		pop	{r3, r4, r5, pc}
 145              	.L12:
 146              		.align	2
 147              	.L11:
 148 0040 10E000E0 		.word	-536813552
 149              		.cfi_endproc
 150              	.LFE56:
 152              		.section	.text.timer_set_prescaler.isra.0,"ax",%progbits
 153              		.align	1
 154              		.thumb
 155              		.thumb_func
 157              	timer_set_prescaler.isra.0:
 158              	.LFB249:
 159              		.file 3 "../Libmaple/libmaple/libmaple/timer.h"
   1:../Libmaple/libmaple/libmaple/timer.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/timer.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/timer.h ****  *
   4:../Libmaple/libmaple/libmaple/timer.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/timer.h ****  *
   6:../Libmaple/libmaple/libmaple/timer.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/timer.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/timer.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/timer.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/timer.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/timer.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/timer.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/timer.h ****  *
  14:../Libmaple/libmaple/libmaple/timer.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/timer.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/timer.h ****  *
  17:../Libmaple/libmaple/libmaple/timer.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/timer.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/timer.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/timer.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/timer.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/timer.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/timer.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/timer.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/timer.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/timer.h **** 
  27:../Libmaple/libmaple/libmaple/timer.h **** /**
  28:../Libmaple/libmaple/libmaple/timer.h ****  * @file   timer.h
  29:../Libmaple/libmaple/libmaple/timer.h ****  * @author Marti Bolivar <mbolivar@leaflabs.com>
  30:../Libmaple/libmaple/libmaple/timer.h ****  * @brief  New-style timer interface.
  31:../Libmaple/libmaple/libmaple/timer.h ****  *
  32:../Libmaple/libmaple/libmaple/timer.h ****  * Replaces old timers.h implementation.
  33:../Libmaple/libmaple/libmaple/timer.h ****  */
  34:../Libmaple/libmaple/libmaple/timer.h **** 
  35:../Libmaple/libmaple/libmaple/timer.h **** #ifndef _TIMERS_H_
  36:../Libmaple/libmaple/libmaple/timer.h **** #define _TIMERS_H_
  37:../Libmaple/libmaple/libmaple/timer.h **** 
  38:../Libmaple/libmaple/libmaple/timer.h **** #include "libmaple.h"
  39:../Libmaple/libmaple/libmaple/timer.h **** #include "rcc.h"
  40:../Libmaple/libmaple/libmaple/timer.h **** #include "nvic.h"
  41:../Libmaple/libmaple/libmaple/timer.h **** #include "bitband.h"
  42:../Libmaple/libmaple/libmaple/timer.h **** 
  43:../Libmaple/libmaple/libmaple/timer.h **** #ifdef __cplusplus
  44:../Libmaple/libmaple/libmaple/timer.h **** extern "C"{
  45:../Libmaple/libmaple/libmaple/timer.h **** #endif
  46:../Libmaple/libmaple/libmaple/timer.h **** 
  47:../Libmaple/libmaple/libmaple/timer.h **** /*
  48:../Libmaple/libmaple/libmaple/timer.h ****  * Register maps and devices
  49:../Libmaple/libmaple/libmaple/timer.h ****  */
  50:../Libmaple/libmaple/libmaple/timer.h **** 
  51:../Libmaple/libmaple/libmaple/timer.h **** /** Advanced control timer register map type */
  52:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_adv_reg_map {
  53:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  54:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  55:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  56:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  57:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  58:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  59:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  60:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  61:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  62:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  63:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  64:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  65:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 RCR;            /**< Repetition counter register */
  66:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  67:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  68:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  69:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  70:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 BDTR;           /**< Break and dead-time register */
  71:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  72:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  73:../Libmaple/libmaple/libmaple/timer.h **** } timer_adv_reg_map;
  74:../Libmaple/libmaple/libmaple/timer.h **** 
  75:../Libmaple/libmaple/libmaple/timer.h **** /** General purpose timer register map type */
  76:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_gen_reg_map {
  77:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  78:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  79:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  80:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  81:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  82:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  83:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  84:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  85:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  86:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  87:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  88:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  89:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
  90:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  91:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  92:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  93:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  94:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
  95:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  96:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  97:../Libmaple/libmaple/libmaple/timer.h **** } timer_gen_reg_map;
  98:../Libmaple/libmaple/libmaple/timer.h **** 
  99:../Libmaple/libmaple/libmaple/timer.h **** /** Basic timer register map type */
 100:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_bas_reg_map {
 101:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
 102:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
 103:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
 104:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
 105:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
 106:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
 107:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
 108:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED3;     /**< Reserved */
 109:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED4;     /**< Reserved */
 110:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
 111:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
 112:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
 113:../Libmaple/libmaple/libmaple/timer.h **** } timer_bas_reg_map;
 114:../Libmaple/libmaple/libmaple/timer.h **** 
 115:../Libmaple/libmaple/libmaple/timer.h **** 
 116:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 117:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 118:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40010000)
 119:../Libmaple/libmaple/libmaple/timer.h **** #else
 120:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 121:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40012C00)
 122:../Libmaple/libmaple/libmaple/timer.h **** #endif
 123:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 2 register map base pointer */
 124:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER2_BASE        ((struct timer_gen_reg_map*)0x40000000)
 125:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 3 register map base pointer */
 126:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER3_BASE        ((struct timer_gen_reg_map*)0x40000400)
 127:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 4 register map base pointer */
 128:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER4_BASE        ((struct timer_gen_reg_map*)0x40000800)
 129:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 130:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 5 register map base pointer */
 131:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER5_BASE        ((struct timer_gen_reg_map*)0x40000C00)
 132:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 6 register map base pointer */
 133:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER6_BASE        ((struct timer_bas_reg_map*)0x40001000)
 134:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 7 register map base pointer */
 135:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER7_BASE        ((struct timer_bas_reg_map*)0x40001400)
 136:../Libmaple/libmaple/libmaple/timer.h **** 
 137:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 138:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 139:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40010400)
 140:../Libmaple/libmaple/libmaple/timer.h **** #else
 141:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 142:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40013400)
 143:../Libmaple/libmaple/libmaple/timer.h **** #endif
 144:../Libmaple/libmaple/libmaple/timer.h **** #endif
 145:../Libmaple/libmaple/libmaple/timer.h **** 
 146:../Libmaple/libmaple/libmaple/timer.h **** /*
 147:../Libmaple/libmaple/libmaple/timer.h ****  * Timer devices
 148:../Libmaple/libmaple/libmaple/timer.h ****  */
 149:../Libmaple/libmaple/libmaple/timer.h **** 
 150:../Libmaple/libmaple/libmaple/timer.h **** /**
 151:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer register map type.
 152:../Libmaple/libmaple/libmaple/timer.h ****  *
 153:../Libmaple/libmaple/libmaple/timer.h ****  * Just holds a pointer to the correct type of register map, based on
 154:../Libmaple/libmaple/libmaple/timer.h ****  * the timer's type.
 155:../Libmaple/libmaple/libmaple/timer.h ****  */
 156:../Libmaple/libmaple/libmaple/timer.h **** typedef union timer_reg_map {
 157:../Libmaple/libmaple/libmaple/timer.h ****     timer_adv_reg_map *adv;     /**< Advanced register map */
 158:../Libmaple/libmaple/libmaple/timer.h ****     timer_gen_reg_map *gen;     /**< General purpose register map */
 159:../Libmaple/libmaple/libmaple/timer.h ****     timer_bas_reg_map *bas;     /**< Basic register map */
 160:../Libmaple/libmaple/libmaple/timer.h **** } timer_reg_map;
 161:../Libmaple/libmaple/libmaple/timer.h **** 
 162:../Libmaple/libmaple/libmaple/timer.h **** /**
 163:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer type
 164:../Libmaple/libmaple/libmaple/timer.h ****  *
 165:../Libmaple/libmaple/libmaple/timer.h ****  * Type marker for timer_dev.
 166:../Libmaple/libmaple/libmaple/timer.h ****  *
 167:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_dev
 168:../Libmaple/libmaple/libmaple/timer.h ****  */
 169:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_type {
 170:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_ADVANCED,             /**< Advanced type */
 171:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_GENERAL,              /**< General purpose type */
 172:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BASIC                 /**< Basic type */
 173:../Libmaple/libmaple/libmaple/timer.h **** } timer_type;
 174:../Libmaple/libmaple/libmaple/timer.h **** 
 175:../Libmaple/libmaple/libmaple/timer.h **** /** Timer device type */
 176:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_dev {
 177:../Libmaple/libmaple/libmaple/timer.h ****     timer_reg_map regs;         /**< Register map */
 178:../Libmaple/libmaple/libmaple/timer.h ****     rcc_clk_id clk_id;          /**< RCC clock information */
 179:../Libmaple/libmaple/libmaple/timer.h ****     timer_type type;            /**< Timer's type */
 180:../Libmaple/libmaple/libmaple/timer.h ****     voidFuncPtr handlers[];     /**< User IRQ handlers */
 181:../Libmaple/libmaple/libmaple/timer.h **** } timer_dev;
 182:../Libmaple/libmaple/libmaple/timer.h **** 
 183:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER1;
 184:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER2;
 185:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER3;
 186:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER4;
 187:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 188:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER5;
 189:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER6;
 190:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER7;
 191:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER8;
 192:../Libmaple/libmaple/libmaple/timer.h **** #endif
 193:../Libmaple/libmaple/libmaple/timer.h **** 
 194:../Libmaple/libmaple/libmaple/timer.h **** /*
 195:../Libmaple/libmaple/libmaple/timer.h ****  * Register bit definitions
 196:../Libmaple/libmaple/libmaple/timer.h ****  */
 197:../Libmaple/libmaple/libmaple/timer.h **** 
 198:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 1 (CR1) */
 199:../Libmaple/libmaple/libmaple/timer.h **** 
 200:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE_BIT              7
 201:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR_BIT               4
 202:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM_BIT               3
 203:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS_BIT               2
 204:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS_BIT              1
 205:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN_BIT               0
 206:../Libmaple/libmaple/libmaple/timer.h **** 
 207:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD                   (0x3 << 8)
 208:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_1TCKINT           (0x0 << 8)
 209:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_2TCKINT           (0x1 << 8)
 210:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_4TICKINT          (0x2 << 8)
 211:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE                  BIT(TIMER_CR1_ARPE_BIT)
 212:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS               (0x3 << 5)
 213:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_EDGE          (0x0 << 5)
 214:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER1       (0x1 << 5)
 215:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER2       (0x2 << 5)
 216:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER3       (0x3 << 5)
 217:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR                   BIT(TIMER_CR1_DIR_BIT)
 218:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM                   BIT(TIMER_CR1_OPM_BIT)
 219:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS                   BIT(TIMER_CR1_URS_BIT)
 220:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS                  BIT(TIMER_CR1_UDIS_BIT)
 221:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN                   BIT(TIMER_CR1_CEN_BIT)
 222:../Libmaple/libmaple/libmaple/timer.h **** 
 223:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 2 (CR2) */
 224:../Libmaple/libmaple/libmaple/timer.h **** 
 225:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4_BIT              14
 226:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N_BIT             13
 227:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3_BIT              12
 228:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N_BIT             11
 229:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2_BIT              10
 230:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N_BIT             9
 231:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1_BIT              8
 232:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S_BIT              7 /* tills? yikes */
 233:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS_BIT              3
 234:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS_BIT              2
 235:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC_BIT              0
 236:../Libmaple/libmaple/libmaple/timer.h **** 
 237:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4                  BIT(TIMER_CR2_OIS4_BIT)
 238:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N                 BIT(TIMER_CR2_OIS3N_BIT)
 239:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3                  BIT(TIMER_CR2_OIS3_BIT)
 240:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N                 BIT(TIMER_CR2_OIS2N_BIT)
 241:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2                  BIT(TIMER_CR2_OIS2_BIT)
 242:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N                 BIT(TIMER_CR2_OIS1N_BIT)
 243:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1                  BIT(TIMER_CR2_OIS1_BIT)
 244:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S                  BIT(TIMER_CR2_TI1S_BIT)
 245:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS                   (0x7 << 4)
 246:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_RESET             (0x0 << 4)
 247:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_ENABLE            (0x1 << 4)
 248:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_UPDATE            (0x2 << 4)
 249:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_PULSE     (0x3 << 4)
 250:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC1REF    (0x4 << 4)
 251:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC2REF    (0x5 << 4)
 252:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC3REF    (0x6 << 4)
 253:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC4REF    (0x7 << 4)
 254:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS                  BIT(TIMER_CR2_CCDS_BIT)
 255:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS                  BIT(TIMER_CR2_CCUS_BIT)
 256:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC                  BIT(TIMER_CR2_CCPC_BIT)
 257:../Libmaple/libmaple/libmaple/timer.h **** 
 258:../Libmaple/libmaple/libmaple/timer.h **** /* Slave mode control register (SMCR) */
 259:../Libmaple/libmaple/libmaple/timer.h **** 
 260:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP_BIT              15
 261:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE_BIT              14
 262:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM_BIT              7
 263:../Libmaple/libmaple/libmaple/timer.h **** 
 264:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP                  BIT(TIMER_SMCR_ETP_BIT)
 265:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE                  BIT(TIMER_SMCR_ECE_BIT)
 266:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS                 (0x3 << 12)
 267:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_OFF             (0x0 << 12)
 268:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV2            (0x1 << 12)
 269:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV4            (0x2 << 12)
 270:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV8            (0x3 << 12)
 271:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETF                  (0xF << 12)
 272:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM                  BIT(TIMER_SMCR_MSM_BIT)
 273:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS                   (0x3 << 4)
 274:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR0              (0x0 << 4)
 275:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR1              (0x1 << 4)
 276:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR2              (0x2 << 4)
 277:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR3              (0x3 << 4)
 278:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1F_ED           (0x4 << 4)
 279:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1FP1            (0x5 << 4)
 280:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI2FP2            (0x6 << 4)
 281:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ETRF              (0x7 << 4)
 282:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS                  0x3
 283:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_DISABLED         0x0
 284:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER1         0x1
 285:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER2         0x2
 286:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER3         0x3
 287:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_RESET            0x4
 288:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_GATED            0x5
 289:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_TRIGGER          0x6
 290:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_EXTERNAL         0x7
 291:../Libmaple/libmaple/libmaple/timer.h **** 
 292:../Libmaple/libmaple/libmaple/timer.h **** /* DMA/Interrupt enable register (DIER) */
 293:../Libmaple/libmaple/libmaple/timer.h **** 
 294:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE_BIT              14
 295:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE_BIT            12
 296:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE_BIT            11
 297:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE_BIT            10
 298:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE_BIT            9
 299:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE_BIT              8
 300:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE_BIT              6
 301:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE_BIT            4
 302:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE_BIT            3
 303:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE_BIT            2
 304:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE_BIT            1
 305:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE_BIT              0
 306:../Libmaple/libmaple/libmaple/timer.h **** 
 307:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE                  BIT(TIMER_DIER_TDE_BIT)
 308:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE                BIT(TIMER_DIER_CC4DE_BIT)
 309:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE                BIT(TIMER_DIER_CC3DE_BIT)
 310:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE                BIT(TIMER_DIER_CC2DE_BIT)
 311:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE                BIT(TIMER_DIER_CC1DE_BIT)
 312:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE                  BIT(TIMER_DIER_UDE_BIT)
 313:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE                  BIT(TIMER_DIER_TIE_BIT)
 314:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE                BIT(TIMER_DIER_CC4IE_BIT)
 315:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE                BIT(TIMER_DIER_CC3IE_BIT)
 316:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE                BIT(TIMER_DIER_CC2IE_BIT)
 317:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE                BIT(TIMER_DIER_CC1IE_BIT)
 318:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE                  BIT(TIMER_DIER_UIE_BIT)
 319:../Libmaple/libmaple/libmaple/timer.h **** 
 320:../Libmaple/libmaple/libmaple/timer.h **** /* Status register (SR) */
 321:../Libmaple/libmaple/libmaple/timer.h **** 
 322:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF_BIT              12
 323:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF_BIT              11
 324:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF_BIT              10
 325:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF_BIT              9
 326:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF_BIT                7
 327:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF_BIT                6
 328:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF_BIT              5
 329:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF_BIT              4
 330:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF_BIT              3
 331:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF_BIT              2
 332:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF_BIT              1
 333:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF_BIT                0
 334:../Libmaple/libmaple/libmaple/timer.h **** 
 335:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF                  BIT(TIMER_SR_CC4OF_BIT)
 336:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF                  BIT(TIMER_SR_CC3OF_BIT)
 337:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF                  BIT(TIMER_SR_CC2OF_BIT)
 338:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF                  BIT(TIMER_SR_CC1OF_BIT)
 339:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF                    BIT(TIMER_SR_BIF_BIT)
 340:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF                    BIT(TIMER_SR_TIF_BIT)
 341:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF                  BIT(TIMER_SR_COMIF_BIT)
 342:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF                  BIT(TIMER_SR_CC4IF_BIT)
 343:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF                  BIT(TIMER_SR_CC3IF_BIT)
 344:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF                  BIT(TIMER_SR_CC2IF_BIT)
 345:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF                  BIT(TIMER_SR_CC1IF_BIT)
 346:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF                    BIT(TIMER_SR_UIF_BIT)
 347:../Libmaple/libmaple/libmaple/timer.h **** 
 348:../Libmaple/libmaple/libmaple/timer.h **** /* Event generation register (EGR) */
 349:../Libmaple/libmaple/libmaple/timer.h **** 
 350:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG_BIT                6
 351:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G_BIT              4
 352:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G_BIT              3
 353:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G_BIT              2
 354:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G_BIT              1
 355:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG_BIT                0
 356:../Libmaple/libmaple/libmaple/timer.h **** 
 357:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG                    BIT(TIMER_EGR_TG_BIT)
 358:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G                  BIT(TIMER_EGR_CC4G_BIT)
 359:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G                  BIT(TIMER_EGR_CC3G_BIT)
 360:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G                  BIT(TIMER_EGR_CC2G_BIT)
 361:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G                  BIT(TIMER_EGR_CC1G_BIT)
 362:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG                    BIT(TIMER_EGR_UG_BIT)
 363:../Libmaple/libmaple/libmaple/timer.h **** 
 364:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode registers, common values */
 365:../Libmaple/libmaple/libmaple/timer.h **** 
 366:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_OUTPUT           0x0
 367:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI1        0x1
 368:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI2        0x2
 369:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TRC        0x3
 370:../Libmaple/libmaple/libmaple/timer.h **** 
 371:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 1 (CCMR1) */
 372:../Libmaple/libmaple/libmaple/timer.h **** 
 373:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE_BIT           15
 374:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE_BIT           11
 375:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE_BIT           10
 376:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE_BIT           7
 377:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE_BIT           3
 378:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE_BIT           2
 379:../Libmaple/libmaple/libmaple/timer.h **** 
 380:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE               BIT(TIMER_CCMR1_OC2CE_BIT)
 381:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2M                (0x3 << 12)
 382:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2F                (0xF << 12)
 383:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE               BIT(TIMER_CCMR1_OC2PE_BIT)
 384:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE               BIT(TIMER_CCMR1_OC2FE_BIT)
 385:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2PSC              (0x3 << 10)
 386:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S                (0x3 << 8)
 387:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 388:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 389:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 390:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 391:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE               BIT(TIMER_CCMR1_OC1CE_BIT)
 392:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1M                (0x3 << 4)
 393:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1F                (0xF << 4)
 394:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE               BIT(TIMER_CCMR1_OC1PE_BIT)
 395:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE               BIT(TIMER_CCMR1_OC1FE_BIT)
 396:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1PSC              (0x3 << 2)
 397:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S                0x3
 398:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 399:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 400:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 401:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 402:../Libmaple/libmaple/libmaple/timer.h **** 
 403:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 2 (CCMR2) */
 404:../Libmaple/libmaple/libmaple/timer.h **** 
 405:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE_BIT           15
 406:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE_BIT           11
 407:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE_BIT           10
 408:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE_BIT           7
 409:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE_BIT           3
 410:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE_BIT           2
 411:../Libmaple/libmaple/libmaple/timer.h **** 
 412:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE               BIT(TIMER_CCMR2_OC4CE_BIT)
 413:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4M                (0x3 << 12)
 414:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2F                (0xF << 12)
 415:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE               BIT(TIMER_CCMR2_OC4PE_BIT)
 416:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE               BIT(TIMER_CCMR2_OC4FE_BIT)
 417:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2PSC              (0x3 << 10)
 418:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC4S                (0x3 << 8)
 419:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 420:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 421:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 422:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 423:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE               BIT(TIMER_CCMR2_OC3CE_BIT)
 424:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3M                (0x3 << 4)
 425:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1F                (0xF << 4)
 426:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE               BIT(TIMER_CCMR2_OC3PE_BIT)
 427:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE               BIT(TIMER_CCMR2_OC3FE_BIT)
 428:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1PSC              (0x3 << 2)
 429:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC3S                0x3
 430:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 431:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 432:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 433:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 434:../Libmaple/libmaple/libmaple/timer.h **** 
 435:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare enable register (CCER) */
 436:../Libmaple/libmaple/libmaple/timer.h **** 
 437:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P_BIT             13
 438:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E_BIT             12
 439:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P_BIT             9
 440:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E_BIT             8
 441:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P_BIT             5
 442:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E_BIT             4
 443:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P_BIT             1
 444:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E_BIT             0
 445:../Libmaple/libmaple/libmaple/timer.h **** 
 446:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P                 BIT(TIMER_CCER_CC4P_BIT)
 447:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E                 BIT(TIMER_CCER_CC4E_BIT)
 448:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P                 BIT(TIMER_CCER_CC3P_BIT)
 449:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E                 BIT(TIMER_CCER_CC3E_BIT)
 450:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P                 BIT(TIMER_CCER_CC2P_BIT)
 451:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E                 BIT(TIMER_CCER_CC2E_BIT)
 452:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P                 BIT(TIMER_CCER_CC1P_BIT)
 453:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E                 BIT(TIMER_CCER_CC1E_BIT)
 454:../Libmaple/libmaple/libmaple/timer.h **** 
 455:../Libmaple/libmaple/libmaple/timer.h **** /* Break and dead-time register (BDTR) */
 456:../Libmaple/libmaple/libmaple/timer.h **** 
 457:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE_BIT              15
 458:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE_BIT              14
 459:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP_BIT              13
 460:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE_BIT              12
 461:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR_BIT             11
 462:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI_BIT             10
 463:../Libmaple/libmaple/libmaple/timer.h **** 
 464:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE                  BIT(TIMER_BDTR_MOE_BIT)
 465:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE                  BIT(TIMER_BDTR_AOE_BIT)
 466:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP                  BIT(TIMER_BDTR_BKP_BIT)
 467:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE                  BIT(TIMER_BDTR_BKE_BIT)
 468:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR                 BIT(TIMER_BDTR_OSSR_BIT)
 469:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI                 BIT(TIMER_BDTR_OSSI_BIT)
 470:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK                 (0x3 << 8)
 471:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_OFF             (0x0 << 8)
 472:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL1          (0x1 << 8)
 473:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL2          (0x2 << 8)
 474:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL3          (0x3 << 8)
 475:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_DTG                  0xFF
 476:../Libmaple/libmaple/libmaple/timer.h **** 
 477:../Libmaple/libmaple/libmaple/timer.h **** /* DMA control register (DCR) */
 478:../Libmaple/libmaple/libmaple/timer.h **** 
 479:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL                   (0x1F << 8)
 480:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_1BYTE             (0x0 << 8)
 481:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_2BYTE             (0x1 << 8)
 482:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_3BYTE             (0x2 << 8)
 483:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_4BYTE             (0x3 << 8)
 484:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_5BYTE             (0x4 << 8)
 485:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_6BYTE             (0x5 << 8)
 486:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_7BYTE             (0x6 << 8)
 487:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_8BYTE             (0x7 << 8)
 488:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_9BYTE             (0x8 << 8)
 489:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_10BYTE            (0x9 << 8)
 490:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_11BYTE            (0xA << 8)
 491:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_12BYTE            (0xB << 8)
 492:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_13BYTE            (0xC << 8)
 493:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_14BYTE            (0xD << 8)
 494:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_15BYTE            (0xE << 8)
 495:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_16BYTE            (0xF << 8)
 496:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_17BYTE            (0x10 << 8)
 497:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_18BYTE            (0x11 << 8)
 498:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA                   0x1F
 499:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR1               0x0
 500:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR2               0x1
 501:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SMCR              0x2
 502:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DIER              0x3
 503:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SR                0x4
 504:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_EGR               0x5
 505:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR1             0x6
 506:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR2             0x7
 507:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCER              0x8
 508:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CNT               0x9
 509:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_PSC               0xA
 510:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_ARR               0xB
 511:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_RCR               0xC
 512:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR1              0xD
 513:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR2              0xE
 514:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR3              0xF
 515:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR4              0x10
 516:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_BDTR              0x11
 517:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DCR               0x12
 518:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DMAR              0x13
 519:../Libmaple/libmaple/libmaple/timer.h **** 
 520:../Libmaple/libmaple/libmaple/timer.h **** /*
 521:../Libmaple/libmaple/libmaple/timer.h ****  * Convenience routines
 522:../Libmaple/libmaple/libmaple/timer.h ****  */
 523:../Libmaple/libmaple/libmaple/timer.h **** 
 524:../Libmaple/libmaple/libmaple/timer.h **** /**
 525:../Libmaple/libmaple/libmaple/timer.h ****  * Used to configure the behavior of a timer channel.  Note that not
 526:../Libmaple/libmaple/libmaple/timer.h ****  * all timers can be configured in every mode.
 527:../Libmaple/libmaple/libmaple/timer.h ****  */
 528:../Libmaple/libmaple/libmaple/timer.h **** /* TODO TIMER_PWM_CENTER_ALIGNED, TIMER_INPUT_CAPTURE, TIMER_ONE_PULSE */
 529:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_mode {
 530:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_DISABLED, /**< In this mode, the timer stops counting,
 531:../Libmaple/libmaple/libmaple/timer.h ****                          channel interrupts are detached, and no state
 532:../Libmaple/libmaple/libmaple/timer.h ****                          changes are output. */
 533:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_PWM, /**< PWM output mode. This is the default mode for pins
 534:../Libmaple/libmaple/libmaple/timer.h ****                     after initialization. */
 535:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_PWM_CENTER_ALIGNED, /\**< Center-aligned PWM output mode. *\/ */
 536:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_OUTPUT_COMPARE, /**< In this mode, the timer counts from 0
 537:../Libmaple/libmaple/libmaple/timer.h ****                                to its reload value repeatedly; every
 538:../Libmaple/libmaple/libmaple/timer.h ****                                time the counter value reaches one of
 539:../Libmaple/libmaple/libmaple/timer.h ****                                the channel compare values, the
 540:../Libmaple/libmaple/libmaple/timer.h ****                                corresponding interrupt is fired. */
 541:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_INPUT_CAPTURE, /\**< In this mode, the timer can measure the */
 542:../Libmaple/libmaple/libmaple/timer.h ****     /*                           pulse lengths of input signals. *\/ */
 543:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_ONE_PULSE /\**< In this mode, the timer can generate a single */
 544:../Libmaple/libmaple/libmaple/timer.h ****     /*                      pulse on a GPIO pin for a specified amount of */
 545:../Libmaple/libmaple/libmaple/timer.h ****     /*                      time. *\/ */
 546:../Libmaple/libmaple/libmaple/timer.h **** } timer_mode;
 547:../Libmaple/libmaple/libmaple/timer.h **** 
 548:../Libmaple/libmaple/libmaple/timer.h **** /** Timer channel numbers */
 549:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_channel {
 550:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH1 = 1, /**< Channel 1 */
 551:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH2 = 2, /**< Channel 2 */
 552:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH3 = 3, /**< Channel 3 */
 553:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH4 = 4  /**< Channel 4 */
 554:../Libmaple/libmaple/libmaple/timer.h **** } timer_channel;
 555:../Libmaple/libmaple/libmaple/timer.h **** 
 556:../Libmaple/libmaple/libmaple/timer.h **** /*
 557:../Libmaple/libmaple/libmaple/timer.h ****  * Note: Don't require timer_channel arguments! We want to be able to say
 558:../Libmaple/libmaple/libmaple/timer.h ****  *
 559:../Libmaple/libmaple/libmaple/timer.h ****  * for (int channel = 1; channel <= 4; channel++) {
 560:../Libmaple/libmaple/libmaple/timer.h ****  *    ...
 561:../Libmaple/libmaple/libmaple/timer.h ****  * }
 562:../Libmaple/libmaple/libmaple/timer.h ****  *
 563:../Libmaple/libmaple/libmaple/timer.h ****  * without the compiler yelling at us.
 564:../Libmaple/libmaple/libmaple/timer.h ****  */
 565:../Libmaple/libmaple/libmaple/timer.h **** 
 566:../Libmaple/libmaple/libmaple/timer.h **** void timer_init(timer_dev *dev);
 567:../Libmaple/libmaple/libmaple/timer.h **** void timer_disable(timer_dev *dev);
 568:../Libmaple/libmaple/libmaple/timer.h **** void timer_set_mode(timer_dev *dev, uint8 channel, timer_mode mode);
 569:../Libmaple/libmaple/libmaple/timer.h **** void timer_foreach(void (*fn)(timer_dev*));
 570:../Libmaple/libmaple/libmaple/timer.h **** 
 571:../Libmaple/libmaple/libmaple/timer.h **** /**
 572:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer interrupt number.
 573:../Libmaple/libmaple/libmaple/timer.h ****  *
 574:../Libmaple/libmaple/libmaple/timer.h ****  * Not all timers support all of these values; see the descriptions
 575:../Libmaple/libmaple/libmaple/timer.h ****  * for each value.
 576:../Libmaple/libmaple/libmaple/timer.h ****  */
 577:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_interrupt_id {
 578:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_UPDATE_INTERRUPT, /**< Update interrupt, available on all timers. */
 579:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC1_INTERRUPT, /**< Capture/compare 1 interrupt, available
 580:../Libmaple/libmaple/libmaple/timer.h ****                               on general and advanced timers only. */
 581:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC2_INTERRUPT, /**< Capture/compare 2 interrupt, general and
 582:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 583:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC3_INTERRUPT, /**< Capture/compare 3 interrupt, general and
 584:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 585:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC4_INTERRUPT, /**< Capture/compare 4 interrupt, general and
 586:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 587:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_COM_INTERRUPT, /**< COM interrupt, advanced timers only */
 588:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_TRG_INTERRUPT, /**< Trigger interrupt, general and advanced
 589:../Libmaple/libmaple/libmaple/timer.h ****                               timers only */
 590:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BREAK_INTERRUPT /**< Break interrupt, advanced timers only. */
 591:../Libmaple/libmaple/libmaple/timer.h **** } timer_interrupt_id;
 592:../Libmaple/libmaple/libmaple/timer.h **** 
 593:../Libmaple/libmaple/libmaple/timer.h **** void timer_attach_interrupt(timer_dev *dev,
 594:../Libmaple/libmaple/libmaple/timer.h ****                             uint8 interrupt,
 595:../Libmaple/libmaple/libmaple/timer.h ****                             voidFuncPtr handler);
 596:../Libmaple/libmaple/libmaple/timer.h **** void timer_detach_interrupt(timer_dev *dev, uint8 interrupt);
 597:../Libmaple/libmaple/libmaple/timer.h **** 
 598:../Libmaple/libmaple/libmaple/timer.h **** /**
 599:../Libmaple/libmaple/libmaple/timer.h ****  * Initialize all timer devices on the chip.
 600:../Libmaple/libmaple/libmaple/timer.h ****  */
 601:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_init_all(void) {
 602:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_init);
 603:../Libmaple/libmaple/libmaple/timer.h **** }
 604:../Libmaple/libmaple/libmaple/timer.h **** 
 605:../Libmaple/libmaple/libmaple/timer.h **** /**
 606:../Libmaple/libmaple/libmaple/timer.h ****  * Disables all timers on the device.
 607:../Libmaple/libmaple/libmaple/timer.h ****  */
 608:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_disable_all(void) {
 609:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_disable);
 610:../Libmaple/libmaple/libmaple/timer.h **** }
 611:../Libmaple/libmaple/libmaple/timer.h **** 
 612:../Libmaple/libmaple/libmaple/timer.h **** /**
 613:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Stop a timer's counter from changing.
 614:../Libmaple/libmaple/libmaple/timer.h ****  *
 615:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 616:../Libmaple/libmaple/libmaple/timer.h ****  *
 617:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to pause.
 618:../Libmaple/libmaple/libmaple/timer.h ****  */
 619:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_pause(timer_dev *dev) {
 620:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 0;
 621:../Libmaple/libmaple/libmaple/timer.h **** }
 622:../Libmaple/libmaple/libmaple/timer.h **** 
 623:../Libmaple/libmaple/libmaple/timer.h **** /**
 624:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Start a timer's counter.
 625:../Libmaple/libmaple/libmaple/timer.h ****  *
 626:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 627:../Libmaple/libmaple/libmaple/timer.h ****  *
 628:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to resume
 629:../Libmaple/libmaple/libmaple/timer.h ****  */
 630:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_resume(timer_dev *dev) {
 631:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 1;
 632:../Libmaple/libmaple/libmaple/timer.h **** }
 633:../Libmaple/libmaple/libmaple/timer.h **** 
 634:../Libmaple/libmaple/libmaple/timer.h **** /**
 635:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the timer's counter value.
 636:../Libmaple/libmaple/libmaple/timer.h ****  *
 637:../Libmaple/libmaple/libmaple/timer.h ****  * This value is likely to be inaccurate if the counter is running
 638:../Libmaple/libmaple/libmaple/timer.h ****  * with a low prescaler.
 639:../Libmaple/libmaple/libmaple/timer.h ****  *
 640:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to return
 641:../Libmaple/libmaple/libmaple/timer.h ****  */
 642:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_count(timer_dev *dev) {
 643:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->CNT;
 644:../Libmaple/libmaple/libmaple/timer.h **** }
 645:../Libmaple/libmaple/libmaple/timer.h **** 
 646:../Libmaple/libmaple/libmaple/timer.h **** /**
 647:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Sets the counter value for the given timer.
 648:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to set
 649:../Libmaple/libmaple/libmaple/timer.h ****  * @param value New counter value
 650:../Libmaple/libmaple/libmaple/timer.h ****  */
 651:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_count(timer_dev *dev, uint16 value) {
 652:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->CNT = value;
 653:../Libmaple/libmaple/libmaple/timer.h **** }
 654:../Libmaple/libmaple/libmaple/timer.h **** 
 655:../Libmaple/libmaple/libmaple/timer.h **** /**
 656:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the given timer's prescaler.
 657:../Libmaple/libmaple/libmaple/timer.h ****  *
 658:../Libmaple/libmaple/libmaple/timer.h ****  * Note that if the timer's prescaler is set (e.g. via
 659:../Libmaple/libmaple/libmaple/timer.h ****  * timer_set_prescaler() or accessing a TIMx_PSC register), the value
 660:../Libmaple/libmaple/libmaple/timer.h ****  * returned by this function will reflect the new setting, but the
 661:../Libmaple/libmaple/libmaple/timer.h ****  * timer's counter will only reflect the new prescaler at the next
 662:../Libmaple/libmaple/libmaple/timer.h ****  * update event.
 663:../Libmaple/libmaple/libmaple/timer.h ****  *
 664:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to return
 665:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 666:../Libmaple/libmaple/libmaple/timer.h ****  */
 667:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_prescaler(timer_dev *dev) {
 668:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->PSC;
 669:../Libmaple/libmaple/libmaple/timer.h **** }
 670:../Libmaple/libmaple/libmaple/timer.h **** 
 671:../Libmaple/libmaple/libmaple/timer.h **** /**
 672:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's prescale value.
 673:../Libmaple/libmaple/libmaple/timer.h ****  *
 674:../Libmaple/libmaple/libmaple/timer.h ****  * Divides the input clock by (PSC+1).  The new value will not take
 675:../Libmaple/libmaple/libmaple/timer.h ****  * effect until the next update event.
 676:../Libmaple/libmaple/libmaple/timer.h ****  *
 677:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to set
 678:../Libmaple/libmaple/libmaple/timer.h ****  * @param psc New prescaler value
 679:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 680:../Libmaple/libmaple/libmaple/timer.h ****  */
 681:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_prescaler(timer_dev *dev, uint16 psc) {
 160              		.loc 3 681 0
 161              		.cfi_startproc
 162              		@ args = 0, pretend = 0, frame = 0
 163              		@ frame_needed = 0, uses_anonymous_args = 0
 164              		@ link register save eliminated.
 165              	.LVL5:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 166              		.loc 3 682 0
 167 0000 8162     		str	r1, [r0, #40]
 683:../Libmaple/libmaple/libmaple/timer.h **** }
 168              		.loc 3 683 0
 169 0002 7047     		bx	lr
 170              		.cfi_endproc
 171              	.LFE249:
 173              		.section	.text.timer_set_reload.isra.1,"ax",%progbits
 174              		.align	1
 175              		.thumb
 176              		.thumb_func
 178              	timer_set_reload.isra.1:
 179              	.LFB250:
 684:../Libmaple/libmaple/libmaple/timer.h **** 
 685:../Libmaple/libmaple/libmaple/timer.h **** /**
 686:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns a timer's reload value.
 687:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to return
 688:../Libmaple/libmaple/libmaple/timer.h ****  */
 689:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_reload(timer_dev *dev) {
 690:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->ARR;
 691:../Libmaple/libmaple/libmaple/timer.h **** }
 692:../Libmaple/libmaple/libmaple/timer.h **** 
 693:../Libmaple/libmaple/libmaple/timer.h **** /**
 694:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's reload value.
 695:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to set
 696:../Libmaple/libmaple/libmaple/timer.h ****  * @param arr New reload value to use.  Takes effect at next update event.
 697:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 698:../Libmaple/libmaple/libmaple/timer.h ****  */
 699:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_reload(timer_dev *dev, uint16 arr) {
 180              		.loc 3 699 0
 181              		.cfi_startproc
 182              		@ args = 0, pretend = 0, frame = 0
 183              		@ frame_needed = 0, uses_anonymous_args = 0
 184              		@ link register save eliminated.
 185              	.LVL6:
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 186              		.loc 3 700 0
 187 0000 C162     		str	r1, [r0, #44]
 701:../Libmaple/libmaple/libmaple/timer.h **** }
 188              		.loc 3 701 0
 189 0002 7047     		bx	lr
 190              		.cfi_endproc
 191              	.LFE250:
 193              		.section	.text.timer_set_compare.isra.2,"ax",%progbits
 194              		.align	1
 195              		.thumb
 196              		.thumb_func
 198              	timer_set_compare.isra.2:
 199              	.LFB251:
 702:../Libmaple/libmaple/libmaple/timer.h **** 
 703:../Libmaple/libmaple/libmaple/timer.h **** /**
 704:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Get the compare value for the given timer channel.
 705:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 706:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to get.
 707:../Libmaple/libmaple/libmaple/timer.h ****  */
 708:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_compare(timer_dev *dev, uint8 channel) {
 709:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 710:../Libmaple/libmaple/libmaple/timer.h ****     return *ccr;
 711:../Libmaple/libmaple/libmaple/timer.h **** }
 712:../Libmaple/libmaple/libmaple/timer.h **** 
 713:../Libmaple/libmaple/libmaple/timer.h **** /**
 714:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set the compare value for the given timer channel.
 715:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 716:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to set.
 717:../Libmaple/libmaple/libmaple/timer.h ****  * @param value   New compare value.
 718:../Libmaple/libmaple/libmaple/timer.h ****  */
 719:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_compare(timer_dev *dev,
 200              		.loc 3 719 0
 201              		.cfi_startproc
 202              		@ args = 0, pretend = 0, frame = 0
 203              		@ frame_needed = 0, uses_anonymous_args = 0
 204              		@ link register save eliminated.
 205              	.LVL7:
 206              	.LBB13:
 720:../Libmaple/libmaple/libmaple/timer.h ****                                      uint8 channel,
 721:../Libmaple/libmaple/libmaple/timer.h ****                                      uint16 value) {
 722:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 207              		.loc 3 722 0
 208 0000 3430     		adds	r0, r0, #52
 209 0002 0139     		subs	r1, r1, #1
 210              	.LVL8:
 723:../Libmaple/libmaple/libmaple/timer.h ****     *ccr = value;
 211              		.loc 3 723 0
 212 0004 40F82120 		str	r2, [r0, r1, lsl #2]
 213              	.LBE13:
 724:../Libmaple/libmaple/libmaple/timer.h **** }
 214              		.loc 3 724 0
 215 0008 7047     		bx	lr
 216              		.cfi_endproc
 217              	.LFE251:
 219              		.section	.text.timer_generate_update.isra.3,"ax",%progbits
 220              		.align	1
 221              		.thumb
 222              		.thumb_func
 224              	timer_generate_update.isra.3:
 225              	.LFB252:
 725:../Libmaple/libmaple/libmaple/timer.h **** 
 726:../Libmaple/libmaple/libmaple/timer.h **** /**
 727:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Generate an update event for the given timer.
 728:../Libmaple/libmaple/libmaple/timer.h ****  *
 729:../Libmaple/libmaple/libmaple/timer.h ****  * Normally, this will cause the prescaler and auto-reload values in
 730:../Libmaple/libmaple/libmaple/timer.h ****  * the PSC and ARR registers to take immediate effect.  However, this
 731:../Libmaple/libmaple/libmaple/timer.h ****  * function will do nothing if the UDIS bit is set in the timer's CR1
 732:../Libmaple/libmaple/libmaple/timer.h ****  * register (UDIS is cleared by default).
 733:../Libmaple/libmaple/libmaple/timer.h ****  *
 734:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device to generate an update for.
 735:../Libmaple/libmaple/libmaple/timer.h ****  */
 736:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_generate_update(timer_dev *dev) {
 226              		.loc 3 736 0
 227              		.cfi_startproc
 228              		@ args = 0, pretend = 0, frame = 0
 229              		@ frame_needed = 0, uses_anonymous_args = 0
 230              		@ link register save eliminated.
 231              	.LVL9:
 232              	.LBB18:
 233              	.LBB19:
 234              	.LBB20:
 235              	.LBB21:
 236              		.file 4 "../Libmaple/libmaple/libmaple/bitband.h"
   1:../Libmaple/libmaple/libmaple/bitband.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/bitband.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/bitband.h ****  *
   4:../Libmaple/libmaple/libmaple/bitband.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/bitband.h ****  *
   6:../Libmaple/libmaple/libmaple/bitband.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/bitband.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/bitband.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/bitband.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/bitband.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/bitband.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/bitband.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/bitband.h ****  *
  14:../Libmaple/libmaple/libmaple/bitband.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/bitband.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/bitband.h ****  *
  17:../Libmaple/libmaple/libmaple/bitband.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/bitband.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/bitband.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/bitband.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/bitband.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/bitband.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/bitband.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/bitband.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/bitband.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/bitband.h **** 
  27:../Libmaple/libmaple/libmaple/bitband.h **** /**
  28:../Libmaple/libmaple/libmaple/bitband.h ****  * @file bitband.h
  29:../Libmaple/libmaple/libmaple/bitband.h ****  *
  30:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Bit-banding utility functions
  31:../Libmaple/libmaple/libmaple/bitband.h ****  */
  32:../Libmaple/libmaple/libmaple/bitband.h **** 
  33:../Libmaple/libmaple/libmaple/bitband.h **** #include "libmaple_types.h"
  34:../Libmaple/libmaple/libmaple/bitband.h **** 
  35:../Libmaple/libmaple/libmaple/bitband.h **** #ifndef _BITBAND_H_
  36:../Libmaple/libmaple/libmaple/bitband.h **** #define _BITBAND_H_
  37:../Libmaple/libmaple/libmaple/bitband.h **** 
  38:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_REF      0x20000000
  39:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_BASE     0x22000000
  40:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_REF      0x40000000
  41:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_BASE     0x42000000
  42:../Libmaple/libmaple/libmaple/bitband.h **** 
  43:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void*,
  44:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  45:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  46:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32);
  47:../Libmaple/libmaple/libmaple/bitband.h **** 
  48:../Libmaple/libmaple/libmaple/bitband.h **** /**
  49:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  50:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a volatile SRAM address.
  51:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded SRAM region
  52:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  53:../Libmaple/libmaple/libmaple/bitband.h ****  */
  54:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_sramp(volatile void *address, uint32 bit) {
  55:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_SRAM_BASE, BB_SRAM_REF);
  56:../Libmaple/libmaple/libmaple/bitband.h **** }
  57:../Libmaple/libmaple/libmaple/bitband.h **** 
  58:../Libmaple/libmaple/libmaple/bitband.h **** /**
  59:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the SRAM bit-band region.
  60:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to read from
  61:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  62:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  63:../Libmaple/libmaple/libmaple/bitband.h ****  */
  64:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_sram_get_bit(volatile void *address, uint32 bit) {
  65:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_sramp(address, bit);
  66:../Libmaple/libmaple/libmaple/bitband.h **** }
  67:../Libmaple/libmaple/libmaple/bitband.h **** 
  68:../Libmaple/libmaple/libmaple/bitband.h **** /**
  69:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the SRAM bit-band region.
  70:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to write to
  71:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
  72:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
  73:../Libmaple/libmaple/libmaple/bitband.h ****  */
  74:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_sram_set_bit(volatile void *address,
  75:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
  76:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
  77:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_sramp(address, bit) = val;
  78:../Libmaple/libmaple/libmaple/bitband.h **** }
  79:../Libmaple/libmaple/libmaple/bitband.h **** 
  80:../Libmaple/libmaple/libmaple/bitband.h **** /**
  81:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  82:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a peripheral address.
  83:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded peripheral region
  84:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  85:../Libmaple/libmaple/libmaple/bitband.h ****  */
  86:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_perip(volatile void *address, uint32 bit) {
  87:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_PERI_BASE, BB_PERI_REF);
  88:../Libmaple/libmaple/libmaple/bitband.h **** }
  89:../Libmaple/libmaple/libmaple/bitband.h **** 
  90:../Libmaple/libmaple/libmaple/bitband.h **** /**
  91:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the peripheral bit-band region.
  92:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to read from
  93:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  94:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  95:../Libmaple/libmaple/libmaple/bitband.h ****  */
  96:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_peri_get_bit(volatile void *address, uint32 bit) {
  97:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_perip(address, bit);
  98:../Libmaple/libmaple/libmaple/bitband.h **** }
  99:../Libmaple/libmaple/libmaple/bitband.h **** 
 100:../Libmaple/libmaple/libmaple/bitband.h **** /**
 101:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the peripheral bit-band region.
 102:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to write to
 103:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
 104:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
 105:../Libmaple/libmaple/libmaple/bitband.h ****  */
 106:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_peri_set_bit(volatile void *address,
 107:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
 108:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
 109:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_perip(address, bit) = val;
 110:../Libmaple/libmaple/libmaple/bitband.h **** }
 111:../Libmaple/libmaple/libmaple/bitband.h **** 
 112:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void *address,
 113:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bit,
 114:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_base,
 115:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_ref) {
 116:../Libmaple/libmaple/libmaple/bitband.h ****     return (volatile uint32*)(bb_base + ((uint32)address - bb_ref) * 32 +
 117:../Libmaple/libmaple/libmaple/bitband.h ****                               bit * 4);
 237              		.loc 4 117 0
 238 0000 4101     		lsls	r1, r0, #5
 239 0002 01F18440 		add	r0, r1, #1107296256
 240              	.LBE21:
 241              	.LBE20:
 242              	.LBE19:
 243              	.LBE18:
 737:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->EGR, TIMER_EGR_UG_BIT) = 1;
 244              		.loc 3 737 0
 245 0006 0123     		movs	r3, #1
 246 0008 C0F88032 		str	r3, [r0, #640]
 738:../Libmaple/libmaple/libmaple/timer.h **** }
 247              		.loc 3 738 0
 248 000c 7047     		bx	lr
 249              		.cfi_endproc
 250              	.LFE252:
 252              		.section	.text.startup._Z7premainv,"ax",%progbits
 253              		.align	1
 254              		.global	_Z7premainv
 255              		.thumb
 256              		.thumb_func
 258              	_Z7premainv:
 259              	.LFB114:
 260              		.file 5 "/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp"
   1:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** #include <../AeroQuad/UserConfiguration.h>
   2:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** #include <SerialMapping.h>
   3:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** #include <WProgram.h>
   4:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
   5:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** __attribute__(( constructor )) void premain() {
 261              		.loc 5 5 0
 262              		.cfi_startproc
 263              		@ args = 0, pretend = 0, frame = 0
 264              		@ frame_needed = 0, uses_anonymous_args = 0
 265              		@ link register save eliminated.
   6:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp ****     init();
   7:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** }
 266              		.loc 5 7 0
   6:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp ****     init();
 267              		.loc 5 6 0
 268 0000 FFF7FEBF 		b	_Z4initv
 269              		.cfi_endproc
 270              	.LFE114:
 272              		.section	.init_array,"aw",%init_array
 273              		.align	2
 274 0000 00000000 		.word	_Z7premainv(target1)
 275              		.section	.text._init,"ax",%progbits
 276              		.align	1
 277              		.global	_init
 278              		.thumb
 279              		.thumb_func
 281              	_init:
 282              	.LFB115:
   8:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
   9:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** extern "C"{
  10:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp ****         void _init(){};
 283              		.loc 5 10 0
 284              		.cfi_startproc
 285              		@ args = 0, pretend = 0, frame = 0
 286              		@ frame_needed = 0, uses_anonymous_args = 0
 287              		@ link register save eliminated.
 288              		.loc 5 10 0
 289 0000 7047     		bx	lr
 290              		.cfi_endproc
 291              	.LFE115:
 293              		.section	.text._Z23initializeReceiverParami,"ax",%progbits
 294              		.align	1
 295              		.global	_Z23initializeReceiverParami
 296              		.thumb
 297              		.thumb_func
 299              	_Z23initializeReceiverParami:
 300              	.LFB123:
 301              		.file 6 "../Libraries/AQ_Receiver/Receiver.h"
   1:../Libraries/AQ_Receiver/Receiver.h **** /*
   2:../Libraries/AQ_Receiver/Receiver.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Receiver/Receiver.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Receiver/Receiver.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Receiver/Receiver.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Receiver/Receiver.h ****  
   7:../Libraries/AQ_Receiver/Receiver.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Receiver/Receiver.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Receiver/Receiver.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Receiver/Receiver.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Receiver/Receiver.h **** 
  12:../Libraries/AQ_Receiver/Receiver.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Receiver/Receiver.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Receiver/Receiver.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Receiver/Receiver.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Receiver/Receiver.h **** 
  17:../Libraries/AQ_Receiver/Receiver.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Receiver/Receiver.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Receiver/Receiver.h **** */
  20:../Libraries/AQ_Receiver/Receiver.h **** 
  21:../Libraries/AQ_Receiver/Receiver.h **** #ifndef _AEROQUAD_RECEIVER_H_
  22:../Libraries/AQ_Receiver/Receiver.h **** #define _AEROQUAD_RECEIVER_H_
  23:../Libraries/AQ_Receiver/Receiver.h **** 
  24:../Libraries/AQ_Receiver/Receiver.h **** #include "Arduino.h"
  25:../Libraries/AQ_Receiver/Receiver.h **** 
  26:../Libraries/AQ_Receiver/Receiver.h **** #define PWM2RAD 0.002 //  Based upon 5RAD for full stick movement, you take this times the RAD to g
  27:../Libraries/AQ_Receiver/Receiver.h **** 
  28:../Libraries/AQ_Receiver/Receiver.h **** // Receiver variables
  29:../Libraries/AQ_Receiver/Receiver.h **** #define TIMEOUT 25000
  30:../Libraries/AQ_Receiver/Receiver.h **** #define MINCOMMAND 1000
  31:../Libraries/AQ_Receiver/Receiver.h **** #define MIDCOMMAND 1500
  32:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCOMMAND 2000
  33:../Libraries/AQ_Receiver/Receiver.h **** #define MINDELTA 200
  34:../Libraries/AQ_Receiver/Receiver.h **** #define MINCHECK (MINCOMMAND + 100)
  35:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCHECK (MAXCOMMAND - 100)
  36:../Libraries/AQ_Receiver/Receiver.h **** #define MINTHROTTLE (MINCOMMAND + 100)
  37:../Libraries/AQ_Receiver/Receiver.h **** #define LEVELOFF 100
  38:../Libraries/AQ_Receiver/Receiver.h **** #define MAX_NB_CHANNEL 10
  39:../Libraries/AQ_Receiver/Receiver.h **** 
  40:../Libraries/AQ_Receiver/Receiver.h **** int lastReceiverChannel = 0;
  41:../Libraries/AQ_Receiver/Receiver.h **** 
  42:../Libraries/AQ_Receiver/Receiver.h **** float receiverXmitFactor = 0.0;
  43:../Libraries/AQ_Receiver/Receiver.h **** int receiverData[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0};
  44:../Libraries/AQ_Receiver/Receiver.h **** int receiverZero[3] = {0,0,0};
  45:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommand[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0};
  46:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommandSmooth[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0,};
  47:../Libraries/AQ_Receiver/Receiver.h **** float receiverSlope[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  48:../Libraries/AQ_Receiver/Receiver.h **** float receiverOffset[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  49:../Libraries/AQ_Receiver/Receiver.h **** float receiverSmoothFactor[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  50:../Libraries/AQ_Receiver/Receiver.h **** int channelCal;
  51:../Libraries/AQ_Receiver/Receiver.h **** 
  52:../Libraries/AQ_Receiver/Receiver.h **** void initializeReceiverParam(int nbChannel = 6) {
 302              		.loc 6 52 0
 303              		.cfi_startproc
 304              		@ args = 0, pretend = 0, frame = 0
 305              		@ frame_needed = 0, uses_anonymous_args = 0
 306              		@ link register save eliminated.
 307              	.LVL10:
 308              	.LBB22:
  53:../Libraries/AQ_Receiver/Receiver.h ****   
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 309              		.loc 6 54 0
 310 0000 254A     		ldr	r2, .L28
  55:../Libraries/AQ_Receiver/Receiver.h **** 
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 311              		.loc 6 56 0
 312 0002 264B     		ldr	r3, .L28+4
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 313              		.loc 6 54 0
 314 0004 1060     		str	r0, [r2, #0]
 315              		.loc 6 56 0
 316 0006 40F2DC51 		movw	r1, #1500
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
  59:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[THROTTLE] = 1000;
 317              		.loc 6 59 0
 318 000a 4FF47A72 		mov	r2, #1000
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 319              		.loc 6 56 0
 320 000e 1960     		str	r1, [r3, #0]
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
 321              		.loc 6 57 0
 322 0010 5960     		str	r1, [r3, #4]
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
 323              		.loc 6 58 0
 324 0012 9960     		str	r1, [r3, #8]
 325              		.loc 6 59 0
 326 0014 DA60     		str	r2, [r3, #12]
  60:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[MODE] = 1000;
 327              		.loc 6 60 0
 328 0016 1A61     		str	r2, [r3, #16]
  61:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX1] = 1000;
 329              		.loc 6 61 0
 330 0018 5A61     		str	r2, [r3, #20]
  62:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX2] = 1000;
 331              		.loc 6 62 0
 332 001a 9A61     		str	r2, [r3, #24]
  63:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX3] = 1000;
 333              		.loc 6 63 0
 334 001c DA61     		str	r2, [r3, #28]
  64:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX4] = 1000;
 335              		.loc 6 64 0
 336 001e 1A62     		str	r2, [r3, #32]
  65:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX5] = 1000;
 337              		.loc 6 65 0
 338 0020 5A62     		str	r2, [r3, #36]
 339              	.LVL11:
 340              	.LBB23:
  66:../Libraries/AQ_Receiver/Receiver.h ****   
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 341              		.loc 6 67 0
 342 0022 0023     		movs	r3, #0
 343 0024 07E0     		b	.L20
 344              	.LVL12:
 345              	.L21:
  68:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = 1.0;
 346              		.loc 6 68 0 discriminator 2
 347 0026 0121     		movs	r1, #1
 348 0028 1D4A     		ldr	r2, .L28+8
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 349              		.loc 6 67 0 discriminator 2
 350 002a 03EB010C 		add	ip, r3, r1
 351              		.loc 6 68 0 discriminator 2
 352 002e 42F82310 		str	r1, [r2, r3, lsl #2]
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 353              		.loc 6 67 0 discriminator 2
 354 0032 5FFA8CF3 		uxtb	r3, ip
 355              	.LVL13:
 356              	.L20:
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 357              		.loc 6 67 0 is_stmt 0 discriminator 1
 358 0036 8342     		cmp	r3, r0
 359 0038 F5DB     		blt	.L21
 360              	.LVL14:
 361              	.LBE23:
 362              	.LBB24:
  69:../Libraries/AQ_Receiver/Receiver.h ****   }
  70:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
  71:../Libraries/AQ_Receiver/Receiver.h ****     receiverZero[channel] = 1500;
 363              		.loc 6 71 0 is_stmt 1 discriminator 1
 364 003a 1A4B     		ldr	r3, .L28+12
 365              	.LVL15:
 366 003c 40F2DC51 		movw	r1, #1500
 367 0040 1960     		str	r1, [r3, #0]
 368              	.LVL16:
 369 0042 5960     		str	r1, [r3, #4]
 370              	.LVL17:
 371 0044 9960     		str	r1, [r3, #8]
 372              	.LVL18:
 373 0046 0023     		movs	r3, #0
 374 0048 08E0     		b	.L22
 375              	.LVL19:
 376              	.L23:
 377              	.LBE24:
 378              	.LBB25:
  72:../Libraries/AQ_Receiver/Receiver.h ****   }
  73:../Libraries/AQ_Receiver/Receiver.h **** 	
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  75:../Libraries/AQ_Receiver/Receiver.h ****     receiverSlope[channel] = 1;
 379              		.loc 6 75 0 discriminator 2
 380 004a 174A     		ldr	r2, .L28+16
 381 004c 02EB8301 		add	r1, r2, r3, lsl #2
 382 0050 4FF07E5C 		mov	ip, #1065353216
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 383              		.loc 6 74 0 discriminator 2
 384 0054 5A1C     		adds	r2, r3, #1
 385              		.loc 6 75 0 discriminator 2
 386 0056 C1F800C0 		str	ip, [r1, #0]	@ float
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 387              		.loc 6 74 0 discriminator 2
 388 005a D3B2     		uxtb	r3, r2
 389              	.LVL20:
 390              	.L22:
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 391              		.loc 6 74 0 is_stmt 0 discriminator 1
 392 005c 8342     		cmp	r3, r0
 393 005e F4DB     		blt	.L23
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 394              		.loc 6 74 0
 395 0060 0023     		movs	r3, #0
 396              	.LVL21:
 397 0062 08E0     		b	.L24
 398              	.LVL22:
 399              	.L25:
 400              	.LBE25:
 401              	.LBB26:
  76:../Libraries/AQ_Receiver/Receiver.h ****   }	
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  78:../Libraries/AQ_Receiver/Receiver.h ****     receiverOffset[channel] = 1;
 402              		.loc 6 78 0 is_stmt 1 discriminator 2
 403 0064 114A     		ldr	r2, .L28+20
 404 0066 02EB8301 		add	r1, r2, r3, lsl #2
 405 006a 4FF07E5C 		mov	ip, #1065353216
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 406              		.loc 6 77 0 discriminator 2
 407 006e 0133     		adds	r3, r3, #1
 408              	.LVL23:
 409              		.loc 6 78 0 discriminator 2
 410 0070 C1F800C0 		str	ip, [r1, #0]	@ float
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 411              		.loc 6 77 0 discriminator 2
 412 0074 DBB2     		uxtb	r3, r3
 413              	.LVL24:
 414              	.L24:
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 415              		.loc 6 77 0 is_stmt 0 discriminator 1
 416 0076 8342     		cmp	r3, r0
 417 0078 F4DB     		blt	.L25
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 418              		.loc 6 77 0
 419 007a 0023     		movs	r3, #0
 420              	.LVL25:
 421 007c 08E0     		b	.L26
 422              	.LVL26:
 423              	.L27:
 424              	.LBE26:
 425              	.LBB27:
  79:../Libraries/AQ_Receiver/Receiver.h ****   }
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  81:../Libraries/AQ_Receiver/Receiver.h ****     receiverSmoothFactor[channel] = 1; 
 426              		.loc 6 81 0 is_stmt 1 discriminator 2
 427 007e 0C4A     		ldr	r2, .L28+24
 428 0080 02EB8301 		add	r1, r2, r3, lsl #2
 429 0084 4FF07E5C 		mov	ip, #1065353216
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 430              		.loc 6 80 0 discriminator 2
 431 0088 0133     		adds	r3, r3, #1
 432              	.LVL27:
 433              		.loc 6 81 0 discriminator 2
 434 008a C1F800C0 		str	ip, [r1, #0]	@ float
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 435              		.loc 6 80 0 discriminator 2
 436 008e DBB2     		uxtb	r3, r3
 437              	.LVL28:
 438              	.L26:
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 439              		.loc 6 80 0 is_stmt 0 discriminator 1
 440 0090 8342     		cmp	r3, r0
 441 0092 F4DB     		blt	.L27
 442              	.LBE27:
 443              	.LBE22:
  82:../Libraries/AQ_Receiver/Receiver.h ****   }
  83:../Libraries/AQ_Receiver/Receiver.h **** }
 444              		.loc 6 83 0 is_stmt 1
 445 0094 7047     		bx	lr
 446              	.L29:
 447 0096 00BF     		.align	2
 448              	.L28:
 449 0098 00000000 		.word	.LANCHOR0
 450 009c 00000000 		.word	.LANCHOR1
 451 00a0 00000000 		.word	.LANCHOR2
 452 00a4 00000000 		.word	.LANCHOR3
 453 00a8 00000000 		.word	.LANCHOR4
 454 00ac 00000000 		.word	.LANCHOR5
 455 00b0 00000000 		.word	.LANCHOR6
 456              		.cfi_endproc
 457              	.LFE123:
 459              		.section	.text._Z17getReceiverSIDatah,"ax",%progbits
 460              		.align	1
 461              		.global	_Z17getReceiverSIDatah
 462              		.thumb
 463              		.thumb_func
 465              	_Z17getReceiverSIDatah:
 466              	.LFB125:
  84:../Libraries/AQ_Receiver/Receiver.h ****   
  85:../Libraries/AQ_Receiver/Receiver.h **** int getRawChannelValue(byte channel);  
  86:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver();
  87:../Libraries/AQ_Receiver/Receiver.h ****   
  88:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver()
  89:../Libraries/AQ_Receiver/Receiver.h **** {
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  91:../Libraries/AQ_Receiver/Receiver.h **** 
  92:../Libraries/AQ_Receiver/Receiver.h ****     // Apply receiver calibration adjustment
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
  94:../Libraries/AQ_Receiver/Receiver.h ****     // Smooth the flight control receiver inputs
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
  96:../Libraries/AQ_Receiver/Receiver.h ****   }
  97:../Libraries/AQ_Receiver/Receiver.h ****   
  98:../Libraries/AQ_Receiver/Receiver.h ****   // Reduce receiver commands using receiverXmitFactor and center around 1500
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 100:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 101:../Libraries/AQ_Receiver/Receiver.h ****   }	
 102:../Libraries/AQ_Receiver/Receiver.h ****   // No xmitFactor reduction applied for throttle, mode and AUX
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 104:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 105:../Libraries/AQ_Receiver/Receiver.h ****   }
 106:../Libraries/AQ_Receiver/Receiver.h **** }
 107:../Libraries/AQ_Receiver/Receiver.h **** 
 108:../Libraries/AQ_Receiver/Receiver.h **** 
 109:../Libraries/AQ_Receiver/Receiver.h **** void setChannelValue(byte channel,int value);
 110:../Libraries/AQ_Receiver/Receiver.h ****   
 111:../Libraries/AQ_Receiver/Receiver.h **** // return the smoothed & scaled number of radians/sec in stick movement - zero centered
 112:../Libraries/AQ_Receiver/Receiver.h **** const float getReceiverSIData(byte channel) {
 467              		.loc 6 112 0
 468              		.cfi_startproc
 469              		@ args = 0, pretend = 0, frame = 0
 470              		@ frame_needed = 0, uses_anonymous_args = 0
 471              		@ link register save eliminated.
 472              	.LVL29:
 113:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 473              		.loc 6 113 0
 474 0000 0849     		ldr	r1, .L31
 475 0002 094B     		ldr	r3, .L31+4
 476 0004 51F82020 		ldr	r2, [r1, r0, lsl #2]
 477 0008 53F82010 		ldr	r1, [r3, r0, lsl #2]
 478 000c 531A     		subs	r3, r2, r1
 479 000e 00EE103A 		fmsr	s0, r3	@ int
 114:../Libraries/AQ_Receiver/Receiver.h **** }
 480              		.loc 6 114 0
 481 0012 DFED067A 		flds	s15, .L31+8
 113:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 482              		.loc 6 113 0
 483 0016 B8EEC07A 		fsitos	s14, s0
 484              		.loc 6 114 0
 485 001a 67EE276A 		fmuls	s13, s14, s15
 486 001e 16EE900A 		fmrs	r0, s13
 487              	.LVL30:
 488 0022 7047     		bx	lr
 489              	.L32:
 490              		.align	2
 491              	.L31:
 492 0024 00000000 		.word	.LANCHOR1
 493 0028 00000000 		.word	.LANCHOR3
 494 002c 0BD7A33B 		.word	1000593163
 495              		.cfi_endproc
 496              	.LFE125:
 498              		.section	.text._Z9updatePIDffP7PIDdata,"ax",%progbits
 499              		.align	1
 500              		.global	_Z9updatePIDffP7PIDdata
 501              		.thumb
 502              		.thumb_func
 504              	_Z9updatePIDffP7PIDdata:
 505              	.LFB126:
 506              		.file 7 "/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h"
   1:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** /*
   2:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   www.AeroQuad.com
   4:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   An Open Source Arduino based multicopter.
   6:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****  
   7:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   (at your option) any later version. 
  11:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  12:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   GNU General Public License for more details. 
  16:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  17:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   You should have received a copy of the GNU General Public License 
  18:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** */
  20:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  21:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** #ifndef _AQ_PID_H_
  22:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** #define _AQ_PID_H_
  23:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  24:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** enum {
  25:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   RATE_XAXIS_PID_IDX = 0,
  26:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   RATE_YAXIS_PID_IDX,
  27:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ZAXIS_PID_IDX,
  28:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ATTITUDE_XAXIS_PID_IDX,
  29:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ATTITUDE_YAXIS_PID_IDX,
  30:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   HEADING_HOLD_PID_IDX,
  31:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ATTITUDE_GYRO_XAXIS_PID_IDX,
  32:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ATTITUDE_GYRO_YAXIS_PID_IDX,
  33:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  34:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     BARO_ALTITUDE_HOLD_PID_IDX,
  35:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     ZDAMPENING_PID_IDX,
  36:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #endif
  37:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #if defined AltitudeHoldRangeFinder
  38:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     SONAR_ALTITUDE_HOLD_PID_IDX,
  39:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #endif
  40:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #if defined UseGPSNavigator
  41:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     GPSPITCH_PID_IDX,
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     GPSROLL_PID_IDX,
  43:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     GPSYAW_PID_IDX,
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #endif    
  45:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  46:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   LAST_PID_IDX  // keep this definition at the end of this enum
  47:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** };
  48:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** //// PID Variables
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** struct PIDdata {
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float P, I, D;
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float lastError;
  53:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   // AKA experiments with PID
  54:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float previousPIDTime;
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float integratedError;
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float windupGuard; // Thinking about having individual wind up guards for each PID
  57:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** } PID[LAST_PID_IDX];
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // This struct above declares the variable PID[] to hold each of the PID values for various functio
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // The following constants are declared in AeroQuad.h
  61:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // ROLL = 0, PITCH = 1, YAW = 2 (used for Arcobatic Mode, gyros only)
  62:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // ROLLLEVEL = 3, PITCHLEVEL = 4, LEVELGYROROLL = 6, LEVELGYROPITCH = 7 (used for Stable Mode, acce
  63:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // HEADING = 5 (used for heading hold)
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // ALTITUDE = 8 (used for altitude hold)
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // ZDAMPENING = 9 (used in altitude hold to dampen vertical accelerations)
  66:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** float windupGuard; // Read in from EEPROM
  67:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** //// Modified from http://www.arduino.cc/playground/Main/BarebonesPIDForEspresso
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 507              		.loc 7 68 0
 508              		.cfi_startproc
 509              		@ args = 0, pretend = 0, frame = 0
 510              		@ frame_needed = 0, uses_anonymous_args = 0
 511              		@ link register save eliminated.
 512              	.LVL31:
 513              	.LBB28:
  69:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   // AKA PID experiments
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 514              		.loc 7 71 0
 515 0000 2A4B     		ldr	r3, .L40
 516              	.LBE28:
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 517              		.loc 7 68 0
 518 0002 07EE101A 		fmsr	s14, r1
 519              	.LBB29:
 520              		.loc 7 71 0
 521 0006 1968     		ldr	r1, [r3, #0]
 522              	.LVL32:
 523 0008 01EE101A 		fmsr	s2, r1	@ int
 524 000c D2ED040A 		flds	s1, [r2, #16]
 525 0010 B8EE410A 		fuitos	s0, s2
  72:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float error = targetPosition - currentPosition;
 526              		.loc 7 74 0
 527 0014 07EE900A 		fmsr	s15, r0
  75:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   if (inFlight) {
 528              		.loc 7 76 0
 529 0018 2548     		ldr	r0, .L40+4
 530              	.LVL33:
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 531              		.loc 7 71 0
 532 001a 30EE606A 		fsubs	s12, s0, s1
 533 001e DFED256A 		flds	s13, .L40+8
 534              		.loc 7 76 0
 535 0022 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 536              		.loc 7 71 0
 537 0024 86EE265A 		fdivs	s10, s12, s13
 538              	.LVL34:
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
 539              		.loc 7 73 0
 540 0028 82ED040A 		fsts	s0, [r2, #16]
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float error = targetPosition - currentPosition;
 541              		.loc 7 74 0
 542 002c 77EEC75A 		fsubs	s11, s15, s14
 543              	.LVL35:
 544              		.loc 7 76 0
 545 0030 33B1     		cbz	r3, .L34
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PIDparameters->integratedError += error * deltaPIDTime;
 546              		.loc 7 77 0
 547 0032 D2ED051A 		flds	s3, [r2, #20]
 548 0036 45EE851A 		fmacs	s3, s11, s10
 549 003a C2ED051A 		fsts	s3, [r2, #20]
 550 003e 01E0     		b	.L35
 551              	.L34:
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   }
  79:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   else {
  80:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PIDparameters->integratedError = 0.0;
 552              		.loc 7 80 0
 553 0040 0020     		movs	r0, #0
 554 0042 5061     		str	r0, [r2, #20]	@ float
 555              	.L35:
  81:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   }
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->integratedError = constrain(PIDparameters->integratedError, -PIDparameters->windup
 556              		.loc 7 82 0
 557 0044 D2ED066A 		flds	s13, [r2, #24]
 558 0048 92ED056A 		flds	s12, [r2, #20]
 559 004c F1EE667A 		fnegs	s15, s13
 560              	.LVL36:
 561 0050 B4EEE76A 		fcmpes	s12, s15
 562 0054 F1EE10FA 		fmstat
 563 0058 08D4     		bmi	.L36
 564              		.loc 7 82 0 is_stmt 0 discriminator 2
 565 005a B4EE666A 		fcmps	s12, s13
 566 005e F1EE10FA 		fmstat
 567 0062 CCBF     		ite	gt
 568 0064 F0EE667A 		fcpysgt	s15, s13
 569 0068 F0EE467A 		fcpysle	s15, s12
 570              	.L36:
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 571              		.loc 7 83 0 is_stmt 1 discriminator 6
 572 006c D2ED034A 		flds	s9, [r2, #12]
 573 0070 92ED024A 		flds	s8, [r2, #8]
 574 0074 77EE643A 		fsubs	s7, s14, s9
 575 0078 DFED0F2A 		flds	s5, .L40+12
 576 007c 63EE843A 		fmuls	s7, s7, s8
 577 0080 65EE222A 		fmuls	s5, s10, s5
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->lastError = currentPosition;
  85:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   return (PIDparameters->P * error) + (PIDparameters->I * PIDparameters->integratedError) + dTerm;
 578              		.loc 7 86 0 discriminator 6
 579 0084 92ED013A 		flds	s6, [r2, #4]
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 580              		.loc 7 83 0 discriminator 6
 581 0088 C3EEA22A 		fdivs	s5, s7, s5
 582              	.LVL37:
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->lastError = currentPosition;
 583              		.loc 7 84 0 discriminator 6
 584 008c 82ED037A 		fsts	s14, [r2, #12]
 585              		.loc 7 86 0 discriminator 6
 586 0090 92ED007A 		flds	s14, [r2, #0]
 587              	.LVL38:
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->integratedError = constrain(PIDparameters->integratedError, -PIDparameters->windup
 588              		.loc 7 82 0 discriminator 6
 589 0094 C2ED057A 		fsts	s15, [r2, #20]
 590              		.loc 7 86 0 discriminator 6
 591 0098 67EE837A 		fmuls	s15, s15, s6
 592 009c 45EE877A 		fmacs	s15, s11, s14
 593              	.LBE29:
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** }
 594              		.loc 7 87 0 discriminator 6
 595 00a0 37EEA22A 		fadds	s4, s15, s5
 596 00a4 12EE100A 		fmrs	r0, s4
 597 00a8 7047     		bx	lr
 598              	.L41:
 599 00aa 00BF     		.align	2
 600              	.L40:
 601 00ac 00000000 		.word	.LANCHOR7
 602 00b0 00000000 		.word	.LANCHOR8
 603 00b4 00247449 		.word	1232348160
 604 00b8 0000C842 		.word	1120403456
 605              		.cfi_endproc
 606              	.LFE126:
 608              		.section	.text._Z17zeroIntegralErrorv,"ax",%progbits
 609              		.align	1
 610              		.global	_Z17zeroIntegralErrorv
 611              		.thumb
 612              		.thumb_func
 614              	_Z17zeroIntegralErrorv:
 615              	.LFB127:
  88:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  89:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** void zeroIntegralError() __attribute__ ((noinline));
  90:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** void zeroIntegralError() {
 616              		.loc 7 90 0
 617              		.cfi_startproc
 618              		@ args = 0, pretend = 0, frame = 0
 619              		@ frame_needed = 0, uses_anonymous_args = 0
 620              		@ link register save eliminated.
 621              	.LVL39:
 622              	.LBB30:
  91:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   for (byte axis = 0; axis <= ATTITUDE_YAXIS_PID_IDX; axis++) {
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
  93:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].previousPIDTime = currentTime;
 623              		.loc 7 93 0
 624 0000 0C49     		ldr	r1, .L43
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 625              		.loc 7 92 0
 626 0002 0D4B     		ldr	r3, .L43+4
 627              		.loc 7 93 0
 628 0004 0868     		ldr	r0, [r1, #0]
 629 0006 07EE100A 		fmsr	s14, r0	@ int
 630 000a F8EE477A 		fuitos	s15, s14
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 631              		.loc 7 92 0
 632 000e 0022     		movs	r2, #0
 633 0010 5A61     		str	r2, [r3, #20]	@ float
 634              		.loc 7 93 0
 635 0012 C3ED047A 		fsts	s15, [r3, #16]
 636              	.LVL40:
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 637              		.loc 7 92 0
 638 0016 1A63     		str	r2, [r3, #48]	@ float
 639              		.loc 7 93 0
 640 0018 C3ED0B7A 		fsts	s15, [r3, #44]
 641              	.LVL41:
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 642              		.loc 7 92 0
 643 001c DA64     		str	r2, [r3, #76]	@ float
 644              		.loc 7 93 0
 645 001e C3ED127A 		fsts	s15, [r3, #72]
 646              	.LVL42:
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 647              		.loc 7 92 0
 648 0022 9A66     		str	r2, [r3, #104]	@ float
 649              		.loc 7 93 0
 650 0024 C3ED197A 		fsts	s15, [r3, #100]
 651              	.LVL43:
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 652              		.loc 7 92 0
 653 0028 C3F88420 		str	r2, [r3, #132]	@ float
 654              		.loc 7 93 0
 655 002c C3ED207A 		fsts	s15, [r3, #128]
 656              	.LVL44:
 657              	.LBE30:
  94:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   }
  95:/home/james/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** }
 658              		.loc 7 95 0
 659 0030 7047     		bx	lr
 660              	.L44:
 661 0032 00BF     		.align	2
 662              	.L43:
 663 0034 00000000 		.word	.LANCHOR7
 664 0038 00000000 		.word	.LANCHOR9
 665              		.cfi_endproc
 666              	.LFE127:
 668              		.section	.text._Z18computeFourthOrderfP15fourthOrderData,"ax",%progbits
 669              		.align	1
 670              		.global	_Z18computeFourthOrderfP15fourthOrderData
 671              		.thumb
 672              		.thumb_func
 674              	_Z18computeFourthOrderfP15fourthOrderData:
 675              	.LFB128:
 676              		.file 8 "../Libraries/AQ_Math/FourtOrderFilter.h"
   1:../Libraries/AQ_Math/FourtOrderFilter.h **** /*
   2:../Libraries/AQ_Math/FourtOrderFilter.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Math/FourtOrderFilter.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Math/FourtOrderFilter.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Math/FourtOrderFilter.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Math/FourtOrderFilter.h ****  
   7:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Math/FourtOrderFilter.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Math/FourtOrderFilter.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Math/FourtOrderFilter.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  12:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Math/FourtOrderFilter.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Math/FourtOrderFilter.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Math/FourtOrderFilter.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  17:../Libraries/AQ_Math/FourtOrderFilter.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Math/FourtOrderFilter.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Math/FourtOrderFilter.h **** */
  20:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  21:../Libraries/AQ_Math/FourtOrderFilter.h **** #ifndef _AQ_FOURTH_ORDER_FILTER_H_
  22:../Libraries/AQ_Math/FourtOrderFilter.h **** #define _AQ_FOURTH_ORDER_FILTER_H_
  23:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  24:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  25:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  26:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  27:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  28:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  29:../Libraries/AQ_Math/FourtOrderFilter.h **** #include <GlobalDefined.h>
  30:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  31:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  32:../Libraries/AQ_Math/FourtOrderFilter.h **** struct fourthOrderData
  33:../Libraries/AQ_Math/FourtOrderFilter.h **** {
  34:../Libraries/AQ_Math/FourtOrderFilter.h ****   float  inputTm1,  inputTm2,  inputTm3,  inputTm4;
  35:../Libraries/AQ_Math/FourtOrderFilter.h ****   float outputTm1, outputTm2, outputTm3, outputTm4;
  36:../Libraries/AQ_Math/FourtOrderFilter.h **** } fourthOrder[4];
  37:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  38:../Libraries/AQ_Math/FourtOrderFilter.h **** float computeFourthOrder(float currentInput, struct fourthOrderData *filterParameters)
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 677              		.loc 8 39 0
 678              		.cfi_startproc
 679              		@ args = 0, pretend = 0, frame = 0
 680              		@ frame_needed = 0, uses_anonymous_args = 0
 681              		@ link register save eliminated.
 682              	.LVL45:
 683              	.LBB31:
  40:../Libraries/AQ_Math/FourtOrderFilter.h ****   // cheby2(4,60,12.5/50)
  41:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b0  0.001893594048567
  42:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b1 -0.002220262954039
  43:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b2  0.003389066536478
  44:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b3 -0.002220262954039
  45:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b4  0.001893594048567
  46:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  47:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a1 -3.362256889209355
  48:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a2  4.282608240117919
  49:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a3 -2.444765517272841
  50:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a4  0.527149895089809
  51:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  52:../Libraries/AQ_Math/FourtOrderFilter.h ****   float output;
  53:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  54:../Libraries/AQ_Math/FourtOrderFilter.h ****   output = _b0 * currentInput                + 
  55:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b1 * filterParameters->inputTm1  + 
  56:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b2 * filterParameters->inputTm2  +
  57:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b3 * filterParameters->inputTm3  +
  58:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b4 * filterParameters->inputTm4  -
  59:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a1 * filterParameters->outputTm1 -
  60:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a2 * filterParameters->outputTm2 -
  61:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a3 * filterParameters->outputTm3 -
  62:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a4 * filterParameters->outputTm4;
 684              		.loc 8 62 0
 685 0000 91ED005A 		flds	s10, [r1, #0]
 686 0004 9FED203A 		flds	s6, .L46
 687              	.LBE31:
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 688              		.loc 8 39 0
 689 0008 05EE900A 		fmsr	s11, r0
 690              	.LBB32:
 691              		.loc 8 62 0
 692 000c 9FED1F2A 		flds	s4, .L46+4
 693 0010 65EE037A 		fmuls	s15, s10, s6
 694 0014 45EE827A 		fmacs	s15, s11, s4
 695 0018 D1ED014A 		flds	s9, [r1, #4]
 696 001c DFED1C2A 		flds	s5, .L46+8
 697 0020 44EEA27A 		fmacs	s15, s9, s5
 698 0024 91ED024A 		flds	s8, [r1, #8]
 699 0028 44EE037A 		fmacs	s15, s8, s6
 700 002c D1ED031A 		flds	s3, [r1, #12]
 701 0030 41EE827A 		fmacs	s15, s3, s4
 702 0034 91ED047A 		flds	s14, [r1, #16]
 703 0038 9FED161A 		flds	s2, .L46+12
 704 003c 47EE017A 		fmacs	s15, s14, s2
 705 0040 D1ED056A 		flds	s13, [r1, #20]
 706 0044 DFED140A 		flds	s1, .L46+16
 707 0048 46EEE07A 		fnmacs	s15, s13, s1
 708 004c 91ED066A 		flds	s12, [r1, #24]
 709 0050 9FED120A 		flds	s0, .L46+20
 710 0054 46EE007A 		fmacs	s15, s12, s0
 711 0058 91ED073A 		flds	s6, [r1, #28]
 712 005c DFED103A 		flds	s7, .L46+24
 713 0060 43EE637A 		fnmacs	s15, s6, s7
 714              	.LVL46:
  63:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
  67:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm1 = currentInput;
 715              		.loc 8 67 0
 716 0064 0860     		str	r0, [r1, #0]	@ float
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
 717              		.loc 8 64 0
 718 0066 81ED034A 		fsts	s8, [r1, #12]
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
 719              		.loc 8 65 0
 720 006a C1ED024A 		fsts	s9, [r1, #8]
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
 721              		.loc 8 66 0
 722 006e 81ED015A 		fsts	s10, [r1, #4]
  68:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  69:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm4 = filterParameters->outputTm3;
 723              		.loc 8 69 0
 724 0072 81ED076A 		fsts	s12, [r1, #28]
  70:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm3 = filterParameters->outputTm2;
 725              		.loc 8 70 0
 726 0076 C1ED066A 		fsts	s13, [r1, #24]
  71:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm2 = filterParameters->outputTm1;
 727              		.loc 8 71 0
 728 007a 81ED057A 		fsts	s14, [r1, #20]
  72:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm1 = output;
 729              		.loc 8 72 0
 730 007e C1ED047A 		fsts	s15, [r1, #16]
 731              	.LBE32:
  73:../Libraries/AQ_Math/FourtOrderFilter.h ****     
  74:../Libraries/AQ_Math/FourtOrderFilter.h ****   return output;
  75:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 732              		.loc 8 75 0
 733 0082 17EE900A 		fmrs	r0, s15
 734              	.LVL47:
 735 0086 7047     		bx	lr
 736              	.L47:
 737              		.align	2
 738              	.L46:
 739 0088 D58111BB 		.word	-1156480555
 740 008c 7932F83A 		.word	989344377
 741 0090 1A1B5E3B 		.word	996023066
 742 0094 382F5740 		.word	1079455544
 743 0098 200B8940 		.word	1082723104
 744 009c 0A771C40 		.word	1075607306
 745 00a0 4CF3063F 		.word	1057420108
 746              		.cfi_endproc
 747              	.LFE128:
 749              		.section	.text._Z16setupFourthOrderv,"ax",%progbits
 750              		.align	1
 751              		.global	_Z16setupFourthOrderv
 752              		.thumb
 753              		.thumb_func
 755              	_Z16setupFourthOrderv:
 756              	.LFB129:
  76:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  77:../Libraries/AQ_Math/FourtOrderFilter.h **** void setupFourthOrder(void)
  78:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 757              		.loc 8 78 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 0
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              		@ link register save eliminated.
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 762              		.loc 8 79 0
 763 0000 0D4B     		ldr	r3, .L49
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
  83:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
  88:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  89:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
  94:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
  99:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 100:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
 101:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm1 = -9.8065;
 764              		.loc 8 101 0
 765 0002 0E4A     		ldr	r2, .L49+4
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 766              		.loc 8 79 0
 767 0004 0020     		movs	r0, #0
 768 0006 1860     		str	r0, [r3, #0]	@ float
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
 769              		.loc 8 80 0
 770 0008 5860     		str	r0, [r3, #4]	@ float
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
 771              		.loc 8 81 0
 772 000a 9860     		str	r0, [r3, #8]	@ float
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
 773              		.loc 8 82 0
 774 000c D860     		str	r0, [r3, #12]	@ float
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
 775              		.loc 8 84 0
 776 000e 1861     		str	r0, [r3, #16]	@ float
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
 777              		.loc 8 85 0
 778 0010 5861     		str	r0, [r3, #20]	@ float
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
 779              		.loc 8 86 0
 780 0012 9861     		str	r0, [r3, #24]	@ float
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
 781              		.loc 8 87 0
 782 0014 D861     		str	r0, [r3, #28]	@ float
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
 783              		.loc 8 90 0
 784 0016 1862     		str	r0, [r3, #32]	@ float
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
 785              		.loc 8 91 0
 786 0018 5862     		str	r0, [r3, #36]	@ float
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
 787              		.loc 8 92 0
 788 001a 9862     		str	r0, [r3, #40]	@ float
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
 789              		.loc 8 93 0
 790 001c D862     		str	r0, [r3, #44]	@ float
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
 791              		.loc 8 95 0
 792 001e 1863     		str	r0, [r3, #48]	@ float
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
 793              		.loc 8 96 0
 794 0020 5863     		str	r0, [r3, #52]	@ float
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
 795              		.loc 8 97 0
 796 0022 9863     		str	r0, [r3, #56]	@ float
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
 797              		.loc 8 98 0
 798 0024 D863     		str	r0, [r3, #60]	@ float
 799              		.loc 8 101 0
 800 0026 1A64     		str	r2, [r3, #64]	@ float
 102:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm2 = -9.8065;
 801              		.loc 8 102 0
 802 0028 5A64     		str	r2, [r3, #68]	@ float
 103:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm3 = -9.8065;
 803              		.loc 8 103 0
 804 002a 9A64     		str	r2, [r3, #72]	@ float
 104:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm4 = -9.8065;
 805              		.loc 8 104 0
 806 002c DA64     		str	r2, [r3, #76]	@ float
 105:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 106:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm1 = -9.8065;
 807              		.loc 8 106 0
 808 002e 1A65     		str	r2, [r3, #80]	@ float
 107:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm2 = -9.8065;
 809              		.loc 8 107 0
 810 0030 5A65     		str	r2, [r3, #84]	@ float
 108:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm3 = -9.8065;
 811              		.loc 8 108 0
 812 0032 9A65     		str	r2, [r3, #88]	@ float
 109:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm4 = -9.8065;
 813              		.loc 8 109 0
 814 0034 DA65     		str	r2, [r3, #92]	@ float
 110:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 815              		.loc 8 110 0
 816 0036 7047     		bx	lr
 817              	.L50:
 818              		.align	2
 819              	.L49:
 820 0038 00000000 		.word	.LANCHOR10
 821 003c 6DE71CC1 		.word	-1055070355
 822              		.cfi_endproc
 823              	.LFE129:
 825              		.section	.text._ZN14HardwareSPIExt5SetCSEi,"axG",%progbits,_ZN14HardwareSPIExt5SetCSEi,comdat
 826              		.align	1
 827              		.weak	_ZN14HardwareSPIExt5SetCSEi
 828              		.thumb
 829              		.thumb_func
 831              	_ZN14HardwareSPIExt5SetCSEi:
 832              	.LFB133:
 833              		.file 9 "../Libraries/AQ_SPI/HardwareSPIExt.h"
   1:../Libraries/AQ_SPI/HardwareSPIExt.h **** #ifndef _AEROQUAD_SPI_HARDWARESPIEXT_H_
   2:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define _AEROQUAD_SPI_HARDWARESPIEXT_H_
   3:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   4:../Libraries/AQ_SPI/HardwareSPIExt.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   6:../Libraries/AQ_SPI/HardwareSPIExt.h **** // helper class to extend the maple HardwareSPI class
   7:../Libraries/AQ_SPI/HardwareSPIExt.h **** // used by the MPU6000 library
   8:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   9:../Libraries/AQ_SPI/HardwareSPIExt.h **** #include <HardwareSPI.h>
  10:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  11:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_READ_FLAG  0x80
  12:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_MULTI_FLAG 0x40
  13:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SetPin digitalWrite
  14:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  15:../Libraries/AQ_SPI/HardwareSPIExt.h **** class HardwareSPIExt : public HardwareSPI {
  16:../Libraries/AQ_SPI/HardwareSPIExt.h **** public:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  21:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  22:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetCS(int aCS)
 834              		.loc 9 22 0
 835              		.cfi_startproc
 836              		@ args = 0, pretend = 0, frame = 0
 837              		@ frame_needed = 0, uses_anonymous_args = 0
 838              		@ link register save eliminated.
 839              	.LVL48:
  23:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  24:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fCS = aCS;
 840              		.loc 9 24 0
 841 0000 4160     		str	r1, [r0, #4]
  25:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 842              		.loc 9 25 0
 843 0002 7047     		bx	lr
 844              		.cfi_endproc
 845              	.LFE133:
 847              		.section	.text._ZN14HardwareSPIExtC2Ej,"axG",%progbits,_ZN14HardwareSPIExtC5Ej,comdat
 848              		.align	1
 849              		.weak	_ZN14HardwareSPIExtC2Ej
 850              		.thumb
 851              		.thumb_func
 853              	_ZN14HardwareSPIExtC2Ej:
 854              	.LFB131:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 855              		.loc 9 17 0
 856              		.cfi_startproc
 857              		@ args = 0, pretend = 0, frame = 0
 858              		@ frame_needed = 0, uses_anonymous_args = 0
 859              	.LVL49:
 860 0000 10B5     		push	{r4, lr}
 861              	.LCFI1:
 862              		.cfi_def_cfa_offset 8
 863              		.cfi_offset 14, -4
 864              		.cfi_offset 4, -8
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 865              		.loc 9 17 0
 866 0002 0446     		mov	r4, r0
 867              	.LBB33:
 868 0004 FFF7FEFF 		bl	_ZN11HardwareSPIC2Ej
 869              	.LVL50:
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
 870              		.loc 9 18 0
 871 0008 2046     		mov	r0, r4
 872 000a FFF7FEFF 		bl	_ZN11HardwareSPI6nssPinEv
 873 000e 0146     		mov	r1, r0
 874 0010 2046     		mov	r0, r4
 875 0012 FFF7FEFF 		bl	_ZN14HardwareSPIExt5SetCSEi
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
 876              		.loc 9 19 0
 877 0016 0023     		movs	r3, #0
 878 0018 2372     		strb	r3, [r4, #8]
 879              	.LBE33:
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 880              		.loc 9 20 0
 881 001a 2046     		mov	r0, r4
 882 001c 10BD     		pop	{r4, pc}
 883              		.cfi_endproc
 884              	.LFE131:
 886              		.section	.text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj,"axG",%progbits,_ZN14HardwareSPIExt5begi
 887              		.align	1
 888              		.weak	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 889              		.thumb
 890              		.thumb_func
 892              	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj:
 893              	.LFB135:
  26:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  27:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetMultiFlag() {
  28:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = SPI_MULTI_FLAG;
  29:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  30:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
 894              		.loc 9 31 0
 895              		.cfi_startproc
 896              		@ args = 0, pretend = 0, frame = 0
 897              		@ frame_needed = 0, uses_anonymous_args = 0
 898              	.LVL51:
 899 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 900              	.LCFI2:
 901              		.cfi_def_cfa_offset 24
 902              		.cfi_offset 14, -4
 903              		.cfi_offset 8, -8
 904              		.cfi_offset 7, -12
 905              		.cfi_offset 6, -16
 906              		.cfi_offset 5, -20
 907              		.cfi_offset 4, -24
 908              		.loc 9 31 0
 909 0004 0446     		mov	r4, r0
 910 0006 0D46     		mov	r5, r1
  32:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  33:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 911              		.loc 9 33 0
 912 0008 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 913              	.LVL52:
 914 000a 0121     		movs	r1, #1
 915              	.LVL53:
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
 916              		.loc 9 31 0
 917 000c 1746     		mov	r7, r2
 918 000e 1E46     		mov	r6, r3
 919              		.loc 9 33 0
 920 0010 FFF7FEFF 		bl	_Z12digitalWritehh
 921              	.LVL54:
  34:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		pinMode(fCS, OUTPUT);
 922              		.loc 9 34 0
 923 0014 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 924 0016 0021     		movs	r1, #0
 925 0018 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
  35:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 926              		.loc 9 36 0
 927 001c 2046     		mov	r0, r4
 928 001e 2946     		mov	r1, r5
 929 0020 3A46     		mov	r2, r7
 930 0022 3346     		mov	r3, r6
  37:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 931              		.loc 9 37 0
 932 0024 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 933              		.loc 9 36 0
 934 0028 FFF7FEBF 		b	_ZN11HardwareSPI5beginE12SPIFrequencyjj
 935              		.cfi_endproc
 936              	.LFE135:
 938              		.section	.text._ZN14HardwareSPIExt4ReadEiPhi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEiPhi,comdat
 939              		.align	1
 940              		.weak	_ZN14HardwareSPIExt4ReadEiPhi
 941              		.thumb
 942              		.thumb_func
 944              	_ZN14HardwareSPIExt4ReadEiPhi:
 945              	.LFB136:
  38:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 946              		.loc 9 39 0
 947              		.cfi_startproc
 948              		@ args = 0, pretend = 0, frame = 0
 949              		@ frame_needed = 0, uses_anonymous_args = 0
 950              	.LVL55:
 951 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 952              	.LCFI3:
 953              		.cfi_def_cfa_offset 24
 954              		.cfi_offset 14, -4
 955              		.cfi_offset 7, -8
 956              		.cfi_offset 6, -12
 957              		.cfi_offset 5, -16
 958              		.cfi_offset 4, -20
 959              		.cfi_offset 3, -24
 960              		.loc 9 39 0
 961 0002 0446     		mov	r4, r0
 962 0004 0D46     		mov	r5, r1
  40:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  41:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 963              		.loc 9 41 0
 964 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 965              	.LVL56:
 966 0008 0021     		movs	r1, #0
 967              	.LVL57:
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 968              		.loc 9 39 0
 969 000a 1F46     		mov	r7, r3
 970 000c 1646     		mov	r6, r2
 971              		.loc 9 41 0
 972 000e FFF7FEFF 		bl	_Z12digitalWritehh
 973              	.LVL58:
  42:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | SPI_READ_FLAG | fSpiMultiFlag);
 974              		.loc 9 42 0
 975 0012 207A     		ldrb	r0, [r4, #8]	@ zero_extendqisi2
 976 0014 60F07F03 		orn	r3, r0, #127
 977 0018 1D43     		orrs	r5, r5, r3
 978              	.LVL59:
 979 001a E9B2     		uxtb	r1, r5
 980 001c 2046     		mov	r0, r4
 981 001e FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 982 0022 3D46     		mov	r5, r7
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 983              		.loc 9 43 0
 984 0024 06E0     		b	.L56
 985              	.LVL60:
 986              	.L57:
  44:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			*data++ = transfer(0);
 987              		.loc 9 44 0
 988 0026 2046     		mov	r0, r4
 989 0028 0021     		movs	r1, #0
 990 002a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 991 002e 06F8010B 		strb	r0, [r6], #1
 992              	.LVL61:
 993 0032 013D     		subs	r5, r5, #1
 994              	.L56:
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 995              		.loc 9 43 0 discriminator 1
 996 0034 002D     		cmp	r5, #0
 997 0036 F6DC     		bgt	.L57
  45:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 998              		.loc 9 46 0
 999 0038 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1000 003a 0121     		movs	r1, #1
  47:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1001              		.loc 9 47 0
 1002 003c BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1003              		.loc 9 46 0
 1004 0040 FFF7FEBF 		b	_Z12digitalWritehh
 1005              		.cfi_endproc
 1006              	.LFE136:
 1008              		.section	.text._ZN14HardwareSPIExt4ReadEi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEi,comdat
 1009              		.align	1
 1010              		.weak	_ZN14HardwareSPIExt4ReadEi
 1011              		.thumb
 1012              		.thumb_func
 1014              	_ZN14HardwareSPIExt4ReadEi:
 1015              	.LFB137:
  48:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  49:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	unsigned char Read(int addr)
 1016              		.loc 9 49 0
 1017              		.cfi_startproc
 1018              		@ args = 0, pretend = 0, frame = 8
 1019              		@ frame_needed = 0, uses_anonymous_args = 0
 1020              	.LVL62:
 1021 0000 07B5     		push	{r0, r1, r2, lr}
 1022              	.LCFI4:
 1023              		.cfi_def_cfa_offset 16
 1024              		.cfi_offset 14, -4
 1025              		.cfi_offset 2, -8
 1026              		.cfi_offset 1, -12
 1027              		.cfi_offset 0, -16
 1028              	.LBB34:
  50:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  51:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		unsigned char data;
  52:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Read(addr, &data, 1);
 1029              		.loc 9 52 0
 1030 0002 0123     		movs	r3, #1
 1031 0004 0DF10702 		add	r2, sp, #7
 1032 0008 FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 1033              	.LVL63:
 1034              	.LBE34:
  53:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  54:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		return data;
  55:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1035              		.loc 9 55 0
 1036 000c 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 1037 0010 0EBD     		pop	{r1, r2, r3, pc}
 1038              		.cfi_endproc
 1039              	.LFE137:
 1041              		.section	.text._ZN14HardwareSPIExt5WriteEiPhi,"axG",%progbits,_ZN14HardwareSPIExt5WriteEiPhi,comda
 1042              		.align	1
 1043              		.weak	_ZN14HardwareSPIExt5WriteEiPhi
 1044              		.thumb
 1045              		.thumb_func
 1047              	_ZN14HardwareSPIExt5WriteEiPhi:
 1048              	.LFB138:
  56:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
 1049              		.loc 9 57 0
 1050              		.cfi_startproc
 1051              		@ args = 0, pretend = 0, frame = 0
 1052              		@ frame_needed = 0, uses_anonymous_args = 0
 1053              	.LVL64:
 1054 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1055              	.LCFI5:
 1056              		.cfi_def_cfa_offset 24
 1057              		.cfi_offset 14, -4
 1058              		.cfi_offset 7, -8
 1059              		.cfi_offset 6, -12
 1060              		.cfi_offset 5, -16
 1061              		.cfi_offset 4, -20
 1062              		.cfi_offset 3, -24
 1063              		.loc 9 57 0
 1064 0002 0446     		mov	r4, r0
 1065 0004 0D46     		mov	r5, r1
  58:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  59:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 1066              		.loc 9 59 0
 1067 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 1068              	.LVL65:
 1069 0008 0021     		movs	r1, #0
 1070              	.LVL66:
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
 1071              		.loc 9 57 0
 1072 000a 1F46     		mov	r7, r3
 1073 000c 1646     		mov	r6, r2
 1074              		.loc 9 59 0
 1075 000e FFF7FEFF 		bl	_Z12digitalWritehh
 1076              	.LVL67:
  60:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | fSpiMultiFlag);
 1077              		.loc 9 60 0
 1078 0012 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 1079 0014 1D43     		orrs	r5, r5, r3
 1080              	.LVL68:
 1081 0016 E9B2     		uxtb	r1, r5
 1082 0018 2046     		mov	r0, r4
 1083 001a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1084 001e 3D46     		mov	r5, r7
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1085              		.loc 9 61 0
 1086 0020 05E0     		b	.L60
 1087              	.LVL69:
 1088              	.L61:
  62:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			transfer(*data++);
 1089              		.loc 9 62 0
 1090 0022 2046     		mov	r0, r4
 1091 0024 16F8011B 		ldrb	r1, [r6], #1	@ zero_extendqisi2
 1092              	.LVL70:
 1093 0028 FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1094 002c 013D     		subs	r5, r5, #1
 1095              	.LVL71:
 1096              	.L60:
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1097              		.loc 9 61 0 discriminator 1
 1098 002e 002D     		cmp	r5, #0
 1099 0030 F7DC     		bgt	.L61
  63:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1100              		.loc 9 64 0
 1101 0032 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1102 0034 0121     		movs	r1, #1
  65:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1103              		.loc 9 65 0
 1104 0036 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1105              		.loc 9 64 0
 1106 003a FFF7FEBF 		b	_Z12digitalWritehh
 1107              		.cfi_endproc
 1108              	.LFE138:
 1110              		.section	.text._ZN14HardwareSPIExt5WriteEih,"axG",%progbits,_ZN14HardwareSPIExt5WriteEih,comdat
 1111              		.align	1
 1112              		.weak	_ZN14HardwareSPIExt5WriteEih
 1113              		.thumb
 1114              		.thumb_func
 1116              	_ZN14HardwareSPIExt5WriteEih:
 1117              	.LFB139:
  66:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  67:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char data)
 1118              		.loc 9 67 0
 1119              		.cfi_startproc
 1120              		@ args = 0, pretend = 0, frame = 8
 1121              		@ frame_needed = 0, uses_anonymous_args = 0
 1122              	.LVL72:
 1123 0000 07B5     		push	{r0, r1, r2, lr}
 1124              	.LCFI6:
 1125              		.cfi_def_cfa_offset 16
 1126              		.cfi_offset 14, -4
 1127              		.cfi_offset 2, -8
 1128              		.cfi_offset 1, -12
 1129              		.cfi_offset 0, -16
 1130              	.LVL73:
 1131              		.loc 9 67 0
 1132 0002 02AB     		add	r3, sp, #8
 1133              	.LVL74:
 1134 0004 03F8012D 		strb	r2, [r3, #-1]!
  68:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  69:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Write(addr, &data, 1);
 1135              		.loc 9 69 0
 1136 0008 1A46     		mov	r2, r3
 1137              	.LVL75:
 1138 000a 0123     		movs	r3, #1
 1139 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt5WriteEiPhi
 1140              	.LVL76:
  70:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1141              		.loc 9 70 0
 1142 0010 0EBD     		pop	{r1, r2, r3, pc}
 1143              		.cfi_endproc
 1144              	.LFE139:
 1146              		.section	.text._Z19MPU6000_SpiLowSpeedv,"ax",%progbits
 1147              		.align	1
 1148              		.global	_Z19MPU6000_SpiLowSpeedv
 1149              		.thumb
 1150              		.thumb_func
 1152              	_Z19MPU6000_SpiLowSpeedv:
 1153              	.LFB140:
 1154              		.file 10 "../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h"
   1:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** /*
   2:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
   7:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  12:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  17:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** */
  20:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  21:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // parts of the init sequence were taken from AP_InertialSensor_MPU6000.h
  22:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  23:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef _AEROQUAD_PLATFORM_MPU6000_H_
  24:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define _AEROQUAD_PLATFORM_MPU6000_H_
  25:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  26:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // I2C support for MPU6000/6050 is not tested yet
  27:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C
  28:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  29:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include "Arduino.h"
  30:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include <SensorsStatus.h>
  31:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  32:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C	// insert this define before #include <Platform_MPU6000.h> when you use a I2C
  33:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  34:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // MPU 6000 registers
  35:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_WHOAMI			0x75
  36:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_SMPLRT_DIV		0x19
  37:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_CONFIG			0x1A
  38:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_CONFIG		0x1B
  39:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_CONFIG		0x1C
  40:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_EN			0x23
  41:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_PIN_CFG		0x37
  42:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_ENABLE		0x38
  43:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_STATUS		0x3A
  44:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_H		0x3B
  45:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_L		0x3C
  46:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_H		0x3D
  47:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_L		0x3E
  48:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_H		0x3F
  49:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_L		0x40
  50:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_H		0x41
  51:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_L		0x42
  52:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_H		0x43
  53:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_L		0x44
  54:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_H		0x45
  55:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_L		0x46
  56:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_H		0x47
  57:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_L		0x48
  58:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_USER_CTRL		0x6A
  59:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_1		0x6B
  60:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_2		0x6C
  61:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTH		0x72
  62:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTL		0x73
  63:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_R_W			0x74
  64:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  65:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  66:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // Configuration bits
  67:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_SLEEP				0x40
  68:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_H_RESET				0x80
  69:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_CLKSEL				0x07
  70:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROX	0x01
  71:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROZ	0x03
  72:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_EXT_SYNC_GYROX		0x02
  73:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_250DPS          0x00
  74:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_500DPS          0x08
  75:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_1000DPS         0x10
  76:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_2000DPS         0x18
  77:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_MASK            0x18
  78:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_256HZ_NOLPF2  0x00
  79:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_188HZ         0x01
  80:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_98HZ          0x02
  81:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_42HZ          0x03
  82:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_20HZ          0x04
  83:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_10HZ          0x05
  84:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_5HZ           0x06
  85:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_2100HZ_NOLPF  0x07
  86:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_MASK          0x07
  87:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_ANYRD_2CLEAR    0x10
  88:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_RAW_RDY_EN			0x01
  89:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_I2C_IF_DIS          0x10
  90:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_STATUS_DATA		0x01
  91:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  92:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  93:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** typedef struct {
  94:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short x;
  95:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short y;
  96:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short z;
  97:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } tAxis;
  98:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  99:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** union uMPU6000 {
 100:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned char rawByte[];
 101:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned short rawWord[];
 102:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   struct {
 103:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	tAxis accel;
 104:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short temperature;
 105:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	tAxis gyro;
 106:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   } data;
 107:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } MPU6000;
 108:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 109:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 110:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 111:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C_ADDRESS
 112:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#define MPU6000_I2C_ADDRESS 0x68
 113:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 114:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 115:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #include <HardwareSPIExt.h>
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   HardwareSPIExt spiMPU6000(4);
 117:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 118:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 119:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiLowSpeed()
 120:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1155              		.loc 10 120 0
 1156              		.cfi_startproc
 1157              		@ args = 0, pretend = 0, frame = 0
 1158              		@ frame_needed = 0, uses_anonymous_args = 0
 1159              		@ link register save eliminated.
 121:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 122:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.begin(SPI_562_500KHZ, MSBFIRST, 3);
 1160              		.loc 10 122 0
 1161 0000 0248     		ldr	r0, .L64
 1162 0002 0521     		movs	r1, #5
 1163 0004 0122     		movs	r2, #1
 1164 0006 0323     		movs	r3, #3
 123:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 124:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1165              		.loc 10 124 0
 122:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.begin(SPI_562_500KHZ, MSBFIRST, 3);
 1166              		.loc 10 122 0
 1167 0008 FFF7FEBF 		b	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 1168              	.L65:
 1169              		.align	2
 1170              	.L64:
 1171 000c 00000000 		.word	.LANCHOR11
 1172              		.cfi_endproc
 1173              	.LFE140:
 1175              		.section	.text._Z20MPU6000_SpiHighSpeedv,"ax",%progbits
 1176              		.align	1
 1177              		.global	_Z20MPU6000_SpiHighSpeedv
 1178              		.thumb
 1179              		.thumb_func
 1181              	_Z20MPU6000_SpiHighSpeedv:
 1182              	.LFB141:
 125:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 126:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiHighSpeed()
 127:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1183              		.loc 10 127 0
 1184              		.cfi_startproc
 1185              		@ args = 0, pretend = 0, frame = 0
 1186              		@ frame_needed = 0, uses_anonymous_args = 0
 1187 0000 10B5     		push	{r4, lr}
 1188              	.LCFI7:
 1189              		.cfi_def_cfa_offset 8
 1190              		.cfi_offset 14, -4
 1191              		.cfi_offset 4, -8
 128:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 129:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.end();
 1192              		.loc 10 129 0
 1193 0002 064C     		ldr	r4, .L67
 1194 0004 2046     		mov	r0, r4
 1195 0006 FFF7FEFF 		bl	_ZN11HardwareSPI3endEv
 130:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.begin(SPI_9MHZ, MSBFIRST, 3);
 1196              		.loc 10 130 0
 1197 000a 0121     		movs	r1, #1
 1198 000c 2046     		mov	r0, r4
 1199 000e 0A46     		mov	r2, r1
 1200 0010 0323     		movs	r3, #3
 131:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 132:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1201              		.loc 10 132 0
 1202 0012 BDE81040 		pop	{r4, lr}
 130:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.begin(SPI_9MHZ, MSBFIRST, 3);
 1203              		.loc 10 130 0
 1204 0016 FFF7FEBF 		b	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 1205              	.L68:
 1206 001a 00BF     		.align	2
 1207              	.L67:
 1208 001c 00000000 		.word	.LANCHOR11
 1209              		.cfi_endproc
 1210              	.LFE141:
 1212              		.section	.text._Z16MPU6000_WriteRegih,"ax",%progbits
 1213              		.align	1
 1214              		.global	_Z16MPU6000_WriteRegih
 1215              		.thumb
 1216              		.thumb_func
 1218              	_Z16MPU6000_WriteRegih:
 1219              	.LFB142:
 133:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 134:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_WriteReg(int addr, byte data)
 135:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1220              		.loc 10 135 0
 1221              		.cfi_startproc
 1222              		@ args = 0, pretend = 0, frame = 0
 1223              		@ frame_needed = 0, uses_anonymous_args = 0
 1224              	.LVL77:
 1225 0000 08B5     		push	{r3, lr}
 1226              	.LCFI8:
 1227              		.cfi_def_cfa_offset 8
 1228              		.cfi_offset 14, -4
 1229              		.cfi_offset 3, -8
 1230              		.loc 10 135 0
 1231 0002 0346     		mov	r3, r0
 1232 0004 0A46     		mov	r2, r1
 136:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 137:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	updateRegisterI2C(MPU6000_I2C_ADDRESS, addr, data);
 138:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 139:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.Write(addr, data);
 1233              		.loc 10 139 0
 1234 0006 0448     		ldr	r0, .L70
 1235              	.LVL78:
 1236 0008 1946     		mov	r1, r3
 1237              	.LVL79:
 1238 000a FFF7FEFF 		bl	_ZN14HardwareSPIExt5WriteEih
 1239              	.LVL80:
 140:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1240              		.loc 10 141 0
 1241 000e 0120     		movs	r0, #1
 142:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1242              		.loc 10 142 0
 1243 0010 BDE80840 		pop	{r3, lr}
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1244              		.loc 10 141 0
 1245 0014 FFF7FEBF 		b	_Z5delaym
 1246              	.L71:
 1247              		.align	2
 1248              	.L70:
 1249 0018 00000000 		.word	.LANCHOR11
 1250              		.cfi_endproc
 1251              	.LFE142:
 1253              		.section	.text._Z15MPU6000_ReadRegi,"ax",%progbits
 1254              		.align	1
 1255              		.global	_Z15MPU6000_ReadRegi
 1256              		.thumb
 1257              		.thumb_func
 1259              	_Z15MPU6000_ReadRegi:
 1260              	.LFB143:
 143:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 144:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** byte MPU6000_ReadReg(int addr)
 145:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1261              		.loc 10 145 0
 1262              		.cfi_startproc
 1263              		@ args = 0, pretend = 0, frame = 0
 1264              		@ frame_needed = 0, uses_anonymous_args = 0
 1265              	.LVL81:
 1266 0000 10B5     		push	{r4, lr}
 1267              	.LCFI9:
 1268              		.cfi_def_cfa_offset 8
 1269              		.cfi_offset 14, -4
 1270              		.cfi_offset 4, -8
 1271              		.loc 10 145 0
 1272 0002 0146     		mov	r1, r0
 1273              	.LBB35:
 146:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 147:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	sendByteI2C(MPU6000_I2C_ADDRESS, addr);
 148:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = readByteI2C(MPU6000_I2C_ADDRESS);
 149:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 150:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = spiMPU6000.Read(addr);
 1274              		.loc 10 150 0
 1275 0004 0448     		ldr	r0, .L73
 1276              	.LVL82:
 1277 0006 FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEi
 1278              	.LVL83:
 1279 000a 0446     		mov	r4, r0
 1280              	.LVL84:
 151:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 152:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1281              		.loc 10 152 0
 1282 000c 0120     		movs	r0, #1
 1283              	.LVL85:
 1284 000e FFF7FEFF 		bl	_Z5delaym
 1285              	.LBE35:
 153:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   return data;
 154:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1286              		.loc 10 154 0
 1287 0012 2046     		mov	r0, r4
 1288 0014 10BD     		pop	{r4, pc}
 1289              	.L74:
 1290 0016 00BF     		.align	2
 1291              	.L73:
 1292 0018 00000000 		.word	.LANCHOR11
 1293              		.cfi_endproc
 1294              	.LFE143:
 1296              		.section	.text._Z24initializeMPU6000Sensorsv,"ax",%progbits
 1297              		.align	1
 1298              		.global	_Z24initializeMPU6000Sensorsv
 1299              		.thumb
 1300              		.thumb_func
 1302              	_Z24initializeMPU6000Sensorsv:
 1303              	.LFB144:
 155:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 156:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** bool initializeMPU6000SensorsDone = false;
 157:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void initializeMPU6000Sensors()
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1304              		.loc 10 158 0
 1305              		.cfi_startproc
 1306              		@ args = 0, pretend = 0, frame = 0
 1307              		@ frame_needed = 0, uses_anonymous_args = 0
 1308              	.LBB36:
 159:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if(initializeMPU6000SensorsDone) {
 1309              		.loc 10 159 0
 1310 0000 1E4B     		ldr	r3, .L77
 1311              	.LBE36:
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1312              		.loc 10 158 0
 1313 0002 10B5     		push	{r4, lr}
 1314              	.LCFI10:
 1315              		.cfi_def_cfa_offset 8
 1316              		.cfi_offset 14, -4
 1317              		.cfi_offset 4, -8
 1318              	.LBB37:
 1319              		.loc 10 159 0
 1320 0004 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 1321 0006 002C     		cmp	r4, #0
 1322 0008 36D1     		bne	.L75
 160:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	return;
 161:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 162:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   initializeMPU6000SensorsDone = true;
 1323              		.loc 10 162 0
 1324 000a 0122     		movs	r2, #1
 1325 000c 1A70     		strb	r2, [r3, #0]
 163:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 164:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_SpiLowSpeed();
 1326              		.loc 10 164 0
 1327 000e FFF7FEFF 		bl	_Z19MPU6000_SpiLowSpeedv
 165:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 166:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned char val;
 167:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 168:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   val = MPU6000_ReadReg(MPUREG_WHOAMI);
 1328              		.loc 10 168 0
 1329 0012 7520     		movs	r0, #117
 1330 0014 FFF7FEFF 		bl	_Z15MPU6000_ReadRegi
 1331              	.LVL86:
 169:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if((val&0x7E) == 0x68) {
 1332              		.loc 10 169 0
 1333 0018 00F07E00 		and	r0, r0, #126
 1334              	.LVL87:
 1335 001c 6828     		cmp	r0, #104
 1336 001e 2BD1     		bne	.L75
 170:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	vehicleState |= GYRO_DETECTED;
 171:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	vehicleState |= ACCEL_DETECTED;
 1337              		.loc 10 171 0
 1338 0020 174B     		ldr	r3, .L77+4
 1339 0022 1868     		ldr	r0, [r3, #0]
 1340 0024 40F00301 		orr	r1, r0, #3
 1341 0028 1960     		str	r1, [r3, #0]
 172:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   } 
 173:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   else {
 174:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	return;
 175:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 176:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 177:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // Chip reset
 178:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_1, BIT_H_RESET);
 1342              		.loc 10 178 0
 1343 002a 6B20     		movs	r0, #107
 1344 002c 8021     		movs	r1, #128
 1345 002e FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 179:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(100);  // Startup time delay
 1346              		.loc 10 179 0
 1347 0032 6420     		movs	r0, #100
 1348 0034 FFF7FEFF 		bl	_Z5delaym
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 181:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 182:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Disable I2C bus
 183:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);
 1349              		.loc 10 183 0
 1350 0038 6A20     		movs	r0, #106
 1351 003a 1021     		movs	r1, #16
 1352 003c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 184:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 185:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 186:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // Wake Up device and select GyroZ clock (better performance)
 187:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_1, MPU_CLK_SEL_PLLGYROZ);
 1353              		.loc 10 187 0
 1354 0040 6B20     		movs	r0, #107
 1355 0042 0321     		movs	r1, #3
 1356 0044 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 188:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_2, 0);
 1357              		.loc 10 188 0
 1358 0048 6C20     		movs	r0, #108
 1359 004a 2146     		mov	r1, r4
 1360 004c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 189:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 190:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // SAMPLE RATE
 191:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_SMPLRT_DIV,0x00);     // Sample rate = 1kHz
 1361              		.loc 10 191 0
 1362 0050 1920     		movs	r0, #25
 1363 0052 2146     		mov	r1, r4
 1364 0054 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 192:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 193:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // FS & DLPF   FS=1000/s, DLPF = 42Hz (low pass filter)
 194:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_CONFIG, BITS_DLPF_CFG_42HZ);
 1365              		.loc 10 194 0
 1366 0058 1A20     		movs	r0, #26
 1367 005a 0321     		movs	r1, #3
 1368 005c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 195:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_GYRO_CONFIG,BITS_FS_1000DPS);  // Gyro scale 1000/s
 1369              		.loc 10 195 0
 1370 0060 1B20     		movs	r0, #27
 1371 0062 1021     		movs	r1, #16
 1372 0064 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 196:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_ACCEL_CONFIG,0x08);   // Accel scale +-4g (4096LSB/g)
 1373              		.loc 10 196 0
 1374 0068 1C20     		movs	r0, #28
 1375 006a 0821     		movs	r1, #8
 1376 006c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1377              	.LBE37:
 197:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 198:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 199:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // switch to high clock rate
 200:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_SpiHighSpeed();
 201:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1378              		.loc 10 201 0
 1379 0070 BDE81040 		pop	{r4, lr}
 1380              	.LBB38:
 200:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_SpiHighSpeed();
 1381              		.loc 10 200 0
 1382 0074 FFF7FEBF 		b	_Z20MPU6000_SpiHighSpeedv
 1383              	.L75:
 1384 0078 10BD     		pop	{r4, pc}
 1385              	.L78:
 1386 007a 00BF     		.align	2
 1387              	.L77:
 1388 007c 00000000 		.word	.LANCHOR12
 1389 0080 00000000 		.word	.LANCHOR13
 1390              	.LBE38:
 1391              		.cfi_endproc
 1392              	.LFE144:
 1394              		.section	.text._Z15MPU6000SwapDataPhi,"ax",%progbits
 1395              		.align	1
 1396              		.global	_Z15MPU6000SwapDataPhi
 1397              		.thumb
 1398              		.thumb_func
 1400              	_Z15MPU6000SwapDataPhi:
 1401              	.LFB145:
 202:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 203:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 204:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000SwapData(unsigned char *data, int datalen)
 205:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1402              		.loc 10 205 0
 1403              		.cfi_startproc
 1404              		@ args = 0, pretend = 0, frame = 0
 1405              		@ frame_needed = 0, uses_anonymous_args = 0
 1406              		@ link register save eliminated.
 1407              	.LVL88:
 1408              	.LBB39:
 206:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   datalen /= 2;
 1409              		.loc 10 206 0
 1410 0000 01EBD171 		add	r1, r1, r1, lsr #31
 1411              	.LVL89:
 1412 0004 4910     		asrs	r1, r1, #1
 1413              	.LVL90:
 207:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   while(datalen--) {
 1414              		.loc 10 207 0
 1415 0006 04E0     		b	.L80
 1416              	.LVL91:
 1417              	.L81:
 1418              	.LBB40:
 208:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     unsigned char t = data[0];
 1419              		.loc 10 208 0
 1420 0008 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 1421              	.LVL92:
 209:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[0] = data[1];
 1422              		.loc 10 209 0
 1423 000a 4278     		ldrb	r2, [r0, #1]	@ zero_extendqisi2
 210:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[1] = t;
 1424              		.loc 10 210 0
 1425 000c 4370     		strb	r3, [r0, #1]
 209:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[0] = data[1];
 1426              		.loc 10 209 0
 1427 000e 0270     		strb	r2, [r0, #0]
 211:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data += 2;
 1428              		.loc 10 211 0
 1429 0010 0230     		adds	r0, r0, #2
 1430              	.LVL93:
 1431              	.L80:
 1432              	.LBE40:
 207:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   while(datalen--) {
 1433              		.loc 10 207 0 discriminator 1
 1434 0012 11F1FF31 		adds	r1, r1, #-1
 1435              	.LVL94:
 1436 0016 F7D2     		bcs	.L81
 1437              	.LBE39:
 212:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 213:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1438              		.loc 10 213 0
 1439 0018 7047     		bx	lr
 1440              		.cfi_endproc
 1441              	.LFE145:
 1443              		.section	.text._Z18readMPU6000Sensorsv,"ax",%progbits
 1444              		.align	1
 1445              		.global	_Z18readMPU6000Sensorsv
 1446              		.thumb
 1447              		.thumb_func
 1449              	_Z18readMPU6000Sensorsv:
 1450              	.LFB146:
 214:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 215:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Sensors()
 216:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1451              		.loc 10 216 0
 1452              		.cfi_startproc
 1453              		@ args = 0, pretend = 0, frame = 0
 1454              		@ frame_needed = 0, uses_anonymous_args = 0
 1455 0000 10B5     		push	{r4, lr}
 1456              	.LCFI11:
 1457              		.cfi_def_cfa_offset 8
 1458              		.cfi_offset 14, -4
 1459              		.cfi_offset 4, -8
 217:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 218:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     sendByteI2C(MPU6000_I2C_ADDRESS, MPUREG_ACCEL_XOUT_H);
 219:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     Wire.requestFrom(MPU6000_I2C_ADDRESS, sizeof(MPU6000));
 220:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     for(byte i=0; i<sizeof(MPU6000)/sizeof(short); i++) {
 221:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****       MPU6000.rawWord[i] = readWordI2C();
 222:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     }
 223:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 224:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.Read(MPUREG_ACCEL_XOUT_H, MPU6000.rawByte, sizeof(MPU6000));
 1460              		.loc 10 224 0
 1461 0002 064C     		ldr	r4, .L83
 1462 0004 0648     		ldr	r0, .L83+4
 1463 0006 3B21     		movs	r1, #59
 1464 0008 2246     		mov	r2, r4
 1465 000a 0E23     		movs	r3, #14
 1466 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 225:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1467              		.loc 10 225 0
 1468 0010 2046     		mov	r0, r4
 1469 0012 0E21     		movs	r1, #14
 226:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 227:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1470              		.loc 10 227 0
 1471 0014 BDE81040 		pop	{r4, lr}
 225:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1472              		.loc 10 225 0
 1473 0018 FFF7FEBF 		b	_Z15MPU6000SwapDataPhi
 1474              	.L84:
 1475              		.align	2
 1476              	.L83:
 1477 001c 00000000 		.word	.LANCHOR14
 1478 0020 00000000 		.word	.LANCHOR11
 1479              		.cfi_endproc
 1480              	.LFE146:
 1482              		.section	.text._Z16readMPU6000Accelv,"ax",%progbits
 1483              		.align	1
 1484              		.global	_Z16readMPU6000Accelv
 1485              		.thumb
 1486              		.thumb_func
 1488              	_Z16readMPU6000Accelv:
 1489              	.LFB147:
 228:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 229:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000Count=0;
 230:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000AccelCount=0;
 231:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000GyroCount=0;
 232:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 233:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Accel()
 234:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1490              		.loc 10 234 0
 1491              		.cfi_startproc
 1492              		@ args = 0, pretend = 0, frame = 0
 1493              		@ frame_needed = 0, uses_anonymous_args = 0
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000AccelCount++;
 1494              		.loc 10 235 0
 1495 0000 0748     		ldr	r0, .L87
 234:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1496              		.loc 10 234 0
 1497 0002 10B5     		push	{r4, lr}
 1498              	.LCFI12:
 1499              		.cfi_def_cfa_offset 8
 1500              		.cfi_offset 14, -4
 1501              		.cfi_offset 4, -8
 236:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if(readMPU6000AccelCount != readMPU6000Count) {
 1502              		.loc 10 236 0
 1503 0004 074C     		ldr	r4, .L87+4
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000AccelCount++;
 1504              		.loc 10 235 0
 1505 0006 0168     		ldr	r1, [r0, #0]
 1506              		.loc 10 236 0
 1507 0008 2268     		ldr	r2, [r4, #0]
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000AccelCount++;
 1508              		.loc 10 235 0
 1509 000a 4B1C     		adds	r3, r1, #1
 1510              		.loc 10 236 0
 1511 000c 9342     		cmp	r3, r2
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000AccelCount++;
 1512              		.loc 10 235 0
 1513 000e 0360     		str	r3, [r0, #0]
 1514              		.loc 10 236 0
 1515 0010 04D0     		beq	.L85
 237:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     readMPU6000Sensors();
 1516              		.loc 10 237 0
 1517 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 238:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     readMPU6000Count++;
 1518              		.loc 10 238 0
 1519 0016 2368     		ldr	r3, [r4, #0]
 1520 0018 5A1C     		adds	r2, r3, #1
 1521 001a 2260     		str	r2, [r4, #0]
 1522              	.L85:
 1523 001c 10BD     		pop	{r4, pc}
 1524              	.L88:
 1525 001e 00BF     		.align	2
 1526              	.L87:
 1527 0020 00000000 		.word	.LANCHOR15
 1528 0024 00000000 		.word	.LANCHOR16
 1529              		.cfi_endproc
 1530              	.LFE147:
 1532              		.section	.text._Z15readMPU6000Gyrov,"ax",%progbits
 1533              		.align	1
 1534              		.global	_Z15readMPU6000Gyrov
 1535              		.thumb
 1536              		.thumb_func
 1538              	_Z15readMPU6000Gyrov:
 1539              	.LFB148:
 239:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 240:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 241:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 242:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Gyro()
 243:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1540              		.loc 10 243 0
 1541              		.cfi_startproc
 1542              		@ args = 0, pretend = 0, frame = 0
 1543              		@ frame_needed = 0, uses_anonymous_args = 0
 1544 0000 10B5     		push	{r4, lr}
 1545              	.LCFI13:
 1546              		.cfi_def_cfa_offset 8
 1547              		.cfi_offset 14, -4
 1548              		.cfi_offset 4, -8
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000GyroCount++;
 1549              		.loc 10 244 0
 1550 0002 074C     		ldr	r4, .L91
 245:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if(readMPU6000GyroCount != readMPU6000Count) {
 1551              		.loc 10 245 0
 1552 0004 0748     		ldr	r0, .L91+4
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000GyroCount++;
 1553              		.loc 10 244 0
 1554 0006 2168     		ldr	r1, [r4, #0]
 1555              		.loc 10 245 0
 1556 0008 0268     		ldr	r2, [r0, #0]
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000GyroCount++;
 1557              		.loc 10 244 0
 1558 000a 4B1C     		adds	r3, r1, #1
 1559              		.loc 10 245 0
 1560 000c 9342     		cmp	r3, r2
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000GyroCount++;
 1561              		.loc 10 244 0
 1562 000e 2360     		str	r3, [r4, #0]
 1563              		.loc 10 245 0
 1564 0010 04D0     		beq	.L89
 246:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     readMPU6000Sensors();
 1565              		.loc 10 246 0
 1566 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 247:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     readMPU6000GyroCount++;
 1567              		.loc 10 247 0
 1568 0016 2368     		ldr	r3, [r4, #0]
 1569 0018 5A1C     		adds	r2, r3, #1
 1570 001a 2260     		str	r2, [r4, #0]
 1571              	.L89:
 1572 001c 10BD     		pop	{r4, pc}
 1573              	.L92:
 1574 001e 00BF     		.align	2
 1575              	.L91:
 1576 0020 00000000 		.word	.LANCHOR17
 1577 0024 00000000 		.word	.LANCHOR16
 1578              		.cfi_endproc
 1579              	.LFE148:
 1581              		.section	.text._Z14initializeGyrov,"ax",%progbits
 1582              		.align	1
 1583              		.global	_Z14initializeGyrov
 1584              		.thumb
 1585              		.thumb_func
 1587              	_Z14initializeGyrov:
 1588              	.LFB149:
 1589              		.file 11 "../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h"
   1:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** /*
   2:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
   7:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  12:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  17:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** */
  20:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  21:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #ifndef _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  22:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #define _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  23:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  24:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** int gyroRaw[3] = {0,0,0};
  25:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  26:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Platform_MPU6000.h>
  27:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Gyroscope.h>
  28:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  29:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #define GYRO_CALIBRATION_TRESHOLD 25
  30:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  31:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void initializeGyro() {
 1590              		.loc 11 31 0
 1591              		.cfi_startproc
 1592              		@ args = 0, pretend = 0, frame = 0
 1593              		@ frame_needed = 0, uses_anonymous_args = 0
 1594              		@ link register save eliminated.
 1595              	.LVL95:
 1596              	.LBB41:
  32:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   float range = 2*1000.0;
  33:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroScaleFactor = radians(range/65536.0);
 1597              		.loc 11 33 0
 1598 0000 024A     		ldr	r2, .L94
 1599 0002 034B     		ldr	r3, .L94+4
 1600 0004 1A60     		str	r2, [r3, #0]	@ float
 1601              	.LBE41:
  34:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  35:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
  36:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1602              		.loc 11 36 0
 1603              	.LBB42:
  35:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
 1604              		.loc 11 35 0
 1605 0006 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 1606              	.L95:
 1607 000a 00BF     		.align	2
 1608              	.L94:
 1609 000c 58A00B3A 		.word	973840472
 1610 0010 00000000 		.word	.LANCHOR18
 1611              	.LBE42:
 1612              		.cfi_endproc
 1613              	.LFE149:
 1615              		.section	.text._Z17gyroUpdateHeadingv,"ax",%progbits
 1616              		.align	1
 1617              		.global	_Z17gyroUpdateHeadingv
 1618              		.thumb
 1619              		.thumb_func
 1621              	_Z17gyroUpdateHeadingv:
 1622              	.LFB150:
  37:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  38:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void gyroUpdateHeading()
  39:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** {
 1623              		.loc 11 39 0
 1624              		.cfi_startproc
 1625              		@ args = 0, pretend = 0, frame = 0
 1626              		@ frame_needed = 0, uses_anonymous_args = 0
 1627 0000 08B5     		push	{r3, lr}
 1628              	.LCFI14:
 1629              		.cfi_def_cfa_offset 8
 1630              		.cfi_offset 14, -4
 1631              		.cfi_offset 3, -8
 1632              	.LBB43:
  40:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   long int currentTime = micros();
 1633              		.loc 11 40 0
 1634 0002 FFF7FEFF 		bl	_ZL6microsv
 1635              	.LVL96:
  41:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   if (gyroRate[ZAXIS] > (float)radians(1.0) || gyroRate[ZAXIS] < (float)radians(-1.0)) {
 1636              		.loc 11 41 0
 1637 0006 124B     		ldr	r3, .L100
 1638 0008 DFED127A 		flds	s15, .L100+4
 1639 000c 93ED027A 		flds	s14, [r3, #8]
 1640 0010 B4EEE77A 		fcmpes	s14, s15
 1641 0014 F1EE10FA 		fmstat
 1642 0018 0F4B     		ldr	r3, .L100+8
 1643 001a 06DC     		bgt	.L97
 1644              		.loc 11 41 0 is_stmt 0 discriminator 1
 1645 001c 9FED0F0A 		flds	s0, .L100+12
 1646 0020 B4EEC07A 		fcmpes	s14, s0
 1647 0024 F1EE10FA 		fmstat
 1648 0028 10D5     		bpl	.L98
 1649              	.L97:
  42:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroHeading += gyroRate[ZAXIS] * ((currentTime - gyroLastMesuredTime) / 1000000.0);
 1650              		.loc 11 42 0 is_stmt 1
 1651 002a 1968     		ldr	r1, [r3, #0]
 1652 002c 0C4A     		ldr	r2, .L100+16
 1653 002e 411A     		subs	r1, r0, r1
 1654 0030 01EE901A 		fmsr	s3, r1	@ int
 1655 0034 9FED0B1A 		flds	s2, .L100+20
 1656 0038 F8EE616A 		fuitos	s13, s3
 1657 003c D2ED000A 		flds	s1, [r2, #0]
 1658 0040 C6EE816A 		fdivs	s13, s13, s2
 1659 0044 47EE260A 		fmacs	s1, s14, s13
 1660 0048 C2ED000A 		fsts	s1, [r2, #0]
 1661              	.L98:
  43:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  44:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroLastMesuredTime = currentTime;
 1662              		.loc 11 44 0
 1663 004c 1860     		str	r0, [r3, #0]
 1664              	.LBE43:
  45:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1665              		.loc 11 45 0
 1666 004e 08BD     		pop	{r3, pc}
 1667              	.L101:
 1668              		.align	2
 1669              	.L100:
 1670 0050 00000000 		.word	.LANCHOR19
 1671 0054 35FA8E3C 		.word	1016003125
 1672 0058 00000000 		.word	.LANCHOR21
 1673 005c 35FA8EBC 		.word	-1131480523
 1674 0060 00000000 		.word	.LANCHOR20
 1675 0064 00247449 		.word	1232348160
 1676              		.cfi_endproc
 1677              	.LFE150:
 1679              		.section	.text._Z11measureGyrov,"ax",%progbits
 1680              		.align	1
 1681              		.global	_Z11measureGyrov
 1682              		.thumb
 1683              		.thumb_func
 1685              	_Z11measureGyrov:
 1686              	.LFB151:
  46:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  47:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyro() {
 1687              		.loc 11 47 0
 1688              		.cfi_startproc
 1689              		@ args = 0, pretend = 0, frame = 16
 1690              		@ frame_needed = 0, uses_anonymous_args = 0
 1691 0000 30B5     		push	{r4, r5, lr}
 1692              	.LCFI15:
 1693              		.cfi_def_cfa_offset 12
 1694              		.cfi_offset 14, -4
 1695              		.cfi_offset 5, -8
 1696              		.cfi_offset 4, -12
 1697 0002 85B0     		sub	sp, sp, #20
 1698              	.LCFI16:
 1699              		.cfi_def_cfa_offset 32
 1700              	.LBB44:
  48:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Gyro();
 1701              		.loc 11 48 0
 1702 0004 FFF7FEFF 		bl	_Z15readMPU6000Gyrov
  49:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1703              		.loc 11 51 0
 1704 0008 1A4A     		ldr	r2, .L103
 1705 000a 1B49     		ldr	r1, .L103+4
 1706 000c B2F90850 		ldrsh	r5, [r2, #8]
 1707 0010 1A4B     		ldr	r3, .L103+8
 1708 0012 0C68     		ldr	r4, [r1, #0]
 1709 0014 1D60     		str	r5, [r3, #0]
 1710 0016 2C1B     		subs	r4, r5, r4
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1711              		.loc 11 52 0
 1712 0018 B2F90A00 		ldrsh	r0, [r2, #10]
 1713 001c 4D68     		ldr	r5, [r1, #4]
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1714              		.loc 11 53 0
 1715 001e B2F90C20 		ldrsh	r2, [r2, #12]
 1716 0022 8968     		ldr	r1, [r1, #8]
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1717              		.loc 11 52 0
 1718 0024 5860     		str	r0, [r3, #4]
 1719              		.loc 11 53 0
 1720 0026 9A60     		str	r2, [r3, #8]
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1721              		.loc 11 52 0
 1722 0028 281A     		subs	r0, r5, r0
 1723              		.loc 11 53 0
 1724 002a 8A1A     		subs	r2, r1, r2
 1725              	.LBB45:
  54:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  55:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  56:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 1726              		.loc 11 56 0
 1727 002c 01EE904A 		fmsr	s3, r4	@ int
 1728 0030 1349     		ldr	r1, .L103+12
 1729 0032 144B     		ldr	r3, .L103+16
 1730              	.LBE45:
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1731              		.loc 11 51 0
 1732 0034 0194     		str	r4, [sp, #4]
 1733              	.LBB46:
 1734              		.loc 11 56 0
 1735 0036 00EE900A 		fmsr	s1, r0	@ int
 1736 003a 06EE902A 		fmsr	s13, r2	@ int
 1737 003e D1ED007A 		flds	s15, [r1, #0]
 1738 0042 B8EEE11A 		fsitos	s2, s3
 1739 0046 B8EEE00A 		fsitos	s0, s1
 1740 004a B8EEE67A 		fsitos	s14, s13
 1741 004e 21EE271A 		fmuls	s2, s2, s15
 1742 0052 20EE270A 		fmuls	s0, s0, s15
 1743 0056 67EE277A 		fmuls	s15, s14, s15
 1744              	.LBE46:
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1745              		.loc 11 52 0
 1746 005a 0290     		str	r0, [sp, #8]
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1747              		.loc 11 53 0
 1748 005c 0392     		str	r2, [sp, #12]
 1749              	.LVL97:
 1750              	.LBB47:
 1751              		.loc 11 56 0
 1752 005e 83ED001A 		fsts	s2, [r3, #0]
 1753              	.LVL98:
 1754 0062 83ED010A 		fsts	s0, [r3, #4]
 1755              	.LVL99:
 1756 0066 C3ED027A 		fsts	s15, [r3, #8]
 1757              	.LVL100:
 1758              	.LBE47:
 1759              	.LBE44:
  57:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  58:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  59:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  60:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1760              		.loc 11 60 0
 1761 006a 05B0     		add	sp, sp, #20
 1762 006c BDE83040 		pop	{r4, r5, lr}
 1763              	.LBB48:
  59:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 1764              		.loc 11 59 0
 1765 0070 FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 1766              	.L104:
 1767              		.align	2
 1768              	.L103:
 1769 0074 00000000 		.word	.LANCHOR14
 1770 0078 00000000 		.word	.LANCHOR23
 1771 007c 00000000 		.word	.LANCHOR22
 1772 0080 00000000 		.word	.LANCHOR18
 1773 0084 00000000 		.word	.LANCHOR19
 1774              	.LBE48:
 1775              		.cfi_endproc
 1776              	.LFE151:
 1778              		.section	.text._Z14measureGyroSumv,"ax",%progbits
 1779              		.align	1
 1780              		.global	_Z14measureGyroSumv
 1781              		.thumb
 1782              		.thumb_func
 1784              	_Z14measureGyroSumv:
 1785              	.LFB152:
  61:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  62:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyroSum() {
 1786              		.loc 11 62 0
 1787              		.cfi_startproc
 1788              		@ args = 0, pretend = 0, frame = 0
 1789              		@ frame_needed = 0, uses_anonymous_args = 0
 1790 0000 10B5     		push	{r4, lr}
 1791              	.LCFI17:
 1792              		.cfi_def_cfa_offset 8
 1793              		.cfi_offset 14, -4
 1794              		.cfi_offset 4, -8
  63:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Gyro();
 1795              		.loc 11 63 0
 1796 0002 FFF7FEFF 		bl	_Z15readMPU6000Gyrov
  64:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] += (gyroRaw[XAXIS]=MPU6000.data.gyro.x);
 1797              		.loc 11 64 0
 1798 0006 0D4B     		ldr	r3, .L106
 1799 0008 0D49     		ldr	r1, .L106+4
 1800 000a 1C68     		ldr	r4, [r3, #0]
 1801 000c B1F90800 		ldrsh	r0, [r1, #8]
 1802 0010 0C4A     		ldr	r2, .L106+8
 1803 0012 2418     		adds	r4, r4, r0
 1804 0014 1C60     		str	r4, [r3, #0]
 1805 0016 1060     		str	r0, [r2, #0]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1806              		.loc 11 65 0
 1807 0018 5C68     		ldr	r4, [r3, #4]
 1808 001a B1F90A00 		ldrsh	r0, [r1, #10]
  66:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] += (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1809              		.loc 11 66 0
 1810 001e B1F90C10 		ldrsh	r1, [r1, #12]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1811              		.loc 11 65 0
 1812 0022 5060     		str	r0, [r2, #4]
 1813 0024 2018     		adds	r0, r4, r0
 1814 0026 5860     		str	r0, [r3, #4]
 1815              		.loc 11 66 0
 1816 0028 9868     		ldr	r0, [r3, #8]
 1817 002a 9160     		str	r1, [r2, #8]
 1818 002c 4118     		adds	r1, r0, r1
 1819 002e 9960     		str	r1, [r3, #8]
  67:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  68:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount++;
 1820              		.loc 11 68 0
 1821 0030 054B     		ldr	r3, .L106+12
 1822 0032 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 1823 0034 421C     		adds	r2, r0, #1
 1824 0036 1A70     		strb	r2, [r3, #0]
  69:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1825              		.loc 11 69 0
 1826 0038 10BD     		pop	{r4, pc}
 1827              	.L107:
 1828 003a 00BF     		.align	2
 1829              	.L106:
 1830 003c 00000000 		.word	.LANCHOR24
 1831 0040 00000000 		.word	.LANCHOR14
 1832 0044 00000000 		.word	.LANCHOR22
 1833 0048 00000000 		.word	.LANCHOR25
 1834              		.cfi_endproc
 1835              	.LFE152:
 1837              		.section	.text._Z16evaluateGyroRatev,"ax",%progbits
 1838              		.align	1
 1839              		.global	_Z16evaluateGyroRatev
 1840              		.thumb
 1841              		.thumb_func
 1843              	_Z16evaluateGyroRatev:
 1844              	.LFB153:
  70:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void evaluateGyroRate() {
 1845              		.loc 11 71 0
 1846              		.cfi_startproc
 1847              		@ args = 0, pretend = 0, frame = 16
 1848              		@ frame_needed = 0, uses_anonymous_args = 0
 1849 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1850              	.LCFI18:
 1851              		.cfi_def_cfa_offset 32
 1852              		.cfi_offset 14, -4
 1853              		.cfi_offset 6, -8
 1854              		.cfi_offset 5, -12
 1855              		.cfi_offset 4, -16
 1856              		.cfi_offset 3, -20
 1857              		.cfi_offset 2, -24
 1858              		.cfi_offset 1, -28
 1859              		.cfi_offset 0, -32
 1860              	.LBB49:
  72:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1861              		.loc 11 73 0
 1862 0002 1F4B     		ldr	r3, .L109
 1863 0004 1F4D     		ldr	r5, .L109+4
 1864 0006 1A68     		ldr	r2, [r3, #0]
 1865 0008 95F800C0 		ldrb	ip, [r5, #0]	@ zero_extendqisi2
  74:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 1866              		.loc 11 74 0
 1867 000c 5968     		ldr	r1, [r3, #4]
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1868              		.loc 11 73 0
 1869 000e 92FBFCF4 		sdiv	r4, r2, ip
 1870 0012 1D4A     		ldr	r2, .L109+8
 1871 0014 1068     		ldr	r0, [r2, #0]
 1872              		.loc 11 74 0
 1873 0016 5668     		ldr	r6, [r2, #4]
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1874              		.loc 11 73 0
 1875 0018 241A     		subs	r4, r4, r0
 1876              		.loc 11 74 0
 1877 001a 91FBFCF0 		sdiv	r0, r1, ip
 1878 001e 301A     		subs	r0, r6, r0
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1879              		.loc 11 75 0
 1880 0020 9E68     		ldr	r6, [r3, #8]
 1881 0022 9168     		ldr	r1, [r2, #8]
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1882              		.loc 11 73 0
 1883 0024 0194     		str	r4, [sp, #4]
 1884              		.loc 11 75 0
 1885 0026 96FBFCFC 		sdiv	ip, r6, ip
  76:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  77:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] = 0;
 1886              		.loc 11 77 0
 1887 002a 0022     		movs	r2, #0
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1888              		.loc 11 75 0
 1889 002c CCEB0101 		rsb	r1, ip, r1
 1890              		.loc 11 77 0
 1891 0030 1A60     		str	r2, [r3, #0]
  78:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] = 0;
 1892              		.loc 11 78 0
 1893 0032 5A60     		str	r2, [r3, #4]
  79:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] = 0;
 1894              		.loc 11 79 0
 1895 0034 9A60     		str	r2, [r3, #8]
  80:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount = 0;
 1896              		.loc 11 80 0
 1897 0036 2A70     		strb	r2, [r5, #0]
 1898              	.LVL101:
 1899              	.LBB50:
  81:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  82:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  83:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 1900              		.loc 11 83 0
 1901 0038 01EE904A 		fmsr	s3, r4	@ int
 1902 003c 134A     		ldr	r2, .L109+12
 1903 003e 144B     		ldr	r3, .L109+16
 1904              	.LBE50:
  74:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 1905              		.loc 11 74 0
 1906 0040 0290     		str	r0, [sp, #8]
 1907              	.LBB51:
 1908              		.loc 11 83 0
 1909 0042 00EE900A 		fmsr	s1, r0	@ int
 1910 0046 06EE901A 		fmsr	s13, r1	@ int
 1911 004a D2ED007A 		flds	s15, [r2, #0]
 1912 004e B8EEE11A 		fsitos	s2, s3
 1913 0052 B8EEE00A 		fsitos	s0, s1
 1914 0056 B8EEE67A 		fsitos	s14, s13
 1915 005a 21EE271A 		fmuls	s2, s2, s15
 1916 005e 20EE270A 		fmuls	s0, s0, s15
 1917 0062 67EE277A 		fmuls	s15, s14, s15
 1918              	.LBE51:
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1919              		.loc 11 75 0
 1920 0066 0391     		str	r1, [sp, #12]
 1921              	.LBB52:
 1922              		.loc 11 83 0
 1923 0068 83ED001A 		fsts	s2, [r3, #0]
 1924              	.LVL102:
 1925 006c 83ED010A 		fsts	s0, [r3, #4]
 1926              	.LVL103:
 1927 0070 C3ED027A 		fsts	s15, [r3, #8]
 1928              	.LVL104:
 1929              	.LBE52:
 1930              	.LBE49:
  84:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  85:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  86:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  87:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1931              		.loc 11 87 0
 1932 0074 04B0     		add	sp, sp, #16
 1933 0076 BDE87040 		pop	{r4, r5, r6, lr}
 1934              	.LBB53:
  86:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 1935              		.loc 11 86 0
 1936 007a FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 1937              	.L110:
 1938 007e 00BF     		.align	2
 1939              	.L109:
 1940 0080 00000000 		.word	.LANCHOR24
 1941 0084 00000000 		.word	.LANCHOR25
 1942 0088 00000000 		.word	.LANCHOR23
 1943 008c 00000000 		.word	.LANCHOR18
 1944 0090 00000000 		.word	.LANCHOR19
 1945              	.LBE53:
 1946              		.cfi_endproc
 1947              	.LFE153:
 1949              		.section	.text._Z13calibrateGyrov,"ax",%progbits
 1950              		.align	1
 1951              		.global	_Z13calibrateGyrov
 1952              		.thumb
 1953              		.thumb_func
 1955              	_Z13calibrateGyrov:
 1956              	.LFB154:
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  89:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  90:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** boolean calibrateGyro() {
 1957              		.loc 11 90 0
 1958              		.cfi_startproc
 1959              		@ args = 0, pretend = 0, frame = 200
 1960              		@ frame_needed = 0, uses_anonymous_args = 0
 1961 0000 70B5     		push	{r4, r5, r6, lr}
 1962              	.LCFI19:
 1963              		.cfi_def_cfa_offset 16
 1964              		.cfi_offset 14, -4
 1965              		.cfi_offset 6, -8
 1966              		.cfi_offset 5, -12
 1967              		.cfi_offset 4, -16
 1968 0002 B2B0     		sub	sp, sp, #200
 1969              	.LCFI20:
 1970              		.cfi_def_cfa_offset 216
 1971              	.LBB54:
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   
  92:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int findZero[FINDZERO];
  93:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int diff = 0; 
 1972              		.loc 11 93 0
 1973 0004 0024     		movs	r4, #0
 1974 0006 3194     		str	r4, [sp, #196]
 1975              	.LVL105:
 1976 0008 154D     		ldr	r5, .L122
 1977 000a 22E0     		b	.L112
 1978              	.LVL106:
 1979              	.L116:
 1980              	.LBB55:
 1981              	.LBB56:
 1982              	.LBB57:
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
  95:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
  96:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       readMPU6000Sensors();
 1983              		.loc 11 96 0
 1984 000c FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 1985 0010 144B     		ldr	r3, .L122+4
  97:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       if(axis == XAXIS) {
 1986              		.loc 11 97 0
 1987 0012 14B9     		cbnz	r4, .L113
  98:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.x;
 1988              		.loc 11 98 0
 1989 0014 B3F90830 		ldrsh	r3, [r3, #8]
 1990 0018 05E0     		b	.L121
 1991              	.L113:
  99:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } 
 100:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  else if(axis == YAXIS) {
 1992              		.loc 11 100 0
 1993 001a 012C     		cmp	r4, #1
 101:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.y;
 1994              		.loc 11 101 0
 1995 001c 0CBF     		ite	eq
 1996 001e B3F90A30 		ldrsheq	r3, [r3, #10]
 102:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } 
 103:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  else {
 104:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.z;
 1997              		.loc 11 104 0
 1998 0022 B3F90C30 		ldrshne	r3, [r3, #12]
 1999              	.L121:
 2000 0026 4DF80630 		str	r3, [sp, r6]
 105:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       }
 106:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       delay(10);
 2001              		.loc 11 106 0
 2002 002a 0A20     		movs	r0, #10
 2003 002c 0436     		adds	r6, r6, #4
 2004 002e FFF7FEFF 		bl	_Z5delaym
  95:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
 2005              		.loc 11 95 0
 2006 0032 C42E     		cmp	r6, #196
 2007 0034 EAD1     		bne	.L116
 2008              	.LBE57:
 107:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     }
 108:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     int tmp = findMedianIntWithDiff(findZero, FINDZERO, &diff);
 2009              		.loc 11 108 0
 2010 0036 3121     		movs	r1, #49
 2011 0038 6846     		mov	r0, sp
 2012 003a 31AA     		add	r2, sp, #196
 2013 003c FFF7FEFF 		bl	_Z21findMedianIntWithDiffPiiS_
 2014              	.LVL107:
 109:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	if (diff <= GYRO_CALIBRATION_TRESHOLD) { 
 2015              		.loc 11 109 0
 2016 0040 319B     		ldr	r3, [sp, #196]
 2017 0042 192B     		cmp	r3, #25
 2018 0044 07DC     		bgt	.L118
 2019              	.LBE56:
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2020              		.loc 11 94 0
 2021 0046 0134     		adds	r4, r4, #1
 2022 0048 E4B2     		uxtb	r4, r4
 2023              	.LVL108:
 2024 004a 032C     		cmp	r4, #3
 2025              	.LBB58:
 110:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  gyroZero[axis] = tmp;
 2026              		.loc 11 110 0
 2027 004c 45F8040F 		str	r0, [r5, #4]!
 2028              	.LBE58:
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2029              		.loc 11 94 0
 2030 0050 03D0     		beq	.L119
 2031              	.LVL109:
 2032              	.L112:
 2033              	.LBE55:
 2034              	.LBE54:
  90:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** boolean calibrateGyro() {
 2035              		.loc 11 90 0 discriminator 1
 2036 0052 0026     		movs	r6, #0
 2037 0054 DAE7     		b	.L116
 2038              	.LVL110:
 2039              	.L118:
 2040              	.LBB61:
 2041              	.LBB60:
 2042              	.LBB59:
 111:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	} 
 112:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	else {
 113:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 		return false; //Calibration failed.
 2043              		.loc 11 113 0
 2044 0056 0020     		movs	r0, #0
 2045              	.LVL111:
 2046 0058 00E0     		b	.L117
 2047              	.LVL112:
 2048              	.L119:
 2049              	.LBE59:
 114:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	}
 115:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
 116:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   return true;
 2050              		.loc 11 116 0
 2051 005a 0120     		movs	r0, #1
 2052              	.LVL113:
 2053              	.L117:
 2054              	.LBE60:
 2055              	.LBE61:
 117:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 2056              		.loc 11 117 0
 2057 005c 32B0     		add	sp, sp, #200
 2058 005e 70BD     		pop	{r4, r5, r6, pc}
 2059              	.L123:
 2060              		.align	2
 2061              	.L122:
 2062 0060 FCFFFFFF 		.word	.LANCHOR23-4
 2063 0064 00000000 		.word	.LANCHOR14
 2064              		.cfi_endproc
 2065              	.LFE154:
 2067              		.section	.text._Z15initializeAccelv,"ax",%progbits
 2068              		.align	1
 2069              		.global	_Z15initializeAccelv
 2070              		.thumb
 2071              		.thumb_func
 2073              	_Z15initializeAccelv:
 2074              	.LFB155:
 2075              		.file 12 "../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h"
   1:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** /*
   2:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
   7:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  12:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  17:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** */
  20:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  21:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #ifndef _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  22:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #define _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  23:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  24:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Platform_MPU6000.h>
  25:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Accelerometer.h>
  26:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  27:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void initializeAccel() {
 2076              		.loc 12 27 0
 2077              		.cfi_startproc
 2078              		@ args = 0, pretend = 0, frame = 0
 2079              		@ frame_needed = 0, uses_anonymous_args = 0
 2080              		@ link register save eliminated.
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   initializeMPU6000Sensors();
  29:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2081              		.loc 12 29 0
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   initializeMPU6000Sensors();
 2082              		.loc 12 28 0
 2083 0000 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 2084              		.cfi_endproc
 2085              	.LFE155:
 2087              		.section	.text._Z12measureAccelv,"ax",%progbits
 2088              		.align	1
 2089              		.global	_Z12measureAccelv
 2090              		.thumb
 2091              		.thumb_func
 2093              	_Z12measureAccelv:
 2094              	.LFB156:
  30:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  31:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  32:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccel() {
 2095              		.loc 12 32 0
 2096              		.cfi_startproc
 2097              		@ args = 0, pretend = 0, frame = 0
 2098              		@ frame_needed = 0, uses_anonymous_args = 0
 2099 0000 10B5     		push	{r4, lr}
 2100              	.LCFI21:
 2101              		.cfi_def_cfa_offset 8
 2102              		.cfi_offset 14, -4
 2103              		.cfi_offset 4, -8
  33:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Accel();
 2104              		.loc 12 33 0
 2105 0002 FFF7FEFF 		bl	_Z16readMPU6000Accelv
  34:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2106              		.loc 12 35 0
 2107 0006 1748     		ldr	r0, .L126
 2108 0008 1749     		ldr	r1, .L126+4
 2109 000a B0F90040 		ldrsh	r4, [r0, #0]
 2110 000e 174A     		ldr	r2, .L126+8
 2111 0010 174B     		ldr	r3, .L126+12
 2112 0012 04EE104A 		fmsr	s8, r4	@ int
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2113              		.loc 12 36 0
 2114 0016 B0F90240 		ldrsh	r4, [r0, #2]
  37:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[ZAXIS] = MPU6000.data.accel.z * accelScaleFactor[ZAXIS] + runTimeAccelBias[ZAXIS];
 2115              		.loc 12 37 0
 2116 001a B0F90400 		ldrsh	r0, [r0, #4]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2117              		.loc 12 36 0
 2118 001e 02EE104A 		fmsr	s4, r4	@ int
 2119              		.loc 12 37 0
 2120 0022 00EE100A 		fmsr	s0, r0	@ int
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2121              		.loc 12 35 0
 2122 0026 B8EEC43A 		fsitos	s6, s8
 2123 002a D1ED003A 		flds	s7, [r1, #0]
 2124 002e D2ED002A 		flds	s5, [r2, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2125              		.loc 12 36 0
 2126 0032 B8EEC21A 		fsitos	s2, s4
 2127 0036 D1ED011A 		flds	s3, [r1, #4]
 2128 003a D2ED010A 		flds	s1, [r2, #4]
 2129              		.loc 12 37 0
 2130 003e F8EEC06A 		fsitos	s13, s0
 2131 0042 91ED027A 		flds	s14, [r1, #8]
 2132 0046 D2ED027A 		flds	s15, [r2, #8]
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2133              		.loc 12 35 0
 2134 004a 43EE232A 		fmacs	s5, s6, s7
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2135              		.loc 12 36 0
 2136 004e 41EE210A 		fmacs	s1, s2, s3
 2137              		.loc 12 37 0
 2138 0052 46EE877A 		fmacs	s15, s13, s14
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2139              		.loc 12 35 0
 2140 0056 C3ED002A 		fsts	s5, [r3, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2141              		.loc 12 36 0
 2142 005a C3ED010A 		fsts	s1, [r3, #4]
 2143              		.loc 12 37 0
 2144 005e C3ED027A 		fsts	s15, [r3, #8]
  38:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2145              		.loc 12 38 0
 2146 0062 10BD     		pop	{r4, pc}
 2147              	.L127:
 2148              		.align	2
 2149              	.L126:
 2150 0064 00000000 		.word	.LANCHOR14
 2151 0068 00000000 		.word	.LANCHOR27
 2152 006c 00000000 		.word	.LANCHOR28
 2153 0070 00000000 		.word	.LANCHOR26
 2154              		.cfi_endproc
 2155              	.LFE156:
 2157              		.section	.text._Z15measureAccelSumv,"ax",%progbits
 2158              		.align	1
 2159              		.global	_Z15measureAccelSumv
 2160              		.thumb
 2161              		.thumb_func
 2163              	_Z15measureAccelSumv:
 2164              	.LFB157:
  39:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  40:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccelSum() {
 2165              		.loc 12 40 0
 2166              		.cfi_startproc
 2167              		@ args = 0, pretend = 0, frame = 0
 2168              		@ frame_needed = 0, uses_anonymous_args = 0
 2169 0000 08B5     		push	{r3, lr}
 2170              	.LCFI22:
 2171              		.cfi_def_cfa_offset 8
 2172              		.cfi_offset 14, -4
 2173              		.cfi_offset 3, -8
  41:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Accel();
 2174              		.loc 12 41 0
 2175 0002 FFF7FEFF 		bl	_Z16readMPU6000Accelv
  42:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[XAXIS] += MPU6000.data.accel.x;
 2176              		.loc 12 42 0
 2177 0006 0C4B     		ldr	r3, .L129
 2178 0008 0C4A     		ldr	r2, .L129+4
 2179 000a 1868     		ldr	r0, [r3, #0]
 2180 000c B2F900C0 		ldrsh	ip, [r2, #0]
 2181 0010 00EB0C01 		add	r1, r0, ip
 2182 0014 1960     		str	r1, [r3, #0]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2183              		.loc 12 43 0
 2184 0016 5868     		ldr	r0, [r3, #4]
 2185 0018 B2F90210 		ldrsh	r1, [r2, #2]
  44:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[ZAXIS] += MPU6000.data.accel.z;
 2186              		.loc 12 44 0
 2187 001c B2F904C0 		ldrsh	ip, [r2, #4]
 2188 0020 9A68     		ldr	r2, [r3, #8]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2189              		.loc 12 43 0
 2190 0022 4018     		adds	r0, r0, r1
 2191              		.loc 12 44 0
 2192 0024 02EB0C01 		add	r1, r2, ip
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2193              		.loc 12 43 0
 2194 0028 5860     		str	r0, [r3, #4]
 2195              		.loc 12 44 0
 2196 002a 9960     		str	r1, [r3, #8]
  45:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  46:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount++;
 2197              		.loc 12 46 0
 2198 002c 044B     		ldr	r3, .L129+8
 2199 002e 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 2200 0030 421C     		adds	r2, r0, #1
 2201 0032 1A70     		strb	r2, [r3, #0]
  47:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2202              		.loc 12 47 0
 2203 0034 08BD     		pop	{r3, pc}
 2204              	.L130:
 2205 0036 00BF     		.align	2
 2206              	.L129:
 2207 0038 00000000 		.word	.LANCHOR29
 2208 003c 00000000 		.word	.LANCHOR14
 2209 0040 00000000 		.word	.LANCHOR30
 2210              		.cfi_endproc
 2211              	.LFE157:
 2213              		.section	.text._Z20evaluateMetersPerSecv,"ax",%progbits
 2214              		.align	1
 2215              		.global	_Z20evaluateMetersPerSecv
 2216              		.thumb
 2217              		.thumb_func
 2219              	_Z20evaluateMetersPerSecv:
 2220              	.LFB158:
  48:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2221              		.loc 12 49 0
 2222              		.cfi_startproc
 2223              		@ args = 0, pretend = 0, frame = 0
 2224              		@ frame_needed = 0, uses_anonymous_args = 0
 2225              	.LVL114:
 2226 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2227              	.LCFI23:
 2228              		.cfi_def_cfa_offset 20
 2229              		.cfi_offset 14, -4
 2230              		.cfi_offset 7, -8
 2231              		.cfi_offset 6, -12
 2232              		.cfi_offset 5, -16
 2233              		.cfi_offset 4, -20
 2234              	.LBB62:
 2235              	.LBB63:
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2236              		.loc 12 51 0
 2237 0002 114A     		ldr	r2, .L134
 2238 0004 114C     		ldr	r4, .L134+4
 2239 0006 1778     		ldrb	r7, [r2, #0]	@ zero_extendqisi2
 2240 0008 1148     		ldr	r0, .L134+8
 2241 000a 1249     		ldr	r1, .L134+12
 2242 000c 0023     		movs	r3, #0
 2243 000e 1646     		mov	r6, r2
 2244              	.LVL115:
 2245              	.L132:
 2246              		.loc 12 51 0 is_stmt 0 discriminator 2
 2247 0010 114D     		ldr	r5, .L134+16
 2248 0012 5A59     		ldr	r2, [r3, r5]
 2249 0014 92FBF7F2 		sdiv	r2, r2, r7
 2250 0018 00EE102A 		fmsr	s0, r2	@ int
 2251 001c 0434     		adds	r4, r4, #4
 2252 001e 0430     		adds	r0, r0, #4
 2253 0020 F8EEC06A 		fsitos	s13, s0
 2254 0024 94ED007A 		flds	s14, [r4, #0]
 2255 0028 D0ED007A 		flds	s15, [r0, #0]
 2256 002c 46EE877A 		fmacs	s15, s13, s14
  52:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   	accelSample[axis] = 0;
 2257              		.loc 12 52 0 is_stmt 1 discriminator 2
 2258 0030 0022     		movs	r2, #0
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2259              		.loc 12 51 0 discriminator 2
 2260 0032 17EE90CA 		fmrs	ip, s15
 2261              		.loc 12 52 0 discriminator 2
 2262 0036 5A51     		str	r2, [r3, r5]
 2263 0038 0433     		adds	r3, r3, #4
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2264              		.loc 12 50 0 discriminator 2
 2265 003a 0C2B     		cmp	r3, #12
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2266              		.loc 12 51 0 discriminator 2
 2267 003c 41F804CF 		str	ip, [r1, #4]!	@ float
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2268              		.loc 12 50 0 discriminator 2
 2269 0040 E6D1     		bne	.L132
 2270              	.LBE63:
  53:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  54:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2271              		.loc 12 54 0
 2272 0042 3270     		strb	r2, [r6, #0]
 2273              	.LBE62:
  55:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2274              		.loc 12 55 0
 2275 0044 F0BD     		pop	{r4, r5, r6, r7, pc}
 2276              	.L135:
 2277 0046 00BF     		.align	2
 2278              	.L134:
 2279 0048 00000000 		.word	.LANCHOR30
 2280 004c FCFFFFFF 		.word	.LANCHOR27-4
 2281 0050 FCFFFFFF 		.word	.LANCHOR28-4
 2282 0054 FCFFFFFF 		.word	.LANCHOR26-4
 2283 0058 00000000 		.word	.LANCHOR29
 2284              		.cfi_endproc
 2285              	.LFE158:
 2287              		.section	.text._Z16computeAccelBiasv,"ax",%progbits
 2288              		.align	1
 2289              		.global	_Z16computeAccelBiasv
 2290              		.thumb
 2291              		.thumb_func
 2293              	_Z16computeAccelBiasv:
 2294              	.LFB159:
  56:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2295              		.loc 12 57 0
 2296              		.cfi_startproc
 2297              		@ args = 0, pretend = 0, frame = 0
 2298              		@ frame_needed = 0, uses_anonymous_args = 0
 2299              	.LVL116:
 2300 0000 10B5     		push	{r4, lr}
 2301              	.LCFI24:
 2302              		.cfi_def_cfa_offset 8
 2303              		.cfi_offset 14, -4
 2304              		.cfi_offset 4, -8
 2305              	.LBB64:
 2306              	.LBB65:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2307              		.loc 12 58 0
 2308 0002 0024     		movs	r4, #0
 2309 0004 08E0     		b	.L137
 2310              	.LVL117:
 2311              	.L138:
  59:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 	readMPU6000Sensors();
 2312              		.loc 12 59 0 discriminator 2
 2313 0006 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
  60:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     measureAccelSum();
 2314              		.loc 12 60 0 discriminator 2
 2315 000a FFF7FEFF 		bl	_Z15measureAccelSumv
  61:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     delayMicroseconds(2500);
 2316              		.loc 12 61 0 discriminator 2
 2317 000e 40F6C410 		movw	r0, #2500
 2318 0012 FFF7FEFF 		bl	_Z17delayMicrosecondsj
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2319              		.loc 12 58 0 discriminator 2
 2320 0016 0134     		adds	r4, r4, #1
 2321              	.LVL118:
 2322              	.L137:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2323              		.loc 12 58 0 is_stmt 0 discriminator 1
 2324 0018 B4F5C87F 		cmp	r4, #400
 2325 001c F3D1     		bne	.L138
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2326              		.loc 12 58 0
 2327 001e 2048     		ldr	r0, .L142
 2328 0020 2049     		ldr	r1, .L142+4
 2329 0022 0023     		movs	r3, #0
 2330              	.LVL119:
 2331              	.L139:
 2332              	.LBE65:
 2333              	.LBB66:
  62:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  63:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
  65:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2334              		.loc 12 65 0 is_stmt 1 discriminator 2
 2335 0024 204C     		ldr	r4, .L142+8
 2336 0026 1A59     		ldr	r2, [r3, r4]
 2337 0028 00EE902A 		fmsr	s1, r2	@ int
 2338 002c 9FED1F0A 		flds	s0, .L142+12
 2339 0030 B8EEE07A 		fsitos	s14, s1
 2340 0034 0430     		adds	r0, r0, #4
 2341 0036 87EE007A 		fdivs	s14, s14, s0
 2342 003a D0ED007A 		flds	s15, [r0, #0]
 2343 003e 67EE277A 		fmuls	s15, s14, s15
 2344 0042 17EE902A 		fmrs	r2, s15
 2345 0046 41F8042F 		str	r2, [r1, #4]!	@ float
  66:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     accelSample[axis] = 0;
 2346              		.loc 12 66 0 discriminator 2
 2347 004a 0022     		movs	r2, #0
 2348 004c 1A51     		str	r2, [r3, r4]
 2349 004e 0433     		adds	r3, r3, #4
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2350              		.loc 12 64 0 discriminator 2
 2351 0050 0C2B     		cmp	r3, #12
 2352 0052 E7D1     		bne	.L139
 2353              	.LBE66:
  67:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
  69:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2354              		.loc 12 70 0
 2355 0054 1649     		ldr	r1, .L142+16
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2356              		.loc 12 68 0
 2357 0056 174B     		ldr	r3, .L142+20
 2358              		.loc 12 70 0
 2359 0058 1748     		ldr	r0, .L142+24
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2360              		.loc 12 68 0
 2361 005a 1A70     		strb	r2, [r3, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2362              		.loc 12 72 0
 2363 005c 91ED022A 		flds	s4, [r1, #8]
 2364 0060 DFED162A 		flds	s5, .L142+28
 2365 0064 72EEC21A 		fsubs	s3, s5, s4
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2366              		.loc 12 70 0
 2367 0068 D1ED004A 		flds	s9, [r1, #0]
  73:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  74:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelOneG = abs(meterPerSecSec[ZAXIS] + runTimeAccelBias[ZAXIS]);
 2368              		.loc 12 74 0
 2369 006c 32EE211A 		fadds	s2, s4, s3
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2370              		.loc 12 71 0
 2371 0070 D1ED013A 		flds	s7, [r1, #4]
 2372              		.loc 12 74 0
 2373 0074 B5EEC01A 		fcmpezs	s2
 2374 0078 F1EE10FA 		fmstat
 2375 007c 104B     		ldr	r3, .L142+32
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2376              		.loc 12 70 0
 2377 007e B1EE644A 		fnegs	s8, s9
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2378              		.loc 12 71 0
 2379 0082 B1EE633A 		fnegs	s6, s7
 2380              		.loc 12 74 0
 2381 0086 D8BF     		it	le
 2382 0088 B1EE411A 		fnegsle	s2, s2
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2383              		.loc 12 70 0
 2384 008c 80ED004A 		fsts	s8, [r0, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2385              		.loc 12 71 0
 2386 0090 80ED013A 		fsts	s6, [r0, #4]
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2387              		.loc 12 72 0
 2388 0094 C0ED021A 		fsts	s3, [r0, #8]
 2389              		.loc 12 74 0
 2390 0098 83ED001A 		fsts	s2, [r3, #0]
 2391              	.LBE64:
  75:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2392              		.loc 12 75 0
 2393 009c 10BD     		pop	{r4, pc}
 2394              	.L143:
 2395 009e 00BF     		.align	2
 2396              	.L142:
 2397 00a0 FCFFFFFF 		.word	.LANCHOR27-4
 2398 00a4 FCFFFFFF 		.word	.LANCHOR26-4
 2399 00a8 00000000 		.word	.LANCHOR29
 2400 00ac 0000C843 		.word	1137180672
 2401 00b0 00000000 		.word	.LANCHOR26
 2402 00b4 00000000 		.word	.LANCHOR30
 2403 00b8 00000000 		.word	.LANCHOR28
 2404 00bc 6DE71CC1 		.word	-1055070355
 2405 00c0 00000000 		.word	.LANCHOR31
 2406              		.cfi_endproc
 2407              	.LFE159:
 2409              		.section	.text._Z12initPlatformv,"ax",%progbits
 2410              		.align	1
 2411              		.global	_Z12initPlatformv
 2412              		.thumb
 2413              		.thumb_func
 2415              	_Z12initPlatformv:
 2416              	.LFB160:
 2417              		.file 13 "../AeroQuad32/platform_aeroquad32.h"
   1:../AeroQuad32/platform_aeroquad32.h **** #ifndef _PLATFORM_AEROQUAD32_H_
   2:../AeroQuad32/platform_aeroquad32.h **** 
   3:../AeroQuad32/platform_aeroquad32.h **** #define _PLATFORM_AEROQUAD32_H_
   4:../AeroQuad32/platform_aeroquad32.h **** 
   5:../AeroQuad32/platform_aeroquad32.h **** static byte __attribute__((unused)) stm32_motor_mapping[] = {
   6:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  9),
   7:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  8),
   8:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  7),
   9:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  6),
  10:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('A', 15),
  11:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  3),
  12:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  4),
  13:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  5)
  14:../AeroQuad32/platform_aeroquad32.h **** };
  15:../AeroQuad32/platform_aeroquad32.h **** 
  16:../AeroQuad32/platform_aeroquad32.h **** static byte __attribute__((unused)) stm32_motor_mapping_tri[] = {
  17:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('A', 15), // note this must be on separate timer device !!
  18:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  8),
  19:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  7),
  20:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  6),
  21:../AeroQuad32/platform_aeroquad32.h **** };
  22:../AeroQuad32/platform_aeroquad32.h **** 
  23:../AeroQuad32/platform_aeroquad32.h **** #ifdef RECEIVER_STM32PPM
  24:../AeroQuad32/platform_aeroquad32.h ****   static byte receiverPinPPM = Port2Pin('D', 15);
  25:../AeroQuad32/platform_aeroquad32.h **** #elif defined ReceiverSBUS
  26:../AeroQuad32/platform_aeroquad32.h ****   // Do nothing
  27:../AeroQuad32/platform_aeroquad32.h **** #else
  28:../AeroQuad32/platform_aeroquad32.h ****   static byte receiverPin[] = {
  29:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 12),
  30:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 13),
  31:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 14),
  32:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 15),
  33:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E',  9),
  34:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 11),
  35:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 13),
  36:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 14)
  37:../AeroQuad32/platform_aeroquad32.h ****   };
  38:../AeroQuad32/platform_aeroquad32.h **** #endif
  39:../AeroQuad32/platform_aeroquad32.h **** 
  40:../AeroQuad32/platform_aeroquad32.h **** #define STM32_BOARD_TYPE "aeroquad32"
  41:../AeroQuad32/platform_aeroquad32.h **** #define LED_Green  Port2Pin('E', 6)
  42:../AeroQuad32/platform_aeroquad32.h **** #define LED_Red    Port2Pin('E', 5)
  43:../AeroQuad32/platform_aeroquad32.h **** #define LED_Yellow LED_Red
  44:../AeroQuad32/platform_aeroquad32.h **** 
  45:../AeroQuad32/platform_aeroquad32.h **** #define BATT_ANALOG_INPUT	Port2Pin('C', 0)
  46:../AeroQuad32/platform_aeroquad32.h **** #define A1       Port2Pin('B',0)
  47:../AeroQuad32/platform_aeroquad32.h **** #define A2       Port2Pin('C',4)
  48:../AeroQuad32/platform_aeroquad32.h **** #define A3       Port2Pin('B',1)
  49:../AeroQuad32/platform_aeroquad32.h **** #define A4       Port2Pin('C',5)
  50:../AeroQuad32/platform_aeroquad32.h **** #define A5       Port2Pin('C',2)
  51:../AeroQuad32/platform_aeroquad32.h **** #define A6       Port2Pin('C',3)
  52:../AeroQuad32/platform_aeroquad32.h **** 
  53:../AeroQuad32/platform_aeroquad32.h **** // external LED drivers
  54:../AeroQuad32/platform_aeroquad32.h **** #define PLED1 Port2Pin('D',  7)
  55:../AeroQuad32/platform_aeroquad32.h **** #define PLED2 Port2Pin('E',  0)
  56:../AeroQuad32/platform_aeroquad32.h **** #define PLED3 Port2Pin('E',  1)
  57:../AeroQuad32/platform_aeroquad32.h **** #define PLED4 Port2Pin('D',  4) 
  58:../AeroQuad32/platform_aeroquad32.h **** 
  59:../AeroQuad32/platform_aeroquad32.h **** #include <Device_I2C.h>
  60:../AeroQuad32/platform_aeroquad32.h **** 
  61:../AeroQuad32/platform_aeroquad32.h **** #include <Gyroscope_MPU6000.h>
  62:../AeroQuad32/platform_aeroquad32.h **** #include <Accelerometer_MPU6000.h>
  63:../AeroQuad32/platform_aeroquad32.h **** 
  64:../AeroQuad32/platform_aeroquad32.h **** // heading mag hold declaration
  65:../AeroQuad32/platform_aeroquad32.h **** #ifdef HeadingMagHold
  66:../AeroQuad32/platform_aeroquad32.h ****   #include <Compass.h>
  67:../AeroQuad32/platform_aeroquad32.h ****   #define HMC5883L
  68:../AeroQuad32/platform_aeroquad32.h **** #endif
  69:../AeroQuad32/platform_aeroquad32.h **** 
  70:../AeroQuad32/platform_aeroquad32.h **** // Altitude declaration
  71:../AeroQuad32/platform_aeroquad32.h **** #ifdef AltitudeHoldBaro
  72:../AeroQuad32/platform_aeroquad32.h ****   #define MS5611
  73:../AeroQuad32/platform_aeroquad32.h **** #endif
  74:../AeroQuad32/platform_aeroquad32.h **** 
  75:../AeroQuad32/platform_aeroquad32.h **** #ifdef AltitudeHoldRangeFinder
  76:../AeroQuad32/platform_aeroquad32.h ****   #define XLMAXSONAR
  77:../AeroQuad32/platform_aeroquad32.h **** #endif
  78:../AeroQuad32/platform_aeroquad32.h **** 
  79:../AeroQuad32/platform_aeroquad32.h **** // Battery Monitor declaration
  80:../AeroQuad32/platform_aeroquad32.h **** #ifdef BattMonitor
  81:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_AREF         3.3		// V
  82:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_R_HIGH       10.0		// kOhm
  83:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_R_LOW        1.5		// kOhm
  84:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_DIODE_LOSS		0.0
  85:../AeroQuad32/platform_aeroquad32.h ****   #define BattDefaultConfig DEFINE_BATTERY(0, BATT_ANALOG_INPUT, (BATT_AREF * (BATT_R_HIGH + BATT_R
  86:../AeroQuad32/platform_aeroquad32.h **** #endif
  87:../AeroQuad32/platform_aeroquad32.h **** 
  88:../AeroQuad32/platform_aeroquad32.h **** #ifdef OSD
  89:../AeroQuad32/platform_aeroquad32.h ****   #define MAX7456_OSD
  90:../AeroQuad32/platform_aeroquad32.h **** #endif
  91:../AeroQuad32/platform_aeroquad32.h **** 
  92:../AeroQuad32/platform_aeroquad32.h **** #ifdef CameraControl
  93:../AeroQuad32/platform_aeroquad32.h ****   #define CameraControl_STM32
  94:../AeroQuad32/platform_aeroquad32.h **** #endif
  95:../AeroQuad32/platform_aeroquad32.h **** 
  96:../AeroQuad32/platform_aeroquad32.h **** void initPlatform() {
 2418              		.loc 13 96 0
 2419              		.cfi_startproc
 2420              		@ args = 0, pretend = 0, frame = 0
 2421              		@ frame_needed = 0, uses_anonymous_args = 0
 2422 0000 10B5     		push	{r4, lr}
 2423              	.LCFI25:
 2424              		.cfi_def_cfa_offset 8
 2425              		.cfi_offset 14, -4
 2426              		.cfi_offset 4, -8
 2427              	.LBB67:
  97:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Green, OUTPUT);
 2428              		.loc 13 97 0
 2429 0002 4620     		movs	r0, #70
 2430 0004 0021     		movs	r1, #0
 2431 0006 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2432              	.LVL120:
  98:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2433              		.loc 13 98 0
 2434 000a 0024     		movs	r4, #0
 2435              	.LVL121:
 2436              	.L145:
 2437              	.LBB68:
  99:../AeroQuad32/platform_aeroquad32.h ****     digitalWrite(LED_Green, ledloop & 1);
 2438              		.loc 13 99 0 discriminator 2
 2439 000c 4620     		movs	r0, #70
 2440 000e 04F00101 		and	r1, r4, #1
  98:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2441              		.loc 13 98 0 discriminator 2
 2442 0012 0134     		adds	r4, r4, #1
 2443              		.loc 13 99 0 discriminator 2
 2444 0014 FFF7FEFF 		bl	_Z12digitalWritehh
  98:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2445              		.loc 13 98 0 discriminator 2
 2446 0018 E4B2     		uxtb	r4, r4
 100:../AeroQuad32/platform_aeroquad32.h ****     delay(50);
 2447              		.loc 13 100 0 discriminator 2
 2448 001a 3220     		movs	r0, #50
 2449 001c FFF7FEFF 		bl	_Z5delaym
 2450              	.LVL122:
  98:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2451              		.loc 13 98 0 discriminator 2
 2452 0020 0A2C     		cmp	r4, #10
 2453 0022 F3D1     		bne	.L145
 2454              	.LBE68:
 101:../AeroQuad32/platform_aeroquad32.h ****   }
 102:../AeroQuad32/platform_aeroquad32.h **** 
 103:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Red, OUTPUT);
 2455              		.loc 13 103 0
 2456 0024 4520     		movs	r0, #69
 2457 0026 0021     		movs	r1, #0
 2458 0028 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 104:../AeroQuad32/platform_aeroquad32.h ****   digitalWrite(LED_Red, LOW);
 2459              		.loc 13 104 0
 2460 002c 4520     		movs	r0, #69
 2461 002e 0021     		movs	r1, #0
 2462 0030 FFF7FEFF 		bl	_Z12digitalWritehh
 105:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Yellow, OUTPUT);
 2463              		.loc 13 105 0
 2464 0034 4520     		movs	r0, #69
 2465 0036 0021     		movs	r1, #0
 2466 0038 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 106:../AeroQuad32/platform_aeroquad32.h ****   digitalWrite(LED_Yellow, LOW);
 2467              		.loc 13 106 0
 2468 003c 4520     		movs	r0, #69
 2469 003e 0021     		movs	r1, #0
 2470 0040 FFF7FEFF 		bl	_Z12digitalWritehh
 107:../AeroQuad32/platform_aeroquad32.h **** 
 108:../AeroQuad32/platform_aeroquad32.h ****   pinMode(BATT_ANALOG_INPUT, INPUT_ANALOG);
 2471              		.loc 13 108 0
 2472 0044 2020     		movs	r0, #32
 2473 0046 0321     		movs	r1, #3
 2474 0048 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 109:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A1, INPUT_ANALOG);
 2475              		.loc 13 109 0
 2476 004c 1020     		movs	r0, #16
 2477 004e 0321     		movs	r1, #3
 2478 0050 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 110:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A2, INPUT_ANALOG);
 2479              		.loc 13 110 0
 2480 0054 2420     		movs	r0, #36
 2481 0056 0321     		movs	r1, #3
 2482 0058 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 111:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A3, INPUT_ANALOG);
 2483              		.loc 13 111 0
 2484 005c 1120     		movs	r0, #17
 2485 005e 0321     		movs	r1, #3
 2486 0060 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 112:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A4, INPUT_ANALOG);
 2487              		.loc 13 112 0
 2488 0064 2520     		movs	r0, #37
 2489 0066 0321     		movs	r1, #3
 2490 0068 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 113:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A5, INPUT_ANALOG);
 2491              		.loc 13 113 0
 2492 006c 2220     		movs	r0, #34
 2493 006e 0321     		movs	r1, #3
 2494 0070 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 114:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A6, INPUT_ANALOG);
 2495              		.loc 13 114 0
 2496 0074 0321     		movs	r1, #3
 2497 0076 2320     		movs	r0, #35
 2498 0078 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 115:../AeroQuad32/platform_aeroquad32.h **** 
 116:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED1, OUTPUT);
 2499              		.loc 13 116 0
 2500 007c 3720     		movs	r0, #55
 2501 007e 0021     		movs	r1, #0
 2502 0080 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 117:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED2, OUTPUT);
 2503              		.loc 13 117 0
 2504 0084 4020     		movs	r0, #64
 2505 0086 0021     		movs	r1, #0
 2506 0088 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 118:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED3, OUTPUT);
 2507              		.loc 13 118 0
 2508 008c 4120     		movs	r0, #65
 2509 008e 0021     		movs	r1, #0
 2510 0090 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 119:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED4, OUTPUT);
 2511              		.loc 13 119 0
 2512 0094 3420     		movs	r0, #52
 2513 0096 0021     		movs	r1, #0
 2514 0098 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 120:../AeroQuad32/platform_aeroquad32.h **** 
 121:../AeroQuad32/platform_aeroquad32.h ****   // I2C setup
 122:../AeroQuad32/platform_aeroquad32.h ****   Wire.begin(Port2Pin('B', 7), Port2Pin('B', 6)); // I2C1_SDA PB7, I2C1_SCL PB6
 2515              		.loc 13 122 0
 2516 009c 0348     		ldr	r0, .L147
 2517 009e 1721     		movs	r1, #23
 2518 00a0 1622     		movs	r2, #22
 2519              	.LBE67:
 123:../AeroQuad32/platform_aeroquad32.h **** 
 124:../AeroQuad32/platform_aeroquad32.h ****   #if !defined(USE_USB_SERIAL)
 125:../AeroQuad32/platform_aeroquad32.h ****     SerialUSB.begin();
 126:../AeroQuad32/platform_aeroquad32.h ****   #endif
 127:../AeroQuad32/platform_aeroquad32.h **** }
 2520              		.loc 13 127 0
 2521 00a2 BDE81040 		pop	{r4, lr}
 2522              	.LBB69:
 122:../AeroQuad32/platform_aeroquad32.h ****   Wire.begin(Port2Pin('B', 7), Port2Pin('B', 6)); // I2C1_SDA PB7, I2C1_SCL PB6
 2523              		.loc 13 122 0
 2524 00a6 FFF7FEBF 		b	_ZN7TwoWire5beginEhh
 2525              	.L148:
 2526 00aa 00BF     		.align	2
 2527              	.L147:
 2528 00ac 00000000 		.word	Wire
 2529              	.LBE69:
 2530              		.cfi_endproc
 2531              	.LFE160:
 2533              		.section	.text._Z42initializePlatformSpecificAccelCalibrationv,"ax",%progbits
 2534              		.align	1
 2535              		.global	_Z42initializePlatformSpecificAccelCalibrationv
 2536              		.thumb
 2537              		.thumb_func
 2539              	_Z42initializePlatformSpecificAccelCalibrationv:
 2540              	.LFB161:
 128:../AeroQuad32/platform_aeroquad32.h **** 
 129:../AeroQuad32/platform_aeroquad32.h **** // called when eeprom is initialized
 130:../AeroQuad32/platform_aeroquad32.h **** void initializePlatformSpecificAccelCalibration() {
 2541              		.loc 13 130 0
 2542              		.cfi_startproc
 2543              		@ args = 0, pretend = 0, frame = 0
 2544              		@ frame_needed = 0, uses_anonymous_args = 0
 2545              		@ link register save eliminated.
 131:../AeroQuad32/platform_aeroquad32.h ****   // Kenny default value, a real accel calibration is strongly recommended
 132:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[XAXIS] = 0.0011970000;
 2546              		.loc 13 132 0
 2547 0000 034B     		ldr	r3, .L150
 2548 0002 0449     		ldr	r1, .L150+4
 133:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[YAXIS] = -0.0012050000;
 2549              		.loc 13 133 0
 2550 0004 0448     		ldr	r0, .L150+8
 134:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[ZAXIS] = -0.0011770000;
 2551              		.loc 13 134 0
 2552 0006 054A     		ldr	r2, .L150+12
 132:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[XAXIS] = 0.0011970000;
 2553              		.loc 13 132 0
 2554 0008 1960     		str	r1, [r3, #0]	@ float
 133:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[YAXIS] = -0.0012050000;
 2555              		.loc 13 133 0
 2556 000a 5860     		str	r0, [r3, #4]	@ float
 2557              		.loc 13 134 0
 2558 000c 9A60     		str	r2, [r3, #8]	@ float
 135:../AeroQuad32/platform_aeroquad32.h ****   #ifdef HeadingMagHold
 136:../AeroQuad32/platform_aeroquad32.h ****     magBias[XAXIS]  = 152.000000;
 137:../AeroQuad32/platform_aeroquad32.h ****     magBias[YAXIS]  = 24.000000;
 138:../AeroQuad32/platform_aeroquad32.h ****     magBias[ZAXIS]  = 16.500000;
 139:../AeroQuad32/platform_aeroquad32.h ****   #endif
 140:../AeroQuad32/platform_aeroquad32.h **** 
 141:../AeroQuad32/platform_aeroquad32.h **** }
 2559              		.loc 13 141 0
 2560 000e 7047     		bx	lr
 2561              	.L151:
 2562              		.align	2
 2563              	.L150:
 2564 0010 00000000 		.word	.LANCHOR27
 2565 0014 A8E49C3A 		.word	983360680
 2566 0018 17F19DBA 		.word	-1164054249
 2567 001c 91459ABA 		.word	-1164294767
 2568              		.cfi_endproc
 2569              	.LFE161:
 2571              		.section	.text._Z22measureCriticalSensorsv,"ax",%progbits
 2572              		.align	1
 2573              		.global	_Z22measureCriticalSensorsv
 2574              		.thumb
 2575              		.thumb_func
 2577              	_Z22measureCriticalSensorsv:
 2578              	.LFB162:
 142:../AeroQuad32/platform_aeroquad32.h **** 
 143:../AeroQuad32/platform_aeroquad32.h **** unsigned long previousMeasureCriticalSensorsTime = 0;
 144:../AeroQuad32/platform_aeroquad32.h **** void measureCriticalSensors() {
 2579              		.loc 13 144 0
 2580              		.cfi_startproc
 2581              		@ args = 0, pretend = 0, frame = 0
 2582              		@ frame_needed = 0, uses_anonymous_args = 0
 2583 0000 38B5     		push	{r3, r4, r5, lr}
 2584              	.LCFI26:
 2585              		.cfi_def_cfa_offset 16
 2586              		.cfi_offset 14, -4
 2587              		.cfi_offset 5, -8
 2588              		.cfi_offset 4, -12
 2589              		.cfi_offset 3, -16
 145:../AeroQuad32/platform_aeroquad32.h ****   // read sensors not faster than every 1 ms
 146:../AeroQuad32/platform_aeroquad32.h ****   if (currentTime - previousMeasureCriticalSensorsTime >= 1000) {
 2590              		.loc 13 146 0
 2591 0002 074D     		ldr	r5, .L154
 2592 0004 074C     		ldr	r4, .L154+4
 2593 0006 2A68     		ldr	r2, [r5, #0]
 2594 0008 2068     		ldr	r0, [r4, #0]
 2595 000a 131A     		subs	r3, r2, r0
 2596 000c B3F57A7F 		cmp	r3, #1000
 2597 0010 05D3     		bcc	.L152
 147:../AeroQuad32/platform_aeroquad32.h ****     measureGyroSum();
 2598              		.loc 13 147 0
 2599 0012 FFF7FEFF 		bl	_Z14measureGyroSumv
 148:../AeroQuad32/platform_aeroquad32.h ****     measureAccelSum();
 2600              		.loc 13 148 0
 2601 0016 FFF7FEFF 		bl	_Z15measureAccelSumv
 149:../AeroQuad32/platform_aeroquad32.h ****     previousMeasureCriticalSensorsTime = currentTime;
 2602              		.loc 13 149 0
 2603 001a 2968     		ldr	r1, [r5, #0]
 2604 001c 2160     		str	r1, [r4, #0]
 2605              	.L152:
 2606 001e 38BD     		pop	{r3, r4, r5, pc}
 2607              	.L155:
 2608              		.align	2
 2609              	.L154:
 2610 0020 00000000 		.word	.LANCHOR7
 2611 0024 00000000 		.word	.LANCHOR32
 2612              		.cfi_endproc
 2613              	.LFE162:
 2615              		.section	.text._Z29initializeBaseKinematicsParamv,"ax",%progbits
 2616              		.align	1
 2617              		.global	_Z29initializeBaseKinematicsParamv
 2618              		.thumb
 2619              		.thumb_func
 2621              	_Z29initializeBaseKinematicsParamv:
 2622              	.LFB163:
 2623              		.file 14 "../Libraries/AQ_Kinematics/Kinematics.h"
   1:../Libraries/AQ_Kinematics/Kinematics.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics.h **** #ifndef _AQ_KINEMATICS_
  22:../Libraries/AQ_Kinematics/Kinematics.h **** #define _AQ_KINEMATICS_
  23:../Libraries/AQ_Kinematics/Kinematics.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics.h **** #include "GlobalDefined.h"
  25:../Libraries/AQ_Kinematics/Kinematics.h **** 
  26:../Libraries/AQ_Kinematics/Kinematics.h **** #define CF 0
  27:../Libraries/AQ_Kinematics/Kinematics.h **** #define KF 1
  28:../Libraries/AQ_Kinematics/Kinematics.h **** #define DCM 2
  29:../Libraries/AQ_Kinematics/Kinematics.h **** #define ARG 3
  30:../Libraries/AQ_Kinematics/Kinematics.h **** #define MARG 4
  31:../Libraries/AQ_Kinematics/Kinematics.h **** 
  32:../Libraries/AQ_Kinematics/Kinematics.h **** // This class is responsible for calculating vehicle attitude
  33:../Libraries/AQ_Kinematics/Kinematics.h **** byte kinematicsType = 0;
  34:../Libraries/AQ_Kinematics/Kinematics.h **** float kinematicsAngle[3] = {0.0,0.0,0.0};
  35:../Libraries/AQ_Kinematics/Kinematics.h **** float gyroAngle[2] = {0.0,0.0};
  36:../Libraries/AQ_Kinematics/Kinematics.h **** float correctedRateVector[3] = {0.0,0.0,0.0};
  37:../Libraries/AQ_Kinematics/Kinematics.h **** float earthAccel[3] = {0.0,0.0,0.0};
  38:../Libraries/AQ_Kinematics/Kinematics.h **** 
  39:../Libraries/AQ_Kinematics/Kinematics.h **** float accelCutoff = 0.0;
  40:../Libraries/AQ_Kinematics/Kinematics.h **** 
  41:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeBaseKinematicsParam() {
 2624              		.loc 14 41 0
 2625              		.cfi_startproc
 2626              		@ args = 0, pretend = 0, frame = 0
 2627              		@ frame_needed = 0, uses_anonymous_args = 0
 2628              		@ link register save eliminated.
 2629              	.LVL123:
 2630              	.LBB70:
 2631              	.LBB71:
  42:../Libraries/AQ_Kinematics/Kinematics.h **** 
  43:../Libraries/AQ_Kinematics/Kinematics.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2632              		.loc 14 44 0
 2633 0000 0448     		ldr	r0, .L157
 2634              	.LBE71:
  45:../Libraries/AQ_Kinematics/Kinematics.h ****   }
  46:../Libraries/AQ_Kinematics/Kinematics.h ****   gyroAngle[XAXIS] = 0;
 2635              		.loc 14 46 0
 2636 0002 054A     		ldr	r2, .L157+4
 2637              	.LBB72:
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2638              		.loc 14 44 0
 2639 0004 0023     		movs	r3, #0
 2640 0006 0360     		str	r3, [r0, #0]	@ float
 2641              	.LVL124:
 2642 0008 4360     		str	r3, [r0, #4]	@ float
 2643              	.LVL125:
 2644 000a 8360     		str	r3, [r0, #8]	@ float
 2645              	.LVL126:
 2646              	.LBE72:
 2647              		.loc 14 46 0
 2648 000c 1360     		str	r3, [r2, #0]	@ float
  47:../Libraries/AQ_Kinematics/Kinematics.h ****   gyroAngle[YAXIS] = 0;
 2649              		.loc 14 47 0
 2650 000e 5360     		str	r3, [r2, #4]	@ float
 2651              	.LBE70:
  48:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2652              		.loc 14 48 0
 2653 0010 7047     		bx	lr
 2654              	.L158:
 2655 0012 00BF     		.align	2
 2656              	.L157:
 2657 0014 00000000 		.word	.LANCHOR33
 2658 0018 00000000 		.word	.LANCHOR34
 2659              		.cfi_endproc
 2660              	.LFE163:
 2662              		.section	.text._Z27kinematicsGetDegreesHeadingh,"ax",%progbits
 2663              		.align	1
 2664              		.global	_Z27kinematicsGetDegreesHeadingh
 2665              		.thumb
 2666              		.thumb_func
 2668              	_Z27kinematicsGetDegreesHeadingh:
 2669              	.LFB164:
  49:../Libraries/AQ_Kinematics/Kinematics.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeKinematics(float hdgX, float hdgY);
  51:../Libraries/AQ_Kinematics/Kinematics.h **** void calculateKinematics(float rollRate,           float pitchRate,     float yawRate,       
  52:../Libraries/AQ_Kinematics/Kinematics.h ****                          float longitudinalAccel,  float lateralAccel,  float verticalAccel, 
  53:../Libraries/AQ_Kinematics/Kinematics.h ****                          float G_Dt);
  54:../Libraries/AQ_Kinematics/Kinematics.h **** float getGyroUnbias(byte axis);
  55:../Libraries/AQ_Kinematics/Kinematics.h **** void calibrateKinematics();
  56:../Libraries/AQ_Kinematics/Kinematics.h ****  
  57:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns the kinematicsAngle of a specific axis in SI units (radians)
  58:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getData(byte axis) {
  59:../Libraries/AQ_Kinematics/Kinematics.h **** //    return kinematicsAngle[axis];
  60:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  61:../Libraries/AQ_Kinematics/Kinematics.h ****   // return heading as +PI/-PI
  62:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getHeading(byte axis) {
  63:../Libraries/AQ_Kinematics/Kinematics.h **** //    return(kinematicsAngle[axis]);
  64:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  65:../Libraries/AQ_Kinematics/Kinematics.h ****   
  66:../Libraries/AQ_Kinematics/Kinematics.h ****   // This really needs to be in Radians to be consistent
  67:../Libraries/AQ_Kinematics/Kinematics.h ****   // I'll fix later - AKA
  68:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns heading in degrees as 0-360
  69:../Libraries/AQ_Kinematics/Kinematics.h **** const float kinematicsGetDegreesHeading(byte axis) {
 2670              		.loc 14 69 0
 2671              		.cfi_startproc
 2672              		@ args = 0, pretend = 0, frame = 0
 2673              		@ frame_needed = 0, uses_anonymous_args = 0
 2674              		@ link register save eliminated.
 2675              	.LVL127:
 2676              	.LBB73:
  70:../Libraries/AQ_Kinematics/Kinematics.h ****   float tDegrees;
  71:../Libraries/AQ_Kinematics/Kinematics.h ****     
  72:../Libraries/AQ_Kinematics/Kinematics.h ****   tDegrees = degrees(kinematicsAngle[axis]);
 2677              		.loc 14 72 0
 2678 0000 0A49     		ldr	r1, .L163
 2679 0002 01EB8003 		add	r3, r1, r0, lsl #2
 2680 0006 93ED007A 		flds	s14, [r3, #0]
 2681 000a DFED097A 		flds	s15, .L163+4
 2682 000e 67EE277A 		fmuls	s15, s14, s15
 2683              	.LVL128:
  73:../Libraries/AQ_Kinematics/Kinematics.h ****   if (tDegrees < 0.0)
 2684              		.loc 14 73 0
 2685 0012 F5EEC07A 		fcmpezs	s15
 2686 0016 F1EE10FA 		fmstat
  74:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees + 360.0);
 2687              		.loc 14 74 0
 2688 001a 44BF     		itt	mi
 2689 001c 9FED057A 		fldsmi	s14, .L163+8
 2690 0020 77EE877A 		faddsmi	s15, s15, s14
 2691              	.LVL129:
 2692              	.LBE73:
  75:../Libraries/AQ_Kinematics/Kinematics.h ****   else
  76:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees);
  77:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2693              		.loc 14 77 0
 2694 0024 17EE900A 		fmrs	r0, s15
 2695              	.LVL130:
 2696 0028 7047     		bx	lr
 2697              	.L164:
 2698 002a 00BF     		.align	2
 2699              	.L163:
 2700 002c 00000000 		.word	.LANCHOR33
 2701 0030 E12E6542 		.word	1113927393
 2702 0034 0000B443 		.word	1135869952
 2703              		.cfi_endproc
 2704              	.LFE164:
 2706              		.global	__aeabi_f2d
 2707              		.global	__aeabi_d2f
 2708              		.section	.text._Z9argUpdatefffffff,"ax",%progbits
 2709              		.align	1
 2710              		.global	_Z9argUpdatefffffff
 2711              		.thumb
 2712              		.thumb_func
 2714              	_Z9argUpdatefffffff:
 2715              	.LFB165:
 2716              		.file 15 "../Libraries/AQ_Kinematics/Kinematics_ARG.h"
   1:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #ifndef _AQ_KINEMATICS_ARG_
  22:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #define _AQ_KINEMATICS_ARG_
  23:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  25:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // IMU.c
  26:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // S.O.H. Madgwick
  27:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // 25th September 2010
  28:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  29:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Description:
  30:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  31:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Quaternion implementation of the 'DCM filter' [Mayhony et al].
  32:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  33:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must define 'halfT' as the (sample period / 2), and the filter gains 'Kp' and 'Ki'.
  34:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  35:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Global variables 'q0', 'q1', 'q2', 'q3' are the quaternion elements representing the estimated
  36:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // orientation.  See my report for an overview of the use of quaternions in this application.
  37:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  38:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must call 'IMUupdate()' every sample period and parse calibrated gyroscope ('gx', 'gy', 'gz
  39:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // and accelerometer ('ax', 'ay', 'ay') data.  Gyroscope units are radians/second, accelerometer 
  40:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // units are irrelevant as the vector is normalised.
  41:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  42:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  43:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  44:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  45:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  46:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // ARG - Accelerometer, Rate Gyro
  47:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  48:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  49:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include "Kinematics.h"
  51:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  52:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include <AQMath.h>
  53:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  54:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Kp = 0.0;                   					// proportional gain governs rate of convergence to accelero
  55:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Ki = 0.0;                   					// integral gain governs rate of convergence of gyroscope bi
  56:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float halfT = 0.0;                					// half the sample period
  57:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float q0 = 0.0, q1 = 0.0, q2 = 0.0, q3 = 0.0;       // quaternion elements representing the estimat
  58:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float exInt = 0.0, eyInt = 0.0, ezInt = 0.0;  		// scaled integral error
  59:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  60:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEx = 0.0;
  61:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEy = 0.0;
  62:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEz = 0.0;
  63:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  64:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  65:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // argUpdate
  66:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2717              		.loc 15 67 0
 2718              		.cfi_startproc
 2719              		@ args = 12, pretend = 0, frame = 0
 2720              		@ frame_needed = 0, uses_anonymous_args = 0
 2721              	.LVL131:
 2722 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2723              	.LCFI27:
 2724              		.cfi_def_cfa_offset 40
 2725              		.cfi_offset 14, -4
 2726              		.cfi_offset 11, -8
 2727              		.cfi_offset 10, -12
 2728              		.cfi_offset 9, -16
 2729              		.cfi_offset 8, -20
 2730              		.cfi_offset 7, -24
 2731              		.cfi_offset 6, -28
 2732              		.cfi_offset 5, -32
 2733              		.cfi_offset 4, -36
 2734              		.cfi_offset 3, -40
 2735 0004 2DED068B 		fstmfdd	sp!, {d8, d9, d10}
 2736              	.LCFI28:
 2737              		.cfi_def_cfa_offset 64
 2738              		.cfi_offset 84, -48
 2739              		.cfi_offset 82, -56
 2740              		.cfi_offset 80, -64
 2741              		.loc 15 67 0
 2742 0008 DDED108A 		flds	s17, [sp, #64]
 2743 000c 08EE103A 		fmsr	s16, r3
 2744              	.LBB74:
  68:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  69:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float norm;
  70:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float vx, vy, vz;
  71:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float q0i, q1i, q2i, q3i;
  72:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float ex, ey, ez;
  73:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
  75:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  76:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise the measurements
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2745              		.loc 15 77 0
 2746 0010 68EEA82A 		fmuls	s5, s17, s17
 2747 0014 48EE082A 		fmacs	s5, s16, s16
 2748              	.LBE74:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2749              		.loc 15 67 0
 2750 0018 9DED119A 		flds	s18, [sp, #68]
 2751              	.LBB75:
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2752              		.loc 15 74 0
 2753 001c DDED127A 		flds	s15, [sp, #72]
 2754              		.loc 15 77 0
 2755 0020 49EE092A 		fmacs	s5, s18, s18
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2756              		.loc 15 74 0
 2757 0024 B6EE003A 		fconsts	s6, #96
 2758 0028 27EE833A 		fmuls	s6, s15, s6
 2759 002c DFF83092 		ldr	r9, .L169+20
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
  81:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****      	
  82:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // estimated direction of gravity and flux (v and w)
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2760              		.loc 15 83 0
 2761 0030 864C     		ldr	r4, .L169
 2762 0032 874F     		ldr	r7, .L169+4
 2763 0034 874D     		ldr	r5, .L169+8
 2764 0036 884E     		ldr	r6, .L169+12
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
  86:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  87:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // error is sum of cross product between reference direction of fields and direction measured by 
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
  91:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  92:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integral error scaled integral gain
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2765              		.loc 15 93 0
 2766 0038 DFF828A2 		ldr	sl, .L169+24
 2767 003c DFF828B2 		ldr	fp, .L169+28
  94:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEx,ex)) {
 2768              		.loc 15 94 0
 2769 0040 DFF82882 		ldr	r8, .L169+32
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2770              		.loc 15 74 0
 2771 0044 89ED003A 		fsts	s6, [r9, #0]
 2772              	.LBE75:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2773              		.loc 15 67 0
 2774 0048 09EE900A 		fmsr	s19, r0
 2775              	.LBB76:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2776              		.loc 15 77 0
 2777 004c 12EE900A 		fmrs	r0, s5
 2778              	.LVL132:
 2779              	.LBE76:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2780              		.loc 15 67 0
 2781 0050 0AEE902A 		fmsr	s21, r2
 2782 0054 0AEE101A 		fmsr	s20, r1
 2783              	.LBB77:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2784              		.loc 15 77 0
 2785 0058 FFF7FEFF 		bl	__aeabi_f2d
 2786              	.LVL133:
 2787 005c FFF7FEFF 		bl	sqrt
 2788 0060 FFF7FEFF 		bl	__aeabi_d2f
 2789 0064 02EE100A 		fmsr	s4, r0
 2790              	.LVL134:
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
 2791              		.loc 15 79 0
 2792 0068 88EE825A 		fdivs	s10, s17, s4
 2793              		.loc 15 94 0
 2794 006c D8F80000 		ldr	r0, [r8, #0]	@ float
 2795              	.LVL135:
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
 2796              		.loc 15 80 0
 2797 0070 C9EE023A 		fdivs	s7, s18, s4
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2798              		.loc 15 83 0
 2799 0074 D4ED000A 		flds	s1, [r4, #0]
 2800 0078 97ED006A 		flds	s12, [r7, #0]
 2801 007c D5ED006A 		flds	s13, [r5, #0]
 2802 0080 96ED000A 		flds	s0, [r6, #0]
 2803 0084 66EE261A 		fmuls	s3, s12, s13
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2804              		.loc 15 84 0
 2805 0088 26EEA01A 		fmuls	s2, s13, s1
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2806              		.loc 15 83 0
 2807 008c 50EE201A 		fmscs	s3, s0, s1
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2808              		.loc 15 84 0
 2809 0090 06EE001A 		fmacs	s2, s12, s0
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2810              		.loc 15 85 0
 2811 0094 20EE000A 		fmuls	s0, s0, s0
 2812 0098 16EE060A 		fmscs	s0, s12, s12
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
 2813              		.loc 15 78 0
 2814 009c 88EE024A 		fdivs	s8, s16, s4
 2815              	.LVL136:
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2816              		.loc 15 85 0
 2817 00a0 06EEE60A 		fnmacs	s0, s13, s13
 2818 00a4 00EEA00A 		fmacs	s0, s1, s1
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2819              		.loc 15 84 0
 2820 00a8 71EE015A 		fadds	s11, s2, s2
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
 2821              		.loc 15 88 0
 2822 00ac 20EE058A 		fmuls	s16, s0, s10
 2823 00b0 15EEA38A 		fmscs	s16, s11, s7
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2824              		.loc 15 93 0
 2825 00b4 DAED007A 		flds	s15, [sl, #0]
 2826 00b8 9BED007A 		flds	s14, [fp, #0]
 2827 00bc 48EE077A 		fmacs	s15, s16, s14
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2828              		.loc 15 83 0
 2829 00c0 71EEA14A 		fadds	s9, s3, s3
 2830              	.LVL137:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 2831              		.loc 15 90 0
 2832 00c4 25EE849A 		fmuls	s18, s11, s8
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 2833              		.loc 15 89 0
 2834 00c8 64EEA38A 		fmuls	s17, s9, s7
 2835              		.loc 15 94 0
 2836 00cc 18EE101A 		fmrs	r1, s16
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 2837              		.loc 15 89 0
 2838 00d0 50EE048A 		fmscs	s17, s0, s8
 2839              	.LVL138:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 2840              		.loc 15 90 0
 2841 00d4 14EE859A 		fmscs	s18, s9, s10
 2842              	.LVL139:
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2843              		.loc 15 93 0
 2844 00d8 CAED007A 		fsts	s15, [sl, #0]
 2845              		.loc 15 94 0
 2846 00dc FFF7FEFF 		bl	_Z10isSwitchedff
 2847              	.LVL140:
 2848 00e0 4346     		mov	r3, r8
 2849 00e2 10B1     		cbz	r0, .L166
  95:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     exInt = 0.0;
 2850              		.loc 15 95 0
 2851 00e4 0022     		movs	r2, #0
 2852 00e6 CAF80020 		str	r2, [sl, #0]	@ float
 2853              	.L166:
  96:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
  98:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 2854              		.loc 15 99 0
 2855 00ea DFF88491 		ldr	r9, .L169+36
 100:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEy,ey)) {
 2856              		.loc 15 100 0
 2857 00ee DFF88481 		ldr	r8, .L169+40
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 2858              		.loc 15 99 0
 2859 00f2 D9ED004A 		flds	s9, [r9, #0]
 2860 00f6 9BED007A 		flds	s14, [fp, #0]
 2861 00fa 48EE874A 		fmacs	s9, s17, s14
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
 2862              		.loc 15 97 0
 2863 00fe 83ED008A 		fsts	s16, [r3, #0]
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 2864              		.loc 15 99 0
 2865 0102 C9ED004A 		fsts	s9, [r9, #0]
 2866              		.loc 15 100 0
 2867 0106 D8F80000 		ldr	r0, [r8, #0]	@ float
 2868 010a 18EE901A 		fmrs	r1, s17
 2869 010e FFF7FEFF 		bl	_Z10isSwitchedff
 2870 0112 4346     		mov	r3, r8
 2871 0114 10B1     		cbz	r0, .L167
 101:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     eyInt = 0.0;
 2872              		.loc 15 101 0
 2873 0116 0020     		movs	r0, #0
 2874 0118 C9F80000 		str	r0, [r9, #0]	@ float
 2875              	.L167:
 102:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 104:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 2876              		.loc 15 105 0
 2877 011c DFF85881 		ldr	r8, .L169+44
 2878 0120 9BED004A 		flds	s8, [fp, #0]
 2879 0124 98ED005A 		flds	s10, [r8, #0]
 2880 0128 09EE045A 		fmacs	s10, s18, s8
 106:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEz,ez)) {
 2881              		.loc 15 106 0
 2882 012c DFF84CB1 		ldr	fp, .L169+48
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 2883              		.loc 15 103 0
 2884 0130 C3ED008A 		fsts	s17, [r3, #0]
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 2885              		.loc 15 105 0
 2886 0134 88ED005A 		fsts	s10, [r8, #0]
 2887              		.loc 15 106 0
 2888 0138 DBF80000 		ldr	r0, [fp, #0]	@ float
 2889 013c 19EE101A 		fmrs	r1, s18
 2890 0140 FFF7FEFF 		bl	_Z10isSwitchedff
 2891 0144 4346     		mov	r3, r8
 2892 0146 5A46     		mov	r2, fp
 2893 0148 08B1     		cbz	r0, .L168
 107:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     ezInt = 0.0;
 2894              		.loc 15 107 0
 2895 014a 0021     		movs	r1, #0
 2896 014c 1960     		str	r1, [r3, #0]	@ float
 2897              	.L168:
 108:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 109:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = ez;
 2898              		.loc 15 109 0
 2899 014e 82ED009A 		fsts	s18, [r2, #0]
 110:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 111:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // adjusted gyroscope measurements
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2900              		.loc 15 112 0
 2901 0152 424A     		ldr	r2, .L169+16
 2902 0154 D2ED000A 		flds	s1, [r2, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 114:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gz = gz + Kp*ez + ezInt;
 2903              		.loc 15 114 0
 2904 0158 40EE89AA 		fmacs	s21, s1, s18
 2905              	.LVL141:
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2906              		.loc 15 112 0
 2907 015c 40EE889A 		fmacs	s19, s1, s16
 2908              	.LVL142:
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2909              		.loc 15 113 0
 2910 0160 00EEA8AA 		fmacs	s20, s1, s17
 2911              	.LVL143:
 2912              		.loc 15 114 0
 2913 0164 D3ED003A 		flds	s7, [r3, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2914              		.loc 15 113 0
 2915 0168 D9ED006A 		flds	s13, [r9, #0]
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2916              		.loc 15 112 0
 2917 016c 9AED006A 		flds	s12, [sl, #0]
 2918              		.loc 15 114 0
 2919 0170 7AEEA3AA 		fadds	s21, s21, s7
 115:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 116:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integrate quaternion rate and normalise
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2920              		.loc 15 117 0
 2921 0174 D5ED004A 		flds	s9, [r5, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2922              		.loc 15 113 0
 2923 0178 3AEE26AA 		fadds	s20, s20, s13
 118:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1i = ( q0*gx + q2*gz - q3*gy) * halfT;
 2924              		.loc 15 118 0
 2925 017c 97ED007A 		flds	s14, [r7, #0]
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2926              		.loc 15 112 0
 2927 0180 79EE869A 		fadds	s19, s19, s12
 2928              	.LVL144:
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2929              		.loc 15 117 0
 2930 0184 96ED005A 		flds	s10, [r6, #0]
 2931              		.loc 15 118 0
 2932 0188 64EEAA5A 		fmuls	s11, s9, s21
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2933              		.loc 15 117 0
 2934 018c 24EE8A0A 		fmuls	s0, s9, s20
 2935              		.loc 15 118 0
 2936 0190 47EE295A 		fmacs	s11, s14, s19
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2937              		.loc 15 117 0
 2938 0194 94ED001A 		flds	s2, [r4, #0]
 2939 0198 15EE690A 		fnmscs	s0, s10, s19
 2940              		.loc 15 118 0
 2941 019c 41EE4A5A 		fnmacs	s11, s2, s20
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2942              		.loc 15 117 0
 2943 01a0 2F4B     		ldr	r3, .L169+20
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 2944              		.loc 15 119 0
 2945 01a2 25EE2A4A 		fmuls	s8, s10, s21
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2946              		.loc 15 117 0
 2947 01a6 01EE6A0A 		fnmacs	s0, s2, s21
 2948              		.loc 15 119 0
 2949 01aa 17EE0A4A 		fmscs	s8, s14, s20
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2950              		.loc 15 117 0
 2951 01ae 93ED003A 		flds	s6, [r3, #0]
 2952              	.LVL145:
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 2953              		.loc 15 122 0
 2954 01b2 F0EE452A 		fcpys	s5, s10
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2955              		.loc 15 120 0
 2956 01b6 65EE0A7A 		fmuls	s15, s10, s20
 2957              		.loc 15 122 0
 2958 01ba 45EE832A 		fmacs	s5, s11, s6
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 2959              		.loc 15 119 0
 2960 01be 01EE294A 		fmacs	s8, s2, s19
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 2961              		.loc 15 121 0
 2962 01c2 B0EE472A 		fcpys	s4, s14
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2963              		.loc 15 120 0
 2964 01c6 47EE2A7A 		fmacs	s15, s14, s21
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 2965              		.loc 15 121 0
 2966 01ca 00EE032A 		fmacs	s4, s0, s6
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 2967              		.loc 15 123 0
 2968 01ce F0EE641A 		fcpys	s3, s9
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2969              		.loc 15 120 0
 2970 01d2 44EEE97A 		fnmacs	s15, s9, s19
 2971              		.loc 15 123 0
 2972 01d6 44EE031A 		fmacs	s3, s8, s6
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 125:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 126:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise quaternion
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 2973              		.loc 15 127 0
 2974 01da 22EEA26A 		fmuls	s12, s5, s5
 2975 01de 02EE026A 		fmacs	s12, s4, s4
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 2976              		.loc 15 124 0
 2977 01e2 07EE831A 		fmacs	s2, s15, s6
 2978              		.loc 15 127 0
 2979 01e6 01EEA16A 		fmacs	s12, s3, s3
 2980 01ea 01EE016A 		fmacs	s12, s2, s2
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 2981              		.loc 15 121 0
 2982 01ee 87ED002A 		fsts	s4, [r7, #0]
 2983              		.loc 15 127 0
 2984 01f2 16EE100A 		fmrs	r0, s12
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 2985              		.loc 15 122 0
 2986 01f6 C6ED002A 		fsts	s5, [r6, #0]
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 2987              		.loc 15 123 0
 2988 01fa C5ED001A 		fsts	s3, [r5, #0]
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 2989              		.loc 15 124 0
 2990 01fe 84ED001A 		fsts	s2, [r4, #0]
 2991              		.loc 15 127 0
 2992 0202 FFF7FEFF 		bl	__aeabi_f2d
 2993              	.LVL146:
 2994 0206 FFF7FEFF 		bl	sqrt
 2995 020a FFF7FEFF 		bl	__aeabi_d2f
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 2996              		.loc 15 128 0
 2997 020e D7ED006A 		flds	s13, [r7, #0]
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 2998              		.loc 15 127 0
 2999 0212 05EE900A 		fmsr	s11, r0
 3000              	.LVL147:
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3001              		.loc 15 129 0
 3002 0216 D6ED000A 		flds	s1, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3003              		.loc 15 130 0
 3004 021a D5ED003A 		flds	s7, [r5, #0]
 131:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = q3 / norm;
 3005              		.loc 15 131 0
 3006 021e 94ED000A 		flds	s0, [r4, #0]
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 3007              		.loc 15 128 0
 3008 0222 C6EEA56A 		fdivs	s13, s13, s11
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3009              		.loc 15 129 0
 3010 0226 C0EEA50A 		fdivs	s1, s1, s11
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3011              		.loc 15 130 0
 3012 022a C3EEA53A 		fdivs	s7, s7, s11
 3013              		.loc 15 131 0
 3014 022e C0EE255A 		fdivs	s11, s0, s11
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 3015              		.loc 15 128 0
 3016 0232 C7ED006A 		fsts	s13, [r7, #0]
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3017              		.loc 15 129 0
 3018 0236 C6ED000A 		fsts	s1, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3019              		.loc 15 130 0
 3020 023a C5ED003A 		fsts	s7, [r5, #0]
 3021              		.loc 15 131 0
 3022 023e C4ED005A 		fsts	s11, [r4, #0]
 3023              	.LBE77:
 132:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3024              		.loc 15 132 0
 3025 0242 BDEC068B 		fldmfdd	sp!, {d8, d9, d10}
 3026 0246 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3027              	.L170:
 3028 024a 00BF     		.align	2
 3029              	.L169:
 3030 024c 00000000 		.word	.LANCHOR37
 3031 0250 00000000 		.word	.LANCHOR38
 3032 0254 00000000 		.word	.LANCHOR39
 3033 0258 00000000 		.word	.LANCHOR36
 3034 025c 00000000 		.word	.LANCHOR47
 3035 0260 00000000 		.word	.LANCHOR35
 3036 0264 00000000 		.word	.LANCHOR40
 3037 0268 00000000 		.word	.LANCHOR41
 3038 026c 00000000 		.word	.LANCHOR42
 3039 0270 00000000 		.word	.LANCHOR43
 3040 0274 00000000 		.word	.LANCHOR44
 3041 0278 00000000 		.word	.LANCHOR45
 3042 027c 00000000 		.word	.LANCHOR46
 3043              		.cfi_endproc
 3044              	.LFE165:
 3046              		.section	.text._Z11eulerAnglesv,"ax",%progbits
 3047              		.align	1
 3048              		.global	_Z11eulerAnglesv
 3049              		.thumb
 3050              		.thumb_func
 3052              	_Z11eulerAnglesv:
 3053              	.LFB166:
 133:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 134:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void eulerAngles()
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3054              		.loc 15 135 0
 3055              		.cfi_startproc
 3056              		@ args = 0, pretend = 0, frame = 0
 3057              		@ frame_needed = 0, uses_anonymous_args = 0
 3058 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 3059              	.LCFI29:
 3060              		.cfi_def_cfa_offset 32
 3061              		.cfi_offset 14, -4
 3062              		.cfi_offset 9, -8
 3063              		.cfi_offset 8, -12
 3064              		.cfi_offset 7, -16
 3065              		.cfi_offset 6, -20
 3066              		.cfi_offset 5, -24
 3067              		.cfi_offset 4, -28
 3068              		.cfi_offset 3, -32
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3069              		.loc 15 136 0
 3070 0004 3C4C     		ldr	r4, .L172
 3071 0006 3D4E     		ldr	r6, .L172+4
 3072 0008 3D4D     		ldr	r5, .L172+8
 3073 000a 3E4F     		ldr	r7, .L172+12
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3074              		.loc 15 135 0
 3075 000c 2DED048B 		fstmfdd	sp!, {d8, d9}
 3076              	.LCFI30:
 3077              		.cfi_def_cfa_offset 48
 3078              		.cfi_offset 82, -40
 3079              		.cfi_offset 80, -48
 3080              		.loc 15 136 0
 3081 0010 D4ED005A 		flds	s11, [r4, #0]
 3082 0014 96ED008A 		flds	s16, [r6, #0]
 3083 0018 D5ED007A 		flds	s15, [r5, #0]
 3084 001c D7ED008A 		flds	s17, [r7, #0]
 3085 0020 68EE255A 		fmuls	s11, s16, s11
 3086 0024 48EEA75A 		fmacs	s11, s17, s15
 3087 0028 B7EE009A 		fconsts	s18, #112
 3088 002c 35EEA55A 		fadds	s10, s11, s11
 3089 0030 15EE100A 		fmrs	r0, s10
 3090 0034 FFF7FEFF 		bl	__aeabi_f2d
 3091 0038 68EE084A 		fmuls	s9, s16, s16
 3092 003c 48EEA84A 		fmacs	s9, s17, s17
 3093 0040 8046     		mov	r8, r0
 3094 0042 34EEA44A 		fadds	s8, s9, s9
 3095 0046 8946     		mov	r9, r1
 3096 0048 79EE443A 		fsubs	s7, s18, s8
 3097 004c 13EE900A 		fmrs	r0, s7
 3098 0050 FFF7FEFF 		bl	__aeabi_f2d
 3099 0054 0246     		mov	r2, r0
 3100 0056 0B46     		mov	r3, r1
 3101 0058 4046     		mov	r0, r8
 3102 005a 4946     		mov	r1, r9
 3103 005c FFF7FEFF 		bl	atan2
 3104 0060 FFF7FEFF 		bl	__aeabi_d2f
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3105              		.loc 15 137 0
 3106 0064 97ED006A 		flds	s12, [r7, #0]
 3107 0068 D4ED002A 		flds	s5, [r4, #0]
 3108 006c D5ED006A 		flds	s13, [r5, #0]
 3109 0070 96ED003A 		flds	s6, [r6, #0]
 3110 0074 66EE222A 		fmuls	s5, s12, s5
 3111 0078 56EE832A 		fmscs	s5, s13, s6
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3112              		.loc 15 136 0
 3113 007c DFF88880 		ldr	r8, .L172+16
 3114              		.loc 15 137 0
 3115 0080 32EEA22A 		fadds	s4, s5, s5
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3116              		.loc 15 136 0
 3117 0084 C8F80000 		str	r0, [r8, #0]	@ float
 3118              		.loc 15 137 0
 3119 0088 12EE100A 		fmrs	r0, s4
 3120 008c FFF7FEFF 		bl	__aeabi_f2d
 3121 0090 FFF7FEFF 		bl	asin
 3122 0094 FFF7FEFF 		bl	__aeabi_d2f
 138:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[ZAXIS]   = atan2(2 * (q0*q3 + q1*q2), 1 - 2 *(q2*q2 + q3*q3));
 3123              		.loc 15 138 0
 3124 0098 D6ED008A 		flds	s17, [r6, #0]
 3125 009c D7ED001A 		flds	s3, [r7, #0]
 3126 00a0 95ED007A 		flds	s14, [r5, #0]
 3127 00a4 94ED008A 		flds	s16, [r4, #0]
 3128 00a8 68EEA11A 		fmuls	s3, s17, s3
 3129 00ac 48EE071A 		fmacs	s3, s16, s14
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3130              		.loc 15 137 0
 3131 00b0 C8F80400 		str	r0, [r8, #4]	@ float
 3132              		.loc 15 138 0
 3133 00b4 31EEA11A 		fadds	s2, s3, s3
 3134 00b8 11EE100A 		fmrs	r0, s2
 3135 00bc FFF7FEFF 		bl	__aeabi_f2d
 3136 00c0 68EE080A 		fmuls	s1, s16, s16
 3137 00c4 48EEA80A 		fmacs	s1, s17, s17
 3138 00c8 0446     		mov	r4, r0
 3139 00ca 30EEA00A 		fadds	s0, s1, s1
 3140 00ce 0D46     		mov	r5, r1
 3141 00d0 79EE407A 		fsubs	s15, s18, s0
 3142 00d4 17EE900A 		fmrs	r0, s15
 3143 00d8 FFF7FEFF 		bl	__aeabi_f2d
 3144 00dc 0246     		mov	r2, r0
 3145 00de 0B46     		mov	r3, r1
 3146 00e0 2046     		mov	r0, r4
 3147 00e2 2946     		mov	r1, r5
 3148 00e4 FFF7FEFF 		bl	atan2
 3149 00e8 FFF7FEFF 		bl	__aeabi_d2f
 3150 00ec C8F80800 		str	r0, [r8, #8]	@ float
 139:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3151              		.loc 15 139 0
 3152 00f0 BDEC048B 		fldmfdd	sp!, {d8, d9}
 3153 00f4 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 3154              	.L173:
 3155              		.align	2
 3156              	.L172:
 3157 00f8 00000000 		.word	.LANCHOR37
 3158 00fc 00000000 		.word	.LANCHOR39
 3159 0100 00000000 		.word	.LANCHOR38
 3160 0104 00000000 		.word	.LANCHOR36
 3161 0108 00000000 		.word	.LANCHOR33
 3162              		.cfi_endproc
 3163              	.LFE166:
 3165              		.section	.text._Z20initializeKinematicsv,"ax",%progbits
 3166              		.align	1
 3167              		.global	_Z20initializeKinematicsv
 3168              		.thumb
 3169              		.thumb_func
 3171              	_Z20initializeKinematicsv:
 3172              	.LFB167:
 140:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 141:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 142:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Initialize ARG
 143:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 144:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 145:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void initializeKinematics() 
 146:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3173              		.loc 15 146 0
 3174              		.cfi_startproc
 3175              		@ args = 0, pretend = 0, frame = 0
 3176              		@ frame_needed = 0, uses_anonymous_args = 0
 3177 0000 08B5     		push	{r3, lr}
 3178              	.LCFI31:
 3179              		.cfi_def_cfa_offset 8
 3180              		.cfi_offset 14, -4
 3181              		.cfi_offset 3, -8
 147:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   initializeBaseKinematicsParam();
 3182              		.loc 15 147 0
 3183 0002 FFF7FEFF 		bl	_Z29initializeBaseKinematicsParamv
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3184              		.loc 15 148 0
 3185 0006 0F4B     		ldr	r3, .L175
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3186              		.loc 15 149 0
 3187 0008 0F49     		ldr	r1, .L175+4
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3188              		.loc 15 150 0
 3189 000a 1048     		ldr	r0, .L175+8
 151:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = 0.0;
 3190              		.loc 15 151 0
 3191 000c 104A     		ldr	r2, .L175+12
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3192              		.loc 15 148 0
 3193 000e 4FF07E5C 		mov	ip, #1065353216
 3194 0012 C3F800C0 		str	ip, [r3, #0]	@ float
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3195              		.loc 15 149 0
 3196 0016 0023     		movs	r3, #0
 3197 0018 0B60     		str	r3, [r1, #0]	@ float
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3198              		.loc 15 150 0
 3199 001a 0360     		str	r3, [r0, #0]	@ float
 3200              		.loc 15 151 0
 3201 001c 1360     		str	r3, [r2, #0]	@ float
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3202              		.loc 15 152 0
 3203 001e 0D49     		ldr	r1, .L175+16
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3204              		.loc 15 153 0
 3205 0020 0D48     		ldr	r0, .L175+20
 154:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = 0.0;
 3206              		.loc 15 154 0
 3207 0022 0E4A     		ldr	r2, .L175+24
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3208              		.loc 15 152 0
 3209 0024 0B60     		str	r3, [r1, #0]	@ float
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3210              		.loc 15 153 0
 3211 0026 0360     		str	r3, [r0, #0]	@ float
 3212              		.loc 15 154 0
 3213 0028 1360     		str	r3, [r2, #0]	@ float
 155:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3214              		.loc 15 156 0
 3215 002a 0D49     		ldr	r1, .L175+28
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3216              		.loc 15 157 0
 3217 002c 0D48     		ldr	r0, .L175+32
 158:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = 0;
 3218              		.loc 15 158 0
 3219 002e 0E4A     		ldr	r2, .L175+36
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3220              		.loc 15 156 0
 3221 0030 0B60     		str	r3, [r1, #0]	@ float
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3222              		.loc 15 157 0
 3223 0032 0360     		str	r3, [r0, #0]	@ float
 3224              		.loc 15 158 0
 3225 0034 1360     		str	r3, [r2, #0]	@ float
 159:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3226              		.loc 15 160 0
 3227 0036 0D48     		ldr	r0, .L175+40
 3228 0038 0D49     		ldr	r1, .L175+44
 161:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Ki = 0.0005; //0.005;
 3229              		.loc 15 161 0
 3230 003a 0E4A     		ldr	r2, .L175+48
 3231 003c 0E4B     		ldr	r3, .L175+52
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3232              		.loc 15 160 0
 3233 003e 0860     		str	r0, [r1, #0]	@ float
 3234              		.loc 15 161 0
 3235 0040 1A60     		str	r2, [r3, #0]	@ float
 162:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3236              		.loc 15 162 0
 3237 0042 08BD     		pop	{r3, pc}
 3238              	.L176:
 3239              		.align	2
 3240              	.L175:
 3241 0044 00000000 		.word	.LANCHOR38
 3242 0048 00000000 		.word	.LANCHOR36
 3243 004c 00000000 		.word	.LANCHOR39
 3244 0050 00000000 		.word	.LANCHOR37
 3245 0054 00000000 		.word	.LANCHOR40
 3246 0058 00000000 		.word	.LANCHOR43
 3247 005c 00000000 		.word	.LANCHOR45
 3248 0060 00000000 		.word	.LANCHOR42
 3249 0064 00000000 		.word	.LANCHOR44
 3250 0068 00000000 		.word	.LANCHOR46
 3251 006c CDCC4C3E 		.word	1045220557
 3252 0070 00000000 		.word	.LANCHOR47
 3253 0074 6F12033A 		.word	973279855
 3254 0078 00000000 		.word	.LANCHOR41
 3255              		.cfi_endproc
 3256              	.LFE167:
 3258              		.section	.text._Z19calculateKinematicsfffffff,"ax",%progbits
 3259              		.align	1
 3260              		.global	_Z19calculateKinematicsfffffff
 3261              		.thumb
 3262              		.thumb_func
 3264              	_Z19calculateKinematicsfffffff:
 3265              	.LFB168:
 163:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 164:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 165:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Calculate ARG
 166:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 167:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calculateKinematics(float rollRate,          float pitchRate,    float yawRate,  
 168:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float longitudinalAccel, float lateralAccel, float verticalAccel, 
 169:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float G_DT) {
 3266              		.loc 15 169 0
 3267              		.cfi_startproc
 3268              		@ args = 12, pretend = 0, frame = 0
 3269              		@ frame_needed = 0, uses_anonymous_args = 0
 3270              	.LVL148:
 3271 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 3272              	.LCFI32:
 3273              		.cfi_def_cfa_offset 24
 3274              		.cfi_offset 14, -4
 3275              		.cfi_offset 4, -8
 3276              		.cfi_offset 3, -12
 3277              		.cfi_offset 2, -16
 3278              		.cfi_offset 1, -20
 3279              		.cfi_offset 0, -24
 170:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 171:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   argUpdate(rollRate,          pitchRate,    yawRate, 
 172:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****             longitudinalAccel, lateralAccel, verticalAccel,  
 173:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 		    G_Dt);
 3280              		.loc 15 173 0
 3281 0002 DDF818E0 		ldr	lr, [sp, #24]	@ float
 3282 0006 DDF81CC0 		ldr	ip, [sp, #28]	@ float
 3283 000a 074C     		ldr	r4, .L178
 3284 000c CDF800E0 		str	lr, [sp, #0]	@ float
 3285 0010 CDF804C0 		str	ip, [sp, #4]	@ float
 3286 0014 2468     		ldr	r4, [r4, #0]	@ float
 3287 0016 0294     		str	r4, [sp, #8]	@ float
 3288 0018 FFF7FEFF 		bl	_Z9argUpdatefffffff
 3289              	.LVL149:
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 175:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3290              		.loc 15 175 0
 3291 001c 04B0     		add	sp, sp, #16
 3292 001e BDE81040 		pop	{r4, lr}
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 3293              		.loc 15 174 0
 3294 0022 FFF7FEBF 		b	_Z11eulerAnglesv
 3295              	.L179:
 3296 0026 00BF     		.align	2
 3297              	.L178:
 3298 0028 00000000 		.word	.LANCHOR48
 3299              		.cfi_endproc
 3300              	.LFE168:
 3302              		.section	.text._Z13getGyroUnbiash,"ax",%progbits
 3303              		.align	1
 3304              		.global	_Z13getGyroUnbiash
 3305              		.thumb
 3306              		.thumb_func
 3308              	_Z13getGyroUnbiash:
 3309              	.LFB169:
 176:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 177:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float getGyroUnbias(byte axis) {
 3310              		.loc 15 177 0
 3311              		.cfi_startproc
 3312              		@ args = 0, pretend = 0, frame = 0
 3313              		@ frame_needed = 0, uses_anonymous_args = 0
 3314              		@ link register save eliminated.
 3315              	.LVL150:
 178:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   return correctedRateVector[axis];
 3316              		.loc 15 178 0
 3317 0000 0249     		ldr	r1, .L181
 3318 0002 01EB8003 		add	r3, r1, r0, lsl #2
 179:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3319              		.loc 15 179 0
 3320 0006 1868     		ldr	r0, [r3, #0]	@ float
 3321              	.LVL151:
 3322 0008 7047     		bx	lr
 3323              	.L182:
 3324 000a 00BF     		.align	2
 3325              	.L181:
 3326 000c 00000000 		.word	.LANCHOR49
 3327              		.cfi_endproc
 3328              	.LFE169:
 3330              		.section	.text._Z19calibrateKinematicsv,"ax",%progbits
 3331              		.align	1
 3332              		.global	_Z19calibrateKinematicsv
 3333              		.thumb
 3334              		.thumb_func
 3336              	_Z19calibrateKinematicsv:
 3337              	.LFB170:
 180:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 181:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calibrateKinematics() {}
 3338              		.loc 15 181 0
 3339              		.cfi_startproc
 3340              		@ args = 0, pretend = 0, frame = 0
 3341              		@ frame_needed = 0, uses_anonymous_args = 0
 3342              		@ link register save eliminated.
 3343              		.loc 15 181 0
 3344 0000 7047     		bx	lr
 3345              		.cfi_endproc
 3346              	.LFE170:
 3348              		.section	.text._Z7FrqInitiiPV8tFrqDataP9timer_devi,"ax",%progbits
 3349              		.align	1
 3350              		.global	_Z7FrqInitiiPV8tFrqDataP9timer_devi
 3351              		.thumb
 3352              		.thumb_func
 3354              	_Z7FrqInitiiPV8tFrqDataP9timer_devi:
 3355              	.LFB171:
 3356              		.file 16 "../Libraries/AQ_Receiver/Receiver_STM32.h"
   1:../Libraries/AQ_Receiver/Receiver_STM32.h **** /*
   2:../Libraries/AQ_Receiver/Receiver_STM32.h ****   Copyright (c) 2011 ala42.  All rights reserved.
   3:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
   4:../Libraries/AQ_Receiver/Receiver_STM32.h ****   STM32 receiver class by ala42 using time input capture
   5:../Libraries/AQ_Receiver/Receiver_STM32.h ****   for use with AeroQuad software and Maple library
   6:../Libraries/AQ_Receiver/Receiver_STM32.h ****   V 1.0 Oct 15 2011
   7:../Libraries/AQ_Receiver/Receiver_STM32.h ****   V 1.1 Jan 22 2012	class free version for AeroQuad 3.0 compatibility
   8:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
   9:../Libraries/AQ_Receiver/Receiver_STM32.h ****   Define the pin numbers used for the receiver in receiverPin[]
  10:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  11:../Libraries/AQ_Receiver/Receiver_STM32.h ****   Timer and timer channels are accessed using the Maple PIN_MAP array.
  12:../Libraries/AQ_Receiver/Receiver_STM32.h ****   Make sure libmaple and this receiver class are compiled using the
  13:../Libraries/AQ_Receiver/Receiver_STM32.h ****   same structure alignment mode. When in doubt, change the stm32_pin_info
  14:../Libraries/AQ_Receiver/Receiver_STM32.h ****   declaration in wirish_types.h to align the size to a multiple of 4 byte
  15:../Libraries/AQ_Receiver/Receiver_STM32.h ****   by adding a filler byte at the end of the structure declaration.
  16:../Libraries/AQ_Receiver/Receiver_STM32.h **** */
  17:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  18:../Libraries/AQ_Receiver/Receiver_STM32.h **** #ifndef _AEROQUAD_RECEIVER_STM32_H_
  19:../Libraries/AQ_Receiver/Receiver_STM32.h **** #define _AEROQUAD_RECEIVER_STM32_H_
  20:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  21:../Libraries/AQ_Receiver/Receiver_STM32.h **** #if defined(AeroQuadSTM32)
  22:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  23:../Libraries/AQ_Receiver/Receiver_STM32.h **** #include "Receiver.h"
  24:../Libraries/AQ_Receiver/Receiver_STM32.h **** #include "wirish.h"
  25:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  26:../Libraries/AQ_Receiver/Receiver_STM32.h **** //#define STM32_TIMER_DEBUG // enable debug messages
  27:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  28:../Libraries/AQ_Receiver/Receiver_STM32.h **** ///////////////////////////////////////////////////////////////////////////////
  29:../Libraries/AQ_Receiver/Receiver_STM32.h **** // configuration part starts here
  30:../Libraries/AQ_Receiver/Receiver_STM32.h **** // definition of pins used for PWM receiver input
  31:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  32:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  33:../Libraries/AQ_Receiver/Receiver_STM32.h **** /*
  34:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	ROLL     0	3
  35:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	PITCH    1	1
  36:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	YAW      2	0
  37:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	THROTTLE 3	2
  38:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	MODE     4	4
  39:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	AUX      5	6
  40:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	AUX2     6	5
  41:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	AUX3     7	7
  42:../Libraries/AQ_Receiver/Receiver_STM32.h **** */
  43:../Libraries/AQ_Receiver/Receiver_STM32.h **** static byte ReceiverChannelMap[] = {0, 1, 2, 3, 4, 5, 6, 7}; // default mapping
  44:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  45:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  46:../Libraries/AQ_Receiver/Receiver_STM32.h **** ///////////////////////////////////////////////////////////////////////////////
  47:../Libraries/AQ_Receiver/Receiver_STM32.h **** // implementation part starts here.
  48:../Libraries/AQ_Receiver/Receiver_STM32.h **** // forward declaration, array is defined at the end of this file
  49:../Libraries/AQ_Receiver/Receiver_STM32.h **** extern voidFuncPtr PWM_in_handler[];
  50:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  51:../Libraries/AQ_Receiver/Receiver_STM32.h **** typedef struct {
  52:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer_dev   *TimerDev;
  53:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer_gen_reg_map *TimerRegs;
  54:../Libraries/AQ_Receiver/Receiver_STM32.h ****   __io uint32	*Timer_ccr;
  55:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			Low;
  56:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			High;
  57:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint16		HighTime;
  58:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint16		RiseTime;
  59:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint16		LastChange;
  60:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			Channel;
  61:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			TimerChannel;
  62:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			PolarityMask;
  63:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			Valid;
  64:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			Debug;
  65:../Libraries/AQ_Receiver/Receiver_STM32.h **** } tFrqData;
  66:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  67:../Libraries/AQ_Receiver/Receiver_STM32.h **** #define FRQInputs 8
  68:../Libraries/AQ_Receiver/Receiver_STM32.h **** volatile tFrqData FrqData[FRQInputs];
  69:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  70:../Libraries/AQ_Receiver/Receiver_STM32.h **** void FrqInit(int aChannel, int aDefault, volatile tFrqData *f, timer_dev *aTimer, int aTimerChannel
 3357              		.loc 16 70 0
 3358              		.cfi_startproc
 3359              		@ args = 4, pretend = 0, frame = 0
 3360              		@ frame_needed = 0, uses_anonymous_args = 0
 3361              	.LVL152:
 3362 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3363              	.LCFI33:
 3364              		.cfi_def_cfa_offset 24
 3365              		.cfi_offset 14, -4
 3366              		.cfi_offset 8, -8
 3367              		.cfi_offset 7, -12
 3368              		.cfi_offset 6, -16
 3369              		.cfi_offset 5, -20
 3370              		.cfi_offset 4, -24
 3371              	.LBB78:
  71:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  72:../Libraries/AQ_Receiver/Receiver_STM32.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
 3372              		.loc 16 72 0
 3373 0004 069D     		ldr	r5, [sp, #24]
  73:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  74:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->Channel      = aChannel;
 3374              		.loc 16 74 0
 3375 0006 D061     		str	r0, [r2, #28]
  75:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->Valid        = false;
 3376              		.loc 16 75 0
 3377 0008 0027     		movs	r7, #0
 3378 000a 9762     		str	r7, [r2, #40]
  76:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  77:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerDev     = aTimer;
 3379              		.loc 16 77 0
 3380 000c 1360     		str	r3, [r2, #0]
  72:../Libraries/AQ_Receiver/Receiver_STM32.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
 3381              		.loc 16 72 0
 3382 000e 6E1E     		subs	r6, r5, #1
 3383              	.LVL153:
  78:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer_gen_reg_map *timer = aTimer->regs.gen;
 3384              		.loc 16 78 0
 3385 0010 1D68     		ldr	r5, [r3, #0]
 3386              	.LVL154:
  79:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerRegs    = timer;
  80:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  81:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3387              		.loc 16 81 0
 3388 0012 B300     		lsls	r3, r6, #2
 3389              	.LVL155:
 3390 0014 05F13408 		add	r8, r5, #52
 3391 0018 08EB0300 		add	r0, r8, r3
 3392              	.LVL156:
  79:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerRegs    = timer;
 3393              		.loc 16 79 0
 3394 001c 5560     		str	r5, [r2, #4]
 3395              	.LBE78:
  70:../Libraries/AQ_Receiver/Receiver_STM32.h **** void FrqInit(int aChannel, int aDefault, volatile tFrqData *f, timer_dev *aTimer, int aTimerChannel
 3396              		.loc 16 70 0
 3397 001e 1446     		mov	r4, r2
 3398              	.LBB79:
 3399              		.loc 16 81 0
 3400 0020 9060     		str	r0, [r2, #8]
  82:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->Debug        = false;
 3401              		.loc 16 82 0
 3402 0022 D762     		str	r7, [r2, #44]
  83:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->HighTime     = aDefault;
 3403              		.loc 16 83 0
 3404 0024 9182     		strh	r1, [r2, #20]	@ movhi
  84:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerChannel = aTimerChannel;
 3405              		.loc 16 84 0
 3406 0026 1662     		str	r6, [r2, #32]
  85:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  86:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int TimerEnable = (1 << (4*aTimerChannel));
 3407              		.loc 16 86 0
 3408 0028 4FF00102 		mov	r2, #1
 3409              	.LVL157:
 3410 002c 02FA03F8 		lsl	r8, r2, r3
 3411              	.LVL158:
  87:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->PolarityMask = TimerEnable << 1;
 3412              		.loc 16 87 0
 3413 0030 4FEA4800 		lsl	r0, r8, #1
 3414 0034 6062     		str	r0, [r4, #36]
  88:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  89:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint32 clock_speed = rcc_dev_timer_clk_speed(f->TimerDev->clk_id);
 3415              		.loc 16 89 0
 3416 0036 2168     		ldr	r1, [r4, #0]
 3417              	.LVL159:
 3418 0038 0879     		ldrb	r0, [r1, #4]	@ zero_extendqisi2
 3419 003a FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 3420              	.LVL160:
  90:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3421              		.loc 16 90 0
 3422 003e 1A4A     		ldr	r2, .L187
 3423 0040 B0FBF2F3 		udiv	r3, r0, r2
 3424 0044 581E     		subs	r0, r3, #1
 3425              	.LVL161:
  91:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->ARR	= 0xffff;
 3426              		.loc 16 91 0
 3427 0046 4FF6FF71 		movw	r1, #65535
  90:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3428              		.loc 16 90 0
 3429 004a A862     		str	r0, [r5, #40]
 3430              		.loc 16 91 0
 3431 004c E962     		str	r1, [r5, #44]
  92:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CR1	= 0;
 3432              		.loc 16 92 0
 3433 004e 2F60     		str	r7, [r5, #0]
  93:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->DIER &= ~(1);
 3434              		.loc 16 93 0
 3435 0050 EA68     		ldr	r2, [r5, #12]
 3436 0052 22F00103 		bic	r3, r2, #1
 3437 0056 EB60     		str	r3, [r5, #12]
  94:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  95:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER &= ~TimerEnable; // Disable timer
 3438              		.loc 16 95 0
 3439 0058 286A     		ldr	r0, [r5, #32]
 3440 005a 20EA0801 		bic	r1, r0, r8
 3441 005e 2962     		str	r1, [r5, #32]
  96:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER &= ~(f->PolarityMask);
 3442              		.loc 16 96 0
 3443 0060 2B6A     		ldr	r3, [r5, #32]
 3444 0062 626A     		ldr	r2, [r4, #36]
  97:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  98:../Libraries/AQ_Receiver/Receiver_STM32.h ****   volatile uint32 *mr;
  99:../Libraries/AQ_Receiver/Receiver_STM32.h ****   if(aTimerChannel < 2) {
 3445              		.loc 16 99 0
 3446 0064 012E     		cmp	r6, #1
  96:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER &= ~(f->PolarityMask);
 3447              		.loc 16 96 0
 3448 0066 23EA0203 		bic	r3, r3, r2
 3449 006a 2B62     		str	r3, [r5, #32]
 100:../Libraries/AQ_Receiver/Receiver_STM32.h ****     mr = &(timer->CCMR1);
 3450              		.loc 16 100 0
 3451 006c D4BF     		ite	le
 3452 006e 05F11803 		addle	r3, r5, #24
 3453              	.LVL162:
 101:../Libraries/AQ_Receiver/Receiver_STM32.h ****   }
 102:../Libraries/AQ_Receiver/Receiver_STM32.h ****   else {
 103:../Libraries/AQ_Receiver/Receiver_STM32.h ****     mr = &(timer->CCMR2);
 3454              		.loc 16 103 0
 3455 0072 05F11C03 		addgt	r3, r5, #28
 3456              	.LVL163:
 104:../Libraries/AQ_Receiver/Receiver_STM32.h ****   }
 105:../Libraries/AQ_Receiver/Receiver_STM32.h ****   *mr &= ~(0xFF << (8*(aTimerChannel&1)));	// prescaler 1
 3457              		.loc 16 105 0
 3458 0076 06F00100 		and	r0, r6, #1
 3459 007a 1968     		ldr	r1, [r3, #0]
 3460 007c C000     		lsls	r0, r0, #3
 3461 007e FF26     		movs	r6, #255
 3462              	.LVL164:
 3463 0080 16FA00F2 		lsls	r2, r6, r0
 3464 0084 21EA0206 		bic	r6, r1, r2
 3465 0088 1E60     		str	r6, [r3, #0]
 106:../Libraries/AQ_Receiver/Receiver_STM32.h ****   *mr |= 0x61 << (8*(aTimerChannel&1));		// 0x61 -> 6=filter, 1=inputs 1,2,3,4
 3466              		.loc 16 106 0
 3467 008a 1A68     		ldr	r2, [r3, #0]
 3468 008c 6121     		movs	r1, #97
 3469 008e 11FA00F6 		lsls	r6, r1, r0
 3470 0092 1643     		orrs	r6, r6, r2
 3471 0094 1E60     		str	r6, [r3, #0]
 107:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 108:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER |= TimerEnable; // Enable
 3472              		.loc 16 108 0
 3473 0096 296A     		ldr	r1, [r5, #32]
 109:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CR1 = 1;
 3474              		.loc 16 109 0
 3475 0098 0123     		movs	r3, #1
 3476              	.LVL165:
 108:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER |= TimerEnable; // Enable
 3477              		.loc 16 108 0
 3478 009a 48EA0100 		orr	r0, r8, r1
 3479 009e 2862     		str	r0, [r5, #32]
 3480              		.loc 16 109 0
 3481 00a0 2B60     		str	r3, [r5, #0]
 3482              	.LBE79:
 110:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3483              		.loc 16 110 0
 3484 00a2 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3485              	.L188:
 3486 00a6 00BF     		.align	2
 3487              	.L187:
 3488 00a8 40420F00 		.word	1000000
 3489              		.cfi_endproc
 3490              	.LFE171:
 3492              		.section	.text._Z18InitFrqMeasurementv,"ax",%progbits
 3493              		.align	1
 3494              		.global	_Z18InitFrqMeasurementv
 3495              		.thumb
 3496              		.thumb_func
 3498              	_Z18InitFrqMeasurementv:
 3499              	.LFB172:
 111:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 112:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 113:../Libraries/AQ_Receiver/Receiver_STM32.h **** void InitFrqMeasurement() {
 3500              		.loc 16 113 0
 3501              		.cfi_startproc
 3502              		@ args = 0, pretend = 0, frame = 0
 3503              		@ frame_needed = 0, uses_anonymous_args = 0
 3504              	.LVL166:
 3505 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 3506              	.LCFI34:
 3507              		.cfi_def_cfa_offset 24
 3508              		.cfi_offset 14, -4
 3509              		.cfi_offset 6, -8
 3510              		.cfi_offset 5, -12
 3511              		.cfi_offset 4, -16
 3512              		.cfi_offset 1, -20
 3513              		.cfi_offset 0, -24
 114:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 115:../Libraries/AQ_Receiver/Receiver_STM32.h ****   for(int rcLine = 0; rcLine < (int)(sizeof(receiverPin) / sizeof(receiverPin[0])); rcLine++) {
 3514              		.loc 16 115 0
 3515 0002 0024     		movs	r4, #0
 3516              	.LVL167:
 3517              	.L191:
 3518              	.LBB80:
 3519              	.LBB81:
 116:../Libraries/AQ_Receiver/Receiver_STM32.h ****     int pin = receiverPin[rcLine];
 3520              		.loc 16 116 0
 3521 0004 1148     		ldr	r0, .L193
 117:../Libraries/AQ_Receiver/Receiver_STM32.h ****     timer_dev *timer_num = PIN_MAP[pin].timer_device;
 3522              		.loc 16 117 0
 3523 0006 124A     		ldr	r2, .L193+4
 116:../Libraries/AQ_Receiver/Receiver_STM32.h ****     int pin = receiverPin[rcLine];
 3524              		.loc 16 116 0
 3525 0008 235C     		ldrb	r3, [r4, r0]	@ zero_extendqisi2
 3526              	.LVL168:
 3527              		.loc 16 117 0
 3528 000a 1B01     		lsls	r3, r3, #4
 3529              	.LVL169:
 3530 000c D518     		adds	r5, r2, r3
 3531 000e 6E68     		ldr	r6, [r5, #4]
 3532              	.LVL170:
 118:../Libraries/AQ_Receiver/Receiver_STM32.h ****     if(timer_num != NULL) {
 3533              		.loc 16 118 0
 3534 0010 BEB1     		cbz	r6, .L190
 119:../Libraries/AQ_Receiver/Receiver_STM32.h ****       gpio_set_mode(PIN_MAP[pin].gpio_device, PIN_MAP[pin].gpio_bit, GPIO_AF_INPUT_PD);
 3535              		.loc 16 119 0
 3536 0012 D058     		ldr	r0, [r2, r3]
 3537 0014 297B     		ldrb	r1, [r5, #12]	@ zero_extendqisi2
 3538 0016 0A22     		movs	r2, #10
 3539 0018 FFF7FEFF 		bl	gpio_set_mode
 3540              	.LVL171:
 120:../Libraries/AQ_Receiver/Receiver_STM32.h ****       FrqInit(rcLine, 1500, &FrqData[rcLine], timer_num, PIN_MAP[pin].timer_channel);
 3541              		.loc 16 120 0
 3542 001c 697B     		ldrb	r1, [r5, #13]	@ zero_extendqisi2
 3543 001e 0D4B     		ldr	r3, .L193+8
 3544 0020 0091     		str	r1, [sp, #0]
 3545 0022 3022     		movs	r2, #48
 3546 0024 02FB0432 		mla	r2, r2, r4, r3
 3547 0028 2046     		mov	r0, r4
 3548 002a 40F2DC51 		movw	r1, #1500
 3549 002e 3346     		mov	r3, r6
 3550 0030 FFF7FEFF 		bl	_Z7FrqInitiiPV8tFrqDataP9timer_devi
 121:../Libraries/AQ_Receiver/Receiver_STM32.h ****       timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, PWM_in_handler[rcLine]);
 3551              		.loc 16 121 0
 3552 0034 084A     		ldr	r2, .L193+12
 3553 0036 697B     		ldrb	r1, [r5, #13]	@ zero_extendqisi2
 3554 0038 52F82420 		ldr	r2, [r2, r4, lsl #2]
 3555 003c 3046     		mov	r0, r6
 3556 003e FFF7FEFF 		bl	timer_attach_interrupt
 3557              	.L190:
 3558              	.LBE81:
 115:../Libraries/AQ_Receiver/Receiver_STM32.h ****   for(int rcLine = 0; rcLine < (int)(sizeof(receiverPin) / sizeof(receiverPin[0])); rcLine++) {
 3559              		.loc 16 115 0
 3560 0042 0134     		adds	r4, r4, #1
 3561              	.LVL172:
 3562 0044 082C     		cmp	r4, #8
 3563 0046 DDD1     		bne	.L191
 3564              	.LBE80:
 122:../Libraries/AQ_Receiver/Receiver_STM32.h ****     }
 123:../Libraries/AQ_Receiver/Receiver_STM32.h ****   }
 124:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3565              		.loc 16 124 0
 3566 0048 7CBD     		pop	{r2, r3, r4, r5, r6, pc}
 3567              	.L194:
 3568 004a 00BF     		.align	2
 3569              	.L193:
 3570 004c 00000000 		.word	.LANCHOR50
 3571 0050 00000000 		.word	PIN_MAP
 3572 0054 00000000 		.word	.LANCHOR51
 3573 0058 00000000 		.word	.LANCHOR52
 3574              		.cfi_endproc
 3575              	.LFE172:
 3577              		.section	.text._Z17PWMInvertPolarityPV8tFrqData,"ax",%progbits
 3578              		.align	1
 3579              		.global	_Z17PWMInvertPolarityPV8tFrqData
 3580              		.thumb
 3581              		.thumb_func
 3583              	_Z17PWMInvertPolarityPV8tFrqData:
 3584              	.LFB173:
 125:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 126:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 127:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWMInvertPolarity(volatile tFrqData *f) {
 3585              		.loc 16 127 0
 3586              		.cfi_startproc
 3587              		@ args = 0, pretend = 0, frame = 0
 3588              		@ frame_needed = 0, uses_anonymous_args = 0
 3589              		@ link register save eliminated.
 3590              	.LVL173:
 128:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerRegs->CCER ^= f->PolarityMask; // invert polarity
 3591              		.loc 16 128 0
 3592 0000 4368     		ldr	r3, [r0, #4]
 3593 0002 1A6A     		ldr	r2, [r3, #32]
 3594 0004 416A     		ldr	r1, [r0, #36]
 3595 0006 4A40     		eors	r2, r2, r1
 3596 0008 1A62     		str	r2, [r3, #32]
 129:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3597              		.loc 16 129 0
 3598 000a 7047     		bx	lr
 3599              		.cfi_endproc
 3600              	.LFE173:
 3602              		.section	.text._Z9FrqChangePV8tFrqData,"ax",%progbits
 3603              		.align	1
 3604              		.global	_Z9FrqChangePV8tFrqData
 3605              		.thumb
 3606              		.thumb_func
 3608              	_Z9FrqChangePV8tFrqData:
 3609              	.LFB174:
 130:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 131:../Libraries/AQ_Receiver/Receiver_STM32.h **** void FrqChange(volatile tFrqData *f) {
 3610              		.loc 16 131 0
 3611              		.cfi_startproc
 3612              		@ args = 0, pretend = 0, frame = 0
 3613              		@ frame_needed = 0, uses_anonymous_args = 0
 3614              	.LVL174:
 3615              	.LBB82:
 132:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 133:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer_gen_reg_map *timer = f->TimerRegs;
 3616              		.loc 16 133 0
 3617 0000 4168     		ldr	r1, [r0, #4]
 3618              	.LVL175:
 134:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint16_t c = *(f->Timer_ccr);
 3619              		.loc 16 134 0
 3620 0002 8368     		ldr	r3, [r0, #8]
 3621 0004 1B68     		ldr	r3, [r3, #0]
 3622              	.LVL176:
 135:../Libraries/AQ_Receiver/Receiver_STM32.h ****   bool rising = (timer->CCER & f->PolarityMask) == 0;
 3623              		.loc 16 135 0
 3624 0006 0A6A     		ldr	r2, [r1, #32]
 3625 0008 416A     		ldr	r1, [r0, #36]
 3626              	.LVL177:
 3627 000a 1142     		tst	r1, r2
 3628              	.LBB83:
 136:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 137:../Libraries/AQ_Receiver/Receiver_STM32.h ****   if(f->Valid) {
 3629              		.loc 16 137 0
 3630 000c 816A     		ldr	r1, [r0, #40]
 3631              	.LBE83:
 3632              	.LBE82:
 131:../Libraries/AQ_Receiver/Receiver_STM32.h **** void FrqChange(volatile tFrqData *f) {
 3633              		.loc 16 131 0
 3634 000e 10B5     		push	{r4, lr}
 3635              	.LCFI35:
 3636              		.cfi_def_cfa_offset 8
 3637              		.cfi_offset 14, -4
 3638              		.cfi_offset 4, -8
 3639              	.LBB87:
 135:../Libraries/AQ_Receiver/Receiver_STM32.h ****   bool rising = (timer->CCER & f->PolarityMask) == 0;
 3640              		.loc 16 135 0
 3641 0010 14BF     		ite	ne
 3642 0012 0022     		movne	r2, #0
 3643 0014 0122     		moveq	r2, #1
 3644              	.LVL178:
 3645              	.LBB86:
 3646              		.loc 16 137 0
 3647 0016 91B1     		cbz	r1, .L197
 3648              	.LVL179:
 3649              	.LBB84:
 138:../Libraries/AQ_Receiver/Receiver_STM32.h ****     if(rising) {
 3650              		.loc 16 138 0
 3651 0018 0AB1     		cbz	r2, .L198
 139:../Libraries/AQ_Receiver/Receiver_STM32.h ****       f->RiseTime = c;
 3652              		.loc 16 139 0
 3653 001a C382     		strh	r3, [r0, #22]	@ movhi
 3654 001c 13E0     		b	.L199
 3655              	.L198:
 3656              	.LBB85:
 140:../Libraries/AQ_Receiver/Receiver_STM32.h ****     } 
 141:../Libraries/AQ_Receiver/Receiver_STM32.h ****     else {
 142:../Libraries/AQ_Receiver/Receiver_STM32.h ****       uint16_t highTime = c - f->RiseTime;
 3657              		.loc 16 142 0
 3658 001e C48A     		ldrh	r4, [r0, #22]
 3659 0020 191B     		subs	r1, r3, r4
 3660 0022 1FFA81FC 		uxth	ip, r1
 3661              	.LVL180:
 143:../Libraries/AQ_Receiver/Receiver_STM32.h ****       if(highTime > 900 && highTime < 2100) {
 3662              		.loc 16 143 0
 3663 0026 ACF56073 		sub	r3, ip, #896
 3664              	.LVL181:
 3665 002a 5C1F     		subs	r4, r3, #5
 3666 002c A1B2     		uxth	r1, r4
 3667 002e 40F2AE44 		movw	r4, #1198
 3668 0032 A142     		cmp	r1, r4
 144:../Libraries/AQ_Receiver/Receiver_STM32.h ****         f->HighTime = highTime;
 3669              		.loc 16 144 0
 3670 0034 94BF     		ite	ls
 3671 0036 A0F814C0 		strhls	ip, [r0, #20]	@ movhi
 145:../Libraries/AQ_Receiver/Receiver_STM32.h ****       } 
 146:../Libraries/AQ_Receiver/Receiver_STM32.h ****       else {
 147:../Libraries/AQ_Receiver/Receiver_STM32.h ****         f->Valid = false;
 3672              		.loc 16 147 0
 3673 003a 8262     		strhi	r2, [r0, #40]
 3674 003c 03E0     		b	.L199
 3675              	.LVL182:
 3676              	.L197:
 3677              	.LBE85:
 3678              	.LBE84:
 148:../Libraries/AQ_Receiver/Receiver_STM32.h ****       }
 149:../Libraries/AQ_Receiver/Receiver_STM32.h ****     }
 150:../Libraries/AQ_Receiver/Receiver_STM32.h ****   } 
 151:../Libraries/AQ_Receiver/Receiver_STM32.h ****   else if(rising) {
 3679              		.loc 16 151 0
 3680 003e 12B1     		cbz	r2, .L199
 152:../Libraries/AQ_Receiver/Receiver_STM32.h ****     // rising edge, store start time
 153:../Libraries/AQ_Receiver/Receiver_STM32.h ****     f->RiseTime = c;
 154:../Libraries/AQ_Receiver/Receiver_STM32.h ****     f->Valid = true;
 3681              		.loc 16 154 0
 3682 0040 0122     		movs	r2, #1
 153:../Libraries/AQ_Receiver/Receiver_STM32.h ****     f->RiseTime = c;
 3683              		.loc 16 153 0
 3684 0042 C382     		strh	r3, [r0, #22]	@ movhi
 3685              		.loc 16 154 0
 3686 0044 8262     		str	r2, [r0, #40]
 3687              	.LVL183:
 3688              	.L199:
 3689              	.LBE86:
 3690              	.LBE87:
 155:../Libraries/AQ_Receiver/Receiver_STM32.h ****   }
 156:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 157:../Libraries/AQ_Receiver/Receiver_STM32.h ****   PWMInvertPolarity(f);
 158:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3691              		.loc 16 158 0
 3692 0046 BDE81040 		pop	{r4, lr}
 3693              	.LBB88:
 157:../Libraries/AQ_Receiver/Receiver_STM32.h ****   PWMInvertPolarity(f);
 3694              		.loc 16 157 0
 3695 004a FFF7FEBF 		b	_Z17PWMInvertPolarityPV8tFrqData
 3696              	.LVL184:
 3697              	.LBE88:
 3698              		.cfi_endproc
 3699              	.LFE174:
 3701              		.section	.text._Z14IrqChangeValuei,"ax",%progbits
 3702              		.align	1
 3703              		.global	_Z14IrqChangeValuei
 3704              		.thumb
 3705              		.thumb_func
 3707              	_Z14IrqChangeValuei:
 3708              	.LFB175:
 159:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 160:../Libraries/AQ_Receiver/Receiver_STM32.h **** // hide the class details from the interrupt handler
 161:../Libraries/AQ_Receiver/Receiver_STM32.h **** void IrqChangeValue(int chan) {
 3709              		.loc 16 161 0
 3710              		.cfi_startproc
 3711              		@ args = 0, pretend = 0, frame = 0
 3712              		@ frame_needed = 0, uses_anonymous_args = 0
 3713              		@ link register save eliminated.
 3714              	.LVL185:
 162:../Libraries/AQ_Receiver/Receiver_STM32.h ****   FrqChange(&FrqData[chan]);
 3715              		.loc 16 162 0
 3716 0000 024B     		ldr	r3, .L202
 3717 0002 3022     		movs	r2, #48
 3718 0004 02FB0030 		mla	r0, r2, r0, r3
 3719              	.LVL186:
 163:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3720              		.loc 16 163 0
 162:../Libraries/AQ_Receiver/Receiver_STM32.h ****   FrqChange(&FrqData[chan]);
 3721              		.loc 16 162 0
 3722 0008 FFF7FEBF 		b	_Z9FrqChangePV8tFrqData
 3723              	.L203:
 3724              		.align	2
 3725              	.L202:
 3726 000c 00000000 		.word	.LANCHOR51
 3727              		.cfi_endproc
 3728              	.LFE175:
 3730              		.section	.text._Z8PWM_in_7v,"ax",%progbits
 3731              		.align	1
 3732              		.global	_Z8PWM_in_7v
 3733              		.thumb
 3734              		.thumb_func
 3736              	_Z8PWM_in_7v:
 3737              	.LFB183:
 164:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 165:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 166:../Libraries/AQ_Receiver/Receiver_STM32.h **** ///////////////////////////////////////////////////////////////////////////////
 167:../Libraries/AQ_Receiver/Receiver_STM32.h **** // definition of interrupt handler functions, one for each channel
 168:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_0() { IrqChangeValue(0); }
 169:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_1() { IrqChangeValue(1); }
 170:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_2() { IrqChangeValue(2); }
 171:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_3() { IrqChangeValue(3); }
 172:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_4() { IrqChangeValue(4); }
 173:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_5() { IrqChangeValue(5); }
 174:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_6() { IrqChangeValue(6); }
 175:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_7() { IrqChangeValue(7); }
 3738              		.loc 16 175 0
 3739              		.cfi_startproc
 3740              		@ args = 0, pretend = 0, frame = 0
 3741              		@ frame_needed = 0, uses_anonymous_args = 0
 3742              		@ link register save eliminated.
 3743              		.loc 16 175 0
 3744 0000 0720     		movs	r0, #7
 3745 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3746              		.cfi_endproc
 3747              	.LFE183:
 3749              		.section	.text._Z8PWM_in_6v,"ax",%progbits
 3750              		.align	1
 3751              		.global	_Z8PWM_in_6v
 3752              		.thumb
 3753              		.thumb_func
 3755              	_Z8PWM_in_6v:
 3756              	.LFB182:
 174:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_6() { IrqChangeValue(6); }
 3757              		.loc 16 174 0
 3758              		.cfi_startproc
 3759              		@ args = 0, pretend = 0, frame = 0
 3760              		@ frame_needed = 0, uses_anonymous_args = 0
 3761              		@ link register save eliminated.
 174:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_6() { IrqChangeValue(6); }
 3762              		.loc 16 174 0
 3763 0000 0620     		movs	r0, #6
 3764 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3765              		.cfi_endproc
 3766              	.LFE182:
 3768              		.section	.text._Z8PWM_in_5v,"ax",%progbits
 3769              		.align	1
 3770              		.global	_Z8PWM_in_5v
 3771              		.thumb
 3772              		.thumb_func
 3774              	_Z8PWM_in_5v:
 3775              	.LFB181:
 173:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_5() { IrqChangeValue(5); }
 3776              		.loc 16 173 0
 3777              		.cfi_startproc
 3778              		@ args = 0, pretend = 0, frame = 0
 3779              		@ frame_needed = 0, uses_anonymous_args = 0
 3780              		@ link register save eliminated.
 173:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_5() { IrqChangeValue(5); }
 3781              		.loc 16 173 0
 3782 0000 0520     		movs	r0, #5
 3783 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3784              		.cfi_endproc
 3785              	.LFE181:
 3787              		.section	.text._Z8PWM_in_4v,"ax",%progbits
 3788              		.align	1
 3789              		.global	_Z8PWM_in_4v
 3790              		.thumb
 3791              		.thumb_func
 3793              	_Z8PWM_in_4v:
 3794              	.LFB180:
 172:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_4() { IrqChangeValue(4); }
 3795              		.loc 16 172 0
 3796              		.cfi_startproc
 3797              		@ args = 0, pretend = 0, frame = 0
 3798              		@ frame_needed = 0, uses_anonymous_args = 0
 3799              		@ link register save eliminated.
 172:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_4() { IrqChangeValue(4); }
 3800              		.loc 16 172 0
 3801 0000 0420     		movs	r0, #4
 3802 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3803              		.cfi_endproc
 3804              	.LFE180:
 3806              		.section	.text._Z8PWM_in_3v,"ax",%progbits
 3807              		.align	1
 3808              		.global	_Z8PWM_in_3v
 3809              		.thumb
 3810              		.thumb_func
 3812              	_Z8PWM_in_3v:
 3813              	.LFB179:
 171:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_3() { IrqChangeValue(3); }
 3814              		.loc 16 171 0
 3815              		.cfi_startproc
 3816              		@ args = 0, pretend = 0, frame = 0
 3817              		@ frame_needed = 0, uses_anonymous_args = 0
 3818              		@ link register save eliminated.
 171:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_3() { IrqChangeValue(3); }
 3819              		.loc 16 171 0
 3820 0000 0320     		movs	r0, #3
 3821 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3822              		.cfi_endproc
 3823              	.LFE179:
 3825              		.section	.text._Z8PWM_in_2v,"ax",%progbits
 3826              		.align	1
 3827              		.global	_Z8PWM_in_2v
 3828              		.thumb
 3829              		.thumb_func
 3831              	_Z8PWM_in_2v:
 3832              	.LFB178:
 170:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_2() { IrqChangeValue(2); }
 3833              		.loc 16 170 0
 3834              		.cfi_startproc
 3835              		@ args = 0, pretend = 0, frame = 0
 3836              		@ frame_needed = 0, uses_anonymous_args = 0
 3837              		@ link register save eliminated.
 170:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_2() { IrqChangeValue(2); }
 3838              		.loc 16 170 0
 3839 0000 0220     		movs	r0, #2
 3840 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3841              		.cfi_endproc
 3842              	.LFE178:
 3844              		.section	.text._Z8PWM_in_1v,"ax",%progbits
 3845              		.align	1
 3846              		.global	_Z8PWM_in_1v
 3847              		.thumb
 3848              		.thumb_func
 3850              	_Z8PWM_in_1v:
 3851              	.LFB177:
 169:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_1() { IrqChangeValue(1); }
 3852              		.loc 16 169 0
 3853              		.cfi_startproc
 3854              		@ args = 0, pretend = 0, frame = 0
 3855              		@ frame_needed = 0, uses_anonymous_args = 0
 3856              		@ link register save eliminated.
 169:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_1() { IrqChangeValue(1); }
 3857              		.loc 16 169 0
 3858 0000 0120     		movs	r0, #1
 3859 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3860              		.cfi_endproc
 3861              	.LFE177:
 3863              		.section	.text._Z8PWM_in_0v,"ax",%progbits
 3864              		.align	1
 3865              		.global	_Z8PWM_in_0v
 3866              		.thumb
 3867              		.thumb_func
 3869              	_Z8PWM_in_0v:
 3870              	.LFB176:
 168:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_0() { IrqChangeValue(0); }
 3871              		.loc 16 168 0
 3872              		.cfi_startproc
 3873              		@ args = 0, pretend = 0, frame = 0
 3874              		@ frame_needed = 0, uses_anonymous_args = 0
 3875              		@ link register save eliminated.
 168:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_0() { IrqChangeValue(0); }
 3876              		.loc 16 168 0
 3877 0000 0020     		movs	r0, #0
 3878 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3879              		.cfi_endproc
 3880              	.LFE176:
 3882              		.section	.text._Z18initializeReceiveri,"ax",%progbits
 3883              		.align	1
 3884              		.global	_Z18initializeReceiveri
 3885              		.thumb
 3886              		.thumb_func
 3888              	_Z18initializeReceiveri:
 3889              	.LFB184:
 176:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 177:../Libraries/AQ_Receiver/Receiver_STM32.h **** voidFuncPtr PWM_in_handler[] = { PWM_in_0, PWM_in_1, PWM_in_2, PWM_in_3, PWM_in_4, PWM_in_5, PWM_in
 178:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 179:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 180:../Libraries/AQ_Receiver/Receiver_STM32.h **** ///////////////////////////////////////////////////////////////////////////////
 181:../Libraries/AQ_Receiver/Receiver_STM32.h **** // interface part starts here
 182:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 183:../Libraries/AQ_Receiver/Receiver_STM32.h **** void initializeReceiver(int nbChannel = 8) {
 3890              		.loc 16 183 0
 3891              		.cfi_startproc
 3892              		@ args = 0, pretend = 0, frame = 0
 3893              		@ frame_needed = 0, uses_anonymous_args = 0
 3894              	.LVL187:
 3895 0000 08B5     		push	{r3, lr}
 3896              	.LCFI36:
 3897              		.cfi_def_cfa_offset 8
 3898              		.cfi_offset 14, -4
 3899              		.cfi_offset 3, -8
 184:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 185:../Libraries/AQ_Receiver/Receiver_STM32.h ****     initializeReceiverParam(nbChannel);
 3900              		.loc 16 185 0
 3901 0002 FFF7FEFF 		bl	_Z23initializeReceiverParami
 3902              	.LVL188:
 186:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	InitFrqMeasurement();
 187:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3903              		.loc 16 187 0
 3904 0006 BDE80840 		pop	{r3, lr}
 186:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	InitFrqMeasurement();
 3905              		.loc 16 186 0
 3906 000a FFF7FEBF 		b	_Z18InitFrqMeasurementv
 3907              		.cfi_endproc
 3908              	.LFE184:
 3910              		.section	.text._Z18getRawChannelValueh,"ax",%progbits
 3911              		.align	1
 3912              		.global	_Z18getRawChannelValueh
 3913              		.thumb
 3914              		.thumb_func
 3916              	_Z18getRawChannelValueh:
 3917              	.LFB185:
 188:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 189:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 190:../Libraries/AQ_Receiver/Receiver_STM32.h **** int getRawChannelValue(const byte channel) {
 3918              		.loc 16 190 0
 3919              		.cfi_startproc
 3920              		@ args = 0, pretend = 0, frame = 0
 3921              		@ frame_needed = 0, uses_anonymous_args = 0
 3922              		@ link register save eliminated.
 3923              	.LVL189:
 3924              	.LBB89:
 191:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	int chan = ReceiverChannelMap[channel];
 3925              		.loc 16 191 0
 3926 0000 064B     		ldr	r3, .L216
 3927 0002 1B5C     		ldrb	r3, [r3, r0]	@ zero_extendqisi2
 3928              	.LVL190:
 3929              	.LBB90:
 192:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	if(chan < (int)sizeof(receiverPin)) {
 3930              		.loc 16 192 0
 3931 0004 072B     		cmp	r3, #7
 3932 0006 06DC     		bgt	.L215
 3933              	.LBB91:
 193:../Libraries/AQ_Receiver/Receiver_STM32.h **** 		volatile tFrqData *f = &FrqData[chan];
 3934              		.loc 16 193 0
 3935 0008 054A     		ldr	r2, .L216+4
 3936 000a 3020     		movs	r0, #48
 3937              	.LVL191:
 3938 000c 00FB0321 		mla	r1, r0, r3, r2
 3939              	.LVL192:
 194:../Libraries/AQ_Receiver/Receiver_STM32.h **** 		uint16_t PulsLength = f->HighTime;
 3940              		.loc 16 194 0
 3941 0010 888A     		ldrh	r0, [r1, #20]
 3942 0012 80B2     		uxth	r0, r0
 195:../Libraries/AQ_Receiver/Receiver_STM32.h **** 		return PulsLength;
 3943              		.loc 16 195 0
 3944 0014 7047     		bx	lr
 3945              	.LVL193:
 3946              	.L215:
 3947              	.LBE91:
 196:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	} else {
 197:../Libraries/AQ_Receiver/Receiver_STM32.h **** 		return 1500;
 3948              		.loc 16 197 0
 3949 0016 40F2DC50 		movw	r0, #1500
 3950              	.LVL194:
 3951              	.LBE90:
 3952              	.LBE89:
 198:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	}
 199:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3953              		.loc 16 199 0
 3954 001a 7047     		bx	lr
 3955              	.L217:
 3956              		.align	2
 3957              	.L216:
 3958 001c 00000000 		.word	.LANCHOR53
 3959 0020 00000000 		.word	.LANCHOR51
 3960              		.cfi_endproc
 3961              	.LFE185:
 3963              		.section	.text._Z12readReceiverv,"ax",%progbits
 3964              		.align	1
 3965              		.global	_Z12readReceiverv
 3966              		.thumb
 3967              		.thumb_func
 3969              	_Z12readReceiverv:
 3970              	.LFB124:
  89:../Libraries/AQ_Receiver/Receiver.h **** {
 3971              		.loc 6 89 0
 3972              		.cfi_startproc
 3973              		@ args = 0, pretend = 0, frame = 0
 3974              		@ frame_needed = 0, uses_anonymous_args = 0
 3975              	.LVL195:
 3976 0000 70B5     		push	{r4, r5, r6, lr}
 3977              	.LCFI37:
 3978              		.cfi_def_cfa_offset 16
 3979              		.cfi_offset 14, -4
 3980              		.cfi_offset 6, -8
 3981              		.cfi_offset 5, -12
 3982              		.cfi_offset 4, -16
 3983              	.LBB92:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3984              		.loc 6 90 0
 3985 0002 0024     		movs	r4, #0
 3986              	.LBE92:
  89:../Libraries/AQ_Receiver/Receiver.h **** {
 3987              		.loc 6 89 0
 3988 0004 2DED028B 		fstmfdd	sp!, {d8}
 3989              	.LCFI38:
 3990              		.cfi_def_cfa_offset 24
 3991              		.cfi_offset 80, -24
 3992              	.LBB93:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3993              		.loc 6 90 0
 3994 0008 33E0     		b	.L219
 3995              	.LVL196:
 3996              	.L220:
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3997              		.loc 6 93 0 discriminator 2
 3998 000a 3048     		ldr	r0, .L225
 3999 000c A600     		lsls	r6, r4, #2
 4000 000e 8119     		adds	r1, r0, r6
 4001 0010 2046     		mov	r0, r4
 4002 0012 91ED008A 		flds	s16, [r1, #0]
 4003 0016 FFF7FEFF 		bl	_Z18getRawChannelValueh
 4004 001a 2D4B     		ldr	r3, .L225+4
 4005 001c 02EE900A 		fmsr	s5, r0	@ int
 4006 0020 9A19     		adds	r2, r3, r6
 4007 0022 92ED002A 		flds	s4, [r2, #0]
 4008 0026 B8EEE27A 		fsitos	s14, s5
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 4009              		.loc 6 95 0 discriminator 2
 4010 002a 55F82420 		ldr	r2, [r5, r4, lsl #2]
 4011 002e 294B     		ldr	r3, .L225+8
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 4012              		.loc 6 93 0 discriminator 2
 4013 0030 2948     		ldr	r0, .L225+12
 4014 0032 08EE072A 		fmacs	s4, s16, s14
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 4015              		.loc 6 95 0 discriminator 2
 4016 0036 01EE102A 		fmsr	s2, r2	@ int
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 4017              		.loc 6 93 0 discriminator 2
 4018 003a FDEEC21A 		ftosizs	s3, s4
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 4019              		.loc 6 95 0 discriminator 2
 4020 003e 9E19     		adds	r6, r3, r6
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 4021              		.loc 6 93 0 discriminator 2
 4022 0040 11EE901A 		fmrs	r1, s3	@ int
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 4023              		.loc 6 95 0 discriminator 2
 4024 0044 F8EEE17A 		fsitos	s15, s3
 4025 0048 F8EEC10A 		fsitos	s1, s2
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 4026              		.loc 6 93 0 discriminator 2
 4027 004c 40F82410 		str	r1, [r0, r4, lsl #2]
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 4028              		.loc 6 95 0 discriminator 2
 4029 0050 3268     		ldr	r2, [r6, #0]	@ float
 4030 0052 17EE900A 		fmrs	r0, s15
 4031 0056 10EE901A 		fmrs	r1, s1
 4032 005a FFF7FEFF 		bl	_Z12filterSmoothfff
 4033 005e 00EE100A 		fmsr	s0, r0
 4034 0062 BDEEC06A 		ftosizs	s12, s0
 4035 0066 16EE100A 		fmrs	r0, s12	@ int
 4036 006a 45F82400 		str	r0, [r5, r4, lsl #2]
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 4037              		.loc 6 90 0 discriminator 2
 4038 006e 0134     		adds	r4, r4, #1
 4039              	.LVL197:
 4040 0070 E4B2     		uxtb	r4, r4
 4041              	.LVL198:
 4042              	.L219:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 4043              		.loc 6 90 0 is_stmt 0 discriminator 1
 4044 0072 1A4D     		ldr	r5, .L225+16
 4045 0074 2A68     		ldr	r2, [r5, #0]
 4046 0076 1A4D     		ldr	r5, .L225+20
 4047 0078 9442     		cmp	r4, r2
 4048 007a C6DB     		blt	.L220
 4049              	.LVL199:
 4050              	.LBE93:
 4051              	.LBB94:
 100:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 4052              		.loc 6 100 0 is_stmt 1
 4053 007c 194C     		ldr	r4, .L225+24
 4054              	.LVL200:
 4055 007e 94ED007A 		flds	s14, [r4, #0]
 4056 0082 0023     		movs	r3, #0
 4057              	.LVL201:
 4058              	.L221:
 100:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 4059              		.loc 6 100 0 is_stmt 0 discriminator 2
 4060 0084 1849     		ldr	r1, .L225+28
 4061 0086 EC58     		ldr	r4, [r5, r3]
 4062 0088 5858     		ldr	r0, [r3, r1]
 4063 008a 1849     		ldr	r1, .L225+32
 4064 008c 241A     		subs	r4, r4, r0
 4065 008e 04EE904A 		fmsr	s9, r4	@ int
 4066 0092 04EE100A 		fmsr	s8, r0	@ int
 4067 0096 F8EEE46A 		fsitos	s13, s9
 4068 009a F8EEC43A 		fsitos	s7, s8
 4069 009e 46EE873A 		fmacs	s7, s13, s14
 4070 00a2 BDEEE33A 		ftosizs	s6, s7
 4071 00a6 13EE100A 		fmrs	r0, s6	@ int
 4072 00aa 5850     		str	r0, [r3, r1]
 4073 00ac 0433     		adds	r3, r3, #4
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 4074              		.loc 6 99 0 is_stmt 1 discriminator 2
 4075 00ae 0C2B     		cmp	r3, #12
 4076 00b0 E8D1     		bne	.L221
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 4077              		.loc 6 99 0 is_stmt 0
 4078 00b2 0323     		movs	r3, #3
 4079 00b4 05E0     		b	.L222
 4080              	.LVL202:
 4081              	.L223:
 4082              	.LBE94:
 4083              	.LBB95:
 104:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 4084              		.loc 6 104 0 is_stmt 1 discriminator 2
 4085 00b6 55F82300 		ldr	r0, [r5, r3, lsl #2]
 4086 00ba 41F82300 		str	r0, [r1, r3, lsl #2]
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 4087              		.loc 6 103 0 discriminator 2
 4088 00be 0133     		adds	r3, r3, #1
 4089              	.LVL203:
 4090 00c0 DBB2     		uxtb	r3, r3
 4091              	.LVL204:
 4092              	.L222:
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 4093              		.loc 6 103 0 is_stmt 0 discriminator 1
 4094 00c2 9342     		cmp	r3, r2
 4095 00c4 F7DB     		blt	.L223
 4096              	.LBE95:
 106:../Libraries/AQ_Receiver/Receiver.h **** }
 4097              		.loc 6 106 0 is_stmt 1
 4098 00c6 BDEC028B 		fldmfdd	sp!, {d8}
 4099 00ca 70BD     		pop	{r4, r5, r6, pc}
 4100              	.L226:
 4101              		.align	2
 4102              	.L225:
 4103 00cc 00000000 		.word	.LANCHOR4
 4104 00d0 00000000 		.word	.LANCHOR5
 4105 00d4 00000000 		.word	.LANCHOR6
 4106 00d8 00000000 		.word	.LANCHOR54
 4107 00dc 00000000 		.word	.LANCHOR0
 4108 00e0 00000000 		.word	.LANCHOR2
 4109 00e4 00000000 		.word	.LANCHOR55
 4110 00e8 00000000 		.word	.LANCHOR3
 4111 00ec 00000000 		.word	.LANCHOR1
 4112              		.cfi_endproc
 4113              	.LFE124:
 4115              		.section	.text._Z15setChannelValuehi,"ax",%progbits
 4116              		.align	1
 4117              		.global	_Z15setChannelValuehi
 4118              		.thumb
 4119              		.thumb_func
 4121              	_Z15setChannelValuehi:
 4122              	.LFB186:
 200:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 201:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 202:../Libraries/AQ_Receiver/Receiver_STM32.h **** void setChannelValue(byte channel,int value) {
 4123              		.loc 16 202 0
 4124              		.cfi_startproc
 4125              		@ args = 0, pretend = 0, frame = 0
 4126              		@ frame_needed = 0, uses_anonymous_args = 0
 4127              		@ link register save eliminated.
 4128              	.LVL205:
 203:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 4129              		.loc 16 203 0
 4130 0000 7047     		bx	lr
 4131              		.cfi_endproc
 4132              	.LFE186:
 4134              		.section	.text._Z11writeMotorsv,"ax",%progbits
 4135              		.align	1
 4136              		.global	_Z11writeMotorsv
 4137              		.thumb
 4138              		.thumb_func
 4140              	_Z11writeMotorsv:
 4141              	.LFB189:
 4142              		.file 17 "../Libraries/AQ_Motors/Motors_STM32.h"
   1:../Libraries/AQ_Motors/Motors_STM32.h **** #ifndef _AEROQUAD_MOTORS_STM32_H_
   2:../Libraries/AQ_Motors/Motors_STM32.h **** #define _AEROQUAD_MOTORS_STM32_H_
   3:../Libraries/AQ_Motors/Motors_STM32.h **** 
   4:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_Motors/Motors_STM32.h **** 
   6:../Libraries/AQ_Motors/Motors_STM32.h **** #include "Motors.h"
   7:../Libraries/AQ_Motors/Motors_STM32.h **** 
   8:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
   9:../Libraries/AQ_Motors/Motors_STM32.h **** // definition section
  10:../Libraries/AQ_Motors/Motors_STM32.h **** 
  11:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined (USE_400HZ_ESC)
  12:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_FREQUENCY 400   // in Hz
  13:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  14:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_FREQUENCY 300   // in Hz
  15:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  16:../Libraries/AQ_Motors/Motors_STM32.h **** #define PWM_PERIODE     (1000000/PWM_FREQUENCY)
  17:../Libraries/AQ_Motors/Motors_STM32.h **** 
  18:../Libraries/AQ_Motors/Motors_STM32.h **** #ifdef MOTORS_STM32_TRI
  19:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_SERVO_FREQUENCY 50 // Hz 
  20:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_SERVO_PERIODE   (1000000/PWM_SERVO_FREQUENCY)
  21:../Libraries/AQ_Motors/Motors_STM32.h ****   #define STM32_MOTOR_MAP stm32_motor_mapping_tri
  22:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  23:../Libraries/AQ_Motors/Motors_STM32.h ****   #define STM32_MOTOR_MAP stm32_motor_mapping
  24:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  25:../Libraries/AQ_Motors/Motors_STM32.h **** 
  26:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
  27:../Libraries/AQ_Motors/Motors_STM32.h **** // code section
  28:../Libraries/AQ_Motors/Motors_STM32.h **** 
  29:../Libraries/AQ_Motors/Motors_STM32.h **** static int _stm32_motor_number;
  30:../Libraries/AQ_Motors/Motors_STM32.h **** 
  31:../Libraries/AQ_Motors/Motors_STM32.h **** // global section
  32:../Libraries/AQ_Motors/Motors_STM32.h **** 
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
  34:../Libraries/AQ_Motors/Motors_STM32.h ****  
  35:../Libraries/AQ_Motors/Motors_STM32.h ****   int motor;
  36:../Libraries/AQ_Motors/Motors_STM32.h **** 
  37:../Libraries/AQ_Motors/Motors_STM32.h ****   _stm32_motor_number = sizeof(STM32_MOTOR_MAP)/sizeof(STM32_MOTOR_MAP[0]);
  38:../Libraries/AQ_Motors/Motors_STM32.h ****   if(numbers < _stm32_motor_number) {
  39:../Libraries/AQ_Motors/Motors_STM32.h ****     _stm32_motor_number = numbers;
  40:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  41:../Libraries/AQ_Motors/Motors_STM32.h ****   
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
  43:../Libraries/AQ_Motors/Motors_STM32.h **** 
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
  45:../Libraries/AQ_Motors/Motors_STM32.h **** 
  46:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_prescaler(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, prescaler);
  47:../Libraries/AQ_Motors/Motors_STM32.h **** 
  48:../Libraries/AQ_Motors/Motors_STM32.h **** #ifdef MOTORS_STM32_TRI
  49:../Libraries/AQ_Motors/Motors_STM32.h ****     // on Tri mode motor 0 is a servo and thus has slower update rate
  50:../Libraries/AQ_Motors/Motors_STM32.h ****     if (motor == 0) {
  51:../Libraries/AQ_Motors/Motors_STM32.h ****       timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_SERVO_PERIODE);
  52:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  53:../Libraries/AQ_Motors/Motors_STM32.h ****     else {
  54:../Libraries/AQ_Motors/Motors_STM32.h ****       timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_PERIODE);
  55:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  56:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  57:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_PERIODE);
  58:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  59:../Libraries/AQ_Motors/Motors_STM32.h ****     
  60:../Libraries/AQ_Motors/Motors_STM32.h ****     pinMode(STM32_MOTOR_MAP[motor], PWM);
  61:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  62:../Libraries/AQ_Motors/Motors_STM32.h ****   
  63:../Libraries/AQ_Motors/Motors_STM32.h ****   // sync timer
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
  65:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_generate_update(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device);
  66:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  67:../Libraries/AQ_Motors/Motors_STM32.h ****   
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
  69:../Libraries/AQ_Motors/Motors_STM32.h ****   //Serial.println("motor init done\r\n");
  70:../Libraries/AQ_Motors/Motors_STM32.h **** }
  71:../Libraries/AQ_Motors/Motors_STM32.h **** 
  72:../Libraries/AQ_Motors/Motors_STM32.h **** void writeMotors(void) { // update motor commands on timers
 4143              		.loc 17 72 0
 4144              		.cfi_startproc
 4145              		@ args = 0, pretend = 0, frame = 0
 4146              		@ frame_needed = 0, uses_anonymous_args = 0
 4147              	.LVL206:
 4148 0000 38B5     		push	{r3, r4, r5, lr}
 4149              	.LCFI39:
 4150              		.cfi_def_cfa_offset 16
 4151              		.cfi_offset 14, -4
 4152              		.cfi_offset 5, -8
 4153              		.cfi_offset 4, -12
 4154              		.cfi_offset 3, -16
 4155              	.LBB96:
  73:../Libraries/AQ_Motors/Motors_STM32.h **** 
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4156              		.loc 17 74 0
 4157 0002 0B4D     		ldr	r5, .L231
 4158 0004 0024     		movs	r4, #0
 4159 0006 0EE0     		b	.L229
 4160              	.LVL207:
 4161              	.L230:
  75:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_compare(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PIN_MAP[STM32_MOTOR_MAP[motor]]
 4162              		.loc 17 75 0 discriminator 2
 4163 0008 0A4A     		ldr	r2, .L231+4
 4164 000a 0B48     		ldr	r0, .L231+8
 4165 000c 14F802C0 		ldrb	ip, [r4, r2]	@ zero_extendqisi2
 4166 0010 55F8042F 		ldr	r2, [r5, #4]!
 4167 0014 00EB0C13 		add	r3, r0, ip, lsl #4
 4168 0018 92B2     		uxth	r2, r2
 4169              		.file 18 "/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino"
   1:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*
   2:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   AeroQuad v3.0.1 - February 2012
   3:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   www.AeroQuad.com
   4:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   An Open Source Arduino based multicopter.
   6:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
   7:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   This program is free software: you can redistribute it and/or modify
   8:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   it under the terms of the GNU General Public License as published by
   9:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   the Free Software Foundation, either version 3 of the License, or
  10:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   (at your option) any later version.
  11:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  12:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   This program is distributed in the hope that it will be useful,
  13:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   GNU General Public License for more details.
  16:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  17:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   You should have received a copy of the GNU General Public License
  18:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** */
  20:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  21:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /****************************************************************************
  22:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    Before flight, select the different user options for your AeroQuad by
  23:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    editing UserConfiguration.h.
  24:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  25:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    If you need additional assistance go to http://www.aeroquad.com/forum.php
  26:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    or talk to us live on IRC #aeroquad
  27:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** *****************************************************************************/
  28:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  29:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "UserConfiguration.h" // Edit this file first before uploading to the AeroQuad
  30:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  31:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //
  32:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** // Define Security Checks
  33:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //
  34:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  35:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseGPSNMEA) || defined(UseGPSUBLOX) || defined(UseGPSMTK) || defined(UseGPS406)
  36:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  #define UseGPS
  37:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif 
  38:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  39:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseGPSNavigator) && !defined(AltitudeHoldBaro)
  40:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #error "GpsNavigation NEED AltitudeHoldBaro defined"
  41:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  43:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(AutoLanding) && (!defined(AltitudeHoldBaro) || !defined(AltitudeHoldRangeFinder))
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #error "AutoLanding NEED AltitudeHoldBaro and AltitudeHoldRangeFinder defined"
  45:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
  46:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  47:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(ReceiverSBUS) && defined(SlowTelemetry)
  48:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #error "Receiver SWBUS and SlowTelemetry are in conflict for Seria2, they can't be used together"
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined (CameraTXControl) && !defined (CameraControl)
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #error "CameraTXControl need to have CameraControl defined"
  53:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif 
  54:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <EEPROM.h>
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <Wire.h>
  57:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <GlobalDefined.h>
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "AeroQuad.h"
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "PID.h"
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <AQMath.h>
  61:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <FourtOrderFilter.h>
  62:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef BattMonitor
  63:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <BatteryMonitorTypes.h>
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  66:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  67:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********* PLATFORM SPECIFIC SECTION ********************
  69:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuad_v1
  72:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 12
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 12
  75:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  79:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
  80:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
  81:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver declaration
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_328P
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  85:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  88:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // unsupported in v1
  89:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldBaro
  90:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
  91:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef HeadingMagHold
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef BattMonitor
  93:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef BattMonitorAutoDescent
  94:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef POWERED_BY_VIN        
  95:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef CameraControl
  96:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef OSD
  97:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPS
  98:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPSNavigator
  99:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 100:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 101:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 102:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuad_v1 specific initialization need here
 103:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 104:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 105:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     setGyroAref(aref);
 106:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 108:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 109:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 110:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Accel Cal
 111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 1.0;
 112:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[XAXIS] = 0.0;
 113:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 1.0;
 114:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[YAXIS] = 0.0;
 115:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = 1.0;
 116:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[ZAXIS] = 0.0;
 117:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 118:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 119:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 120:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 121:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 122:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 123:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureGyro();
 124:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureAccel();
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 127:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 128:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuad_v1_IDG
 129:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 130:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 12
 131:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 12
 132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 133:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 134:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
 135:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 136:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 137:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
 138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 139:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver declaration
 140:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_328P
 141:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 142:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 143:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM
 144:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 145:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // unsupported in v1
 146:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldBaro
 147:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 148:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef HeadingMagHold
 149:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef BattMonitor
 150:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef BattMonitorAutoDescent
 151:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef POWERED_BY_VIN        
 152:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef CameraControl
 153:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef OSD
 154:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPS
 155:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPSNavigator
 156:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 157:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 158:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuad_v1_IDG specific initialization need here
 159:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 160:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 161:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     setGyroAref(aref);
 162:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 163:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 164:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // called when eeprom is initialized
 165:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 166:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Accel Cal
 167:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 1.0;
 168:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[XAXIS] = 0.0;
 169:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 1.0;
 170:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[YAXIS] = 0.0;
 171:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = 1.0;
 172:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[ZAXIS] = 0.0;
 173:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 174:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 175:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 176:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 177:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 178:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 179:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 180:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureGyro();
 181:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureAccel();
 182:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 183:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 184:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 185:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuad_v18
 186:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 187:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 12
 188:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 12
 189:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 190:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 191:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 192:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 193:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 194:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 195:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 196:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
 197:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 198:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver declaration
 199:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_328P
 200:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 201:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 202:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM_Timer
 203:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 204:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // heading mag hold declaration
 205:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef HeadingMagHold
 206:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define HMC5843
 207:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 208:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 209:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Battery Monitor declaration
 210:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 211:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15, 0.9, BM_NOPIN, 0, 0)
 212:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 213:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BattMonitorAutoDescent
 214:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef POWERED_BY_VIN        
 215:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 216:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 217:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldBaro
 218:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 219:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef CameraControl
 220:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef OSD
 221:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPS
 222:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPSNavigator
 223:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 224:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 225:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuad_v18 specific initialization need here
 226:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 227:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 228:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 229:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 230:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 231:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 232:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 233:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 234:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Wire.begin();
 235:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     TWBR = 12;
 236:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 237:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 238:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 239:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 240:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 241:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0047340002;
 242:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = -0.0046519994;
 243:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0046799998;
 244:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 245:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 246:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 247:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 248:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 250:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureGyroSum();
 251:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureAccelSum();
 252:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 253:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 254:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 255:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 256:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuad_Mini
 257:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 258:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 12
 259:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 12
 260:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 261:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 262:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 263:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 264:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define ITG3200_ADDRESS_ALTERNATE
 265:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 266:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 267:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 268:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_ADXL345.h>
 269:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 270:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver declaration
 271:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_328P
 272:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 273:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 274:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config)
 275:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define MOTOR_PWM_Timer
 276:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 277:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define MOTOR_PWM
 278:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif    
 279:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 280:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // heading mag hold declaration
 281:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef HeadingMagHold
 282:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define HMC5843
 283:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 284:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 285:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Battery Monitor declaration
 286:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 287:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.53, BM_NOPIN, 0, 0)
 288:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 289:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BattMonitorAutoDescent
 290:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef POWERED_BY_VIN        
 291:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 292:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 293:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // unsupported in mini
 294:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldBaro
 295:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 296:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef CameraControl
 297:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef OSD
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPS
 299:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPSNavigator
 300:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 301:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 302:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuad_Mini specific initialization need here
 303:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 304:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 305:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 306:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 307:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 308:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 309:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 310:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 311:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Wire.begin();
 312:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     TWBR = 12;
 313:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 314:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 315:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 316:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 317:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 318:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0371299982;
 319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = -0.0374319982;
 320:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0385979986;
 321:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 324:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 325:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 326:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 327:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureGyroSum();
 328:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureAccelSum();
 329:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 330:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 331:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 332:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuadMega_v1
 333:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 334:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 4
 335:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 31
 336:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 337:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Special thanks to Wilafau for fixes for this setup
 338:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // http://aeroquad.com/showthread.php?991-AeroQuad-Flight-Software-v2.0&p=11466&viewfull=1#post11
 339:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 340:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
 341:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 342:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 343:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
 344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 345:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Reveiver declaration
 346:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define OLD_RECEIVER_PIN_ORDER
 347:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_MEGA
 348:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 349:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 350:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM
 351:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 352:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // unsupported on mega v1
 353:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldBaro
 354:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 355:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef HeadingMagHold
 356:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef BattMonitor
 357:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef BattMonitorAutoDescent
 358:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef POWERED_BY_VIN        
 359:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef CameraControl
 360:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef OSD
 361:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 362:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 363:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuadMega_v1 specific initialization need here
 364:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 365:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 366:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     setGyroAref(aref);
 367:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 368:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 369:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // called when eeprom is initialized
 370:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 371:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Accel Cal
 372:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 1.0;
 373:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[XAXIS] = 0.0;
 374:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 1.0;
 375:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[YAXIS] = 0.0;
 376:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = 1.0;
 377:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[ZAXIS] = 0.0;
 378:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 379:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 380:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 381:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 382:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 383:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 384:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 385:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (deltaTime >= 10000) {
 386:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureGyro();
 387:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureAccel();
 388:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 389:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 390:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 391:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 392:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuadMega_v2
 393:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 394:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 4
 395:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 31
 396:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 397:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 398:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 399:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 400:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 401:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 402:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 403:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
 404:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 405:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver Declaration
 406:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_MEGA
 407:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 408:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 409:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM_Timer
 410:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 411:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // heading mag hold declaration
 412:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef HeadingMagHold
 413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #include <Compass.h>
 414:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //    #define SPARKFUN_5883L_BOB
 415:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define HMC5843
 416:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 417:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 418:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Altitude declaration
 419:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldBaro    
 420:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BMP085 
 421:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 422:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 423:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define XLMAXSONAR 
 424:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 425:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 426:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Battery Monitor declaration
 427:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 428:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 429:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 430:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #else
 431:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 432:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 433:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 434:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BattMonitorAutoDescent
 435:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef POWERED_BY_VIN        
 436:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 437:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 438:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef OSD
 439:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define MAX7456_OSD
 440:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif  
 441:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 442:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifndef UseGPS
 443:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef UseGPSNavigator
 444:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 445:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 446:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 447:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuadMega_v2 specific initialization need here
 448:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 449:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 450:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 451:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 452:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 453:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 454:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 455:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 456:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 457:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 458:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 459:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 460:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 461:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 462:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 463:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 464:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 465:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 466:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 467:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 468:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 469:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Wire.begin();
 470:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     TWBR = 12;
 471:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 472:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 473:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 474:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 475:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 476:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0046449995;
 477:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = -0.0047950000;
 478:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0047549996;
 479:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef HeadingMagHold
 480:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[XAXIS]  = 60.000000;
 481:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[YAXIS]  = -39.000000;
 482:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[ZAXIS]  = -7.500000;
 483:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 484:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 485:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 486:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 487:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 488:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 489:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 490:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureGyroSum();
 491:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureAccelSum();
 492:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 493:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 494:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 495:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuadMega_v21
 496:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 497:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 4
 498:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 31
 499:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 500:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 501:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 502:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 503:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define ITG3200_ADDRESS_ALTERNATE
 504:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_ITG3200_9DOF.h>
 505:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 506:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 507:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_ADXL345_9DOF.h>
 508:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 509:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver Declaration
 510:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_MEGA
 511:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 512:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 513:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM_Timer
 514:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 515:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // heading mag hold declaration
 516:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef HeadingMagHold
 517:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #include <Compass.h>
 518:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SPARKFUN_9DOF_5883L
 519:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 520:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 521:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Altitude declaration
 522:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 523:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BMP085
 524:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 525:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 526:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define XLMAXSONAR 
 527:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 528:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 529:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 530:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Battery Monitor declaration
 531:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 532:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 533:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 534:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #else
 535:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 536:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 537:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 538:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BattMonitorAutoDescent
 539:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef POWERED_BY_VIN        
 540:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 541:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 542:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef OSD
 543:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define MAX7456_OSD
 544:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif  
 545:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 546:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifndef UseGPS
 547:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef UseGPSNavigator
 548:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 549:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 550:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 551:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 552:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuadMega_v21 specific initialization need here
 553:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 554:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 555:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 556:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 557:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 558:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 559:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 560:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 561:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 562:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 563:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 564:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 565:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 566:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 567:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 568:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 569:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 570:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 571:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 572:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 573:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 574:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Wire.begin();
 575:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     TWBR = 12;
 576:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 577:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 578:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 579:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 580:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 581:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0365570020;
 582:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 0.0363000011;
 583:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0384629964;
 584:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef HeadingMagHold
 585:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[XAXIS]  = 1.500000;
 586:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[YAXIS]  = 205.500000;
 587:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[ZAXIS]  = -33.000000;
 588:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 589:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 590:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 591:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 592:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 593:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 594:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 595:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureGyroSum();
 596:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureAccelSum();
 597:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 598:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 599:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 600:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef ArduCopter
 601:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 37
 602:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 35
 603:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 36
 604:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 605:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <APM_ADC.h>
 606:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <APM_RC.h>
 607:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 608:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 609:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 610:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_APM.h>
 611:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 612:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer Declaration
 613:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_APM.h>
 614:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 615:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver Declaration
 616:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_APM
 617:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 618:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor Declaration
 619:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_APM
 620:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 621:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // heading mag hold declaration
 622:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef HeadingMagHold
 623:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define HMC5843
 624:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 625:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 626:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define XLMAXSONAR 
 627:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 628:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 629:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 630:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Altitude declaration
 631:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 632:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BMP085
 633:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 634:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 635:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Battery monitor declaration
 636:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 637:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.31, BM_NOPIN, 0, 0)
 638:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 639:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BattMonitorAutoDescent
 640:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef POWERED_BY_VIN        
 641:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 642:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 643:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef CameraControl
 644:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef OSD
 645:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifndef UseGPS
 646:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef UseGPSNavigator
 647:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 648:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 649:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 650:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 651:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put ArduCopter specific initialization need here
 652:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 653:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 654:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 655:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 656:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Green, OUTPUT);
 657:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 658:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeADC();
 659:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initRC();
 660:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 661:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Wire.begin();
 662:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     TWBR = 12;
 663:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 664:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 665:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 666:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 667:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Accel Cal
 668:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 1.0;
 669:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[XAXIS] = 0.0;
 670:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 1.0;
 671:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[YAXIS] = 0.0;
 672:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = 1.0;
 673:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[ZAXIS] = 0.0;
 674:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef HeadingMagHold
 675:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[XAXIS]  = 0.0;
 676:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[YAXIS]  = 0.0;
 677:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[ZAXIS]  = 0.0;
 678:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 679:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 680:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 681:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 682:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 683:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 684:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 685:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 686:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     evaluateADC();
 687:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureGyroSum();
 688:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureAccelSum();
 689:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 690:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 691:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 692:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuad_Wii
 693:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 694:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 12
 695:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 12
 696:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 697:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 698:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 699:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Platform Wii declaration
 700:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Platform_Wii.h>
 701:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 702:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 703:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_Wii.h>
 704:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 705:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 706:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_WII.h>
 707:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 708:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver declaration
 709:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_328P
 710:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 711:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 712:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM
 713:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 714:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // heading mag hold declaration
 715:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // unsupported on mega v1
 716:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldBaro
 717:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 718:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef HeadingMagHold
 719:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef BattMonitor
 720:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef BattMonitorAutoDescent
 721:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef POWERED_BY_VIN        
 722:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef CameraControl
 723:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef OSD
 724:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPS
 725:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPSNavigator
 726:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 727:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 728:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 729:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuad_Wii specific initialization need here
 730:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 731:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 732:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      Wire.begin();
 733:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 734:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      #if defined(AeroQuad_Paris_v3)
 735:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****        initializeWiiSensors(true);
 736:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      #else
 737:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****        initializeWiiSensors();
 738:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      #endif
 739:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 740:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 741:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 742:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 743:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Accel Cal
 744:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 1.0;
 745:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[XAXIS] = 0.0;
 746:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 1.0;
 747:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[YAXIS] = 0.0;
 748:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = 1.0;
 749:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[ZAXIS] = 0.0;
 750:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 751:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 752:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 753:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 754:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 755:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 756:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 757:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (deltaTime >= 10000) {
 758:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       readWiiSensors();
 759:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureGyro();
 760:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureAccel();
 761:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 762:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 763:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 764:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 765:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuadMega_Wii
 766:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 767:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 4
 768:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 31
 769:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 770:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 771:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 772:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Platform Wii declaration
 773:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Platform_Wii.h>
 774:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 775:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 776:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_Wii.h>
 777:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 778:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 779:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_WII.h>
 780:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 781:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver declaration
 782:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_MEGA
 783:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 784:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 785:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM
 786:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 787:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // heading mag hold declaration
 788:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef HeadingMagHold
 789:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #include <Compass.h>
 790:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define HMC5843
 791:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 792:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 793:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Altitude declaration
 794:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 795:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BMP085
 796:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 797:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 798:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define XLMAXSONAR 
 799:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 800:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 801:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Battery monitor declaration
 802:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 803:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.9, BM_NOPIN, 0, 0)
 804:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 805:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BattMonitorAutoDescent
 806:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef POWERED_BY_VIN        
 807:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 808:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 809:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef OSD
 810:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define MAX7456_OSD
 811:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 812:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 813:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPS        // Wii not enough stable to use gps
 814:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef UseGPSNavigator
 815:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 816:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 817:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 818:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuadMega_Wii specific initialization need here
 819:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 820:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 821:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Wire.begin();
 822:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 823:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeWiiSensors();
 824:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 825:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 826:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 827:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 828:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Accel Cal
 829:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 1.0;
 830:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[XAXIS] = 0.0;
 831:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 1.0;
 832:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[YAXIS] = 0.0;
 833:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = 1.0;
 834:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[ZAXIS] = 0.0;
 835:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef HeadingMagHold
 836:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[XAXIS]  = 0.0;
 837:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[YAXIS]  = 0.0;
 838:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       magBias[ZAXIS]  = 0.0;
 839:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 840:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 841:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 842:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 843:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 844:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 845:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 846:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 847:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (deltaTime >= 10000) {
 848:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       readWiiSensors();
 849:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureGyro();
 850:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureAccel();
 851:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 852:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 853:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 854:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 855:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuadMega_CHR6DM
 856:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 13
 857:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 4
 858:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 31
 859:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 860:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 861:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Platform_CHR6DM.h>
 862:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   CHR6DM chr6dm;
 863:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 864:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 865:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_CHR6DM.h>
 866:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 867:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 868:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_CHR6DM.h>
 869:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 870:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver declaration
 871:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_MEGA
 872:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 873:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 874:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_PWM
 875:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 876:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Kinematics declaration
 877:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "Kinematics_CHR6DM.h"
 878:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 879:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Compass declaration
 880:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define HeadingMagHold
 881:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define COMPASS_CHR6DM
 882:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Magnetometer_CHR6DM.h>
 883:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 884:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef OSD
 885:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define MAX7456_OSD
 886:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 887:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 888:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Altitude declaration
 889:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 890:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BMP085
 891:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 892:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 893:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define XLMAXSONAR 
 894:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 895:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 896:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Battery monitor declaration
 897:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 898:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.9, BM_NOPIN, 0, 0)
 899:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 900:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BattMonitorAutoDescent
 901:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef POWERED_BY_VIN        
 902:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 903:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 904:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifndef UseGPS
 905:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef UseGPSNavigator
 906:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 907:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 908:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 909:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 910:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put AeroQuadMega_CHR6DM specific initialization need here
 911:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 912:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
 913:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Serial1.begin(BAUD);
 914:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PORTD = B00000100;
 915:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 916:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Wire.begin();
 917:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 918:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     chr6dm.resetToFactory();
 919:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     chr6dm.setListenMode();
 920:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     chr6dm.setActiveChannels(CHANNEL_ALL_MASK);
 921:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     chr6dm.requestPacket();
 922:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 923:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     gyroChr6dm = &chr6dm;
 924:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelChr6dm = &chr6dm;
 925:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     kinematicsChr6dm = &chr6dm;
 926:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     compassChr6dm = &chr6dm;
 927:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 928:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 929:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
 930:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 931:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Accel Cal
 932:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 1.0;
 933:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[XAXIS] = 0.0;
 934:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 1.0;
 935:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[YAXIS] = 0.0;
 936:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = 1.0;
 937:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[ZAXIS] = 0.0;
 938:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 939:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 940:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 941:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
 942:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
 943:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
 944:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
 945:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (deltaTime >= 10000) {
 946:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       chr6dm.read();
 947:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureGyro();
 948:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureAccel();
 949:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 950:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 951:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 952:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 953:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef APM_OP_CHR6DM
 954:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Green 37
 955:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Red 35
 956:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define LED_Yellow 36
 957:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 958:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_I2C.h>
 959:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Platform_CHR6DM.h>
 960:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   CHR6DM chr6dm;
 961:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 962:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Gyroscope declaration
 963:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Gyroscope_CHR6DM.h>
 964:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 965:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Accelerometer declaration
 966:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Accelerometer_CHR6DM.h>
 967:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 968:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Receiver declaration
 969:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define RECEIVER_APM
 970:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 971:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Motor declaration
 972:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define MOTOR_APM
 973:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 974:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Kinematics declaration
 975:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "Kinematics_CHR6DM.h"
 976:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 977:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Compass declaration
 978:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define HeadingMagHold
 979:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #define COMPASS_CHR6DM
 980:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Magnetometer_CHR6DM.h>
 981:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 982:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Altitude declaration
 983:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 984:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BMP085
 985:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 986:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 987:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define XLMAXSONAR 
 988:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 989:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 990:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 991:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Battery monitor declaration
 992:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 993:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.31, BM_NOPIN, 0, 0)
 994:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 995:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BattMonitorAutoDescent
 996:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef POWERED_BY_VIN        
 997:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 998:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 999:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef CameraControl
1000:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #undef OSD
1001:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1002:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifndef UseGPS
1003:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef UseGPSNavigator
1004:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1005:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1006:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1007:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
1008:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Put APM_OP_CHR6DM specific initialization need here
1009:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
1010:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initPlatform() {
1011:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
1012:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
1013:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     pinMode(LED_Green, OUTPUT);
1014:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1015:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Serial1.begin(BAUD);
1016:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PORTD = B00000100;
1017:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1018:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Wire.begin();
1019:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1020:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     chr6dm.resetToFactory();
1021:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     chr6dm.setListenMode();
1022:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     chr6dm.setActiveChannels(CHANNEL_ALL_MASK);
1023:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     chr6dm.requestPacket();
1024:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1025:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     gyroChr6dm = &chr6dm;
1026:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelChr6dm = &chr6dm;
1027:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     kinematicsChr6dm = &chr6dm;
1028:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //    tempKinematics.setGyroscope(&gyroSpecific);
1029:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     compassChr6dm = &chr6dm;
1030:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
1031:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1032:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // called when eeprom is initialized
1033:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
1034:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // Accel Cal
1035:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[XAXIS] = 1.0;
1036:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[XAXIS] = 0.0;
1037:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[YAXIS] = 1.0;
1038:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[YAXIS] = 0.0;
1039:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     accelScaleFactor[ZAXIS] = 1.0;
1040:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     runTimeAccelBias[ZAXIS] = 0.0;
1041:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
1042:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1043:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1044:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /**
1045:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    * Measure critical sensors
1046:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    */
1047:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   void measureCriticalSensors() {
1048:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (deltaTime >= 10000) {
1049:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       chr6dm.read();
1050:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureGyro();
1051:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       measureAccel();
1052:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1053:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
1054:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1055:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1056:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1057:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1058:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********* HARDWARE GENERALIZATION SECTION **************
1059:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1060:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1061:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1062:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuadSTM32
1063:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "AeroQuad_STM32.h"
1064:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1065:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1066:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** // default to 10bit ADC (AVR)
1067:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifndef ADC_NUMBER_OF_BITS
1068:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #define ADC_NUMBER_OF_BITS 10
1069:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1070:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1071:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1072:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************** KINEMATICS DECLARATION **************
1073:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1074:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "Kinematics.h"
1075:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
1076:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // CHR6DM have it's own kinematics, so, initialize in it's scope
1077:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #else
1078:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "Kinematics_ARG.h"
1079:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1080:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1081:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1082:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******************** RECEIVER DECLARATION **************
1083:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1084:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(ReceiverHWPPM)
1085:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_HWPPM.h>
1086:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(ReceiverPPM)
1087:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_PPM.h>
1088:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(AeroQuad_Mini) && (defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Conf
1089:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_PPM.h>
1090:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RemotePCReceiver)
1091:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_RemotePC.h>
1092:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(ReceiverSBUS)
1093:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_SBUS.h>
1094:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_328P)
1095:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_328p.h>
1096:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_MEGA)
1097:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_MEGA.h>
1098:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_APM)
1099:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_APM.h>
1100:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_STM32PPM)
1101:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_STM32PPM.h>  
1102:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_STM32)
1103:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_STM32.h>  
1104:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1105:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1106:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseAnalogRSSIReader) 
1107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <AnalogRSSIReader.h>
1108:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(UseEzUHFRSSIReader)
1109:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <EzUHFRSSIReader.h>
1110:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(UseSBUSRSSIReader)
1111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <SBUSRSSIReader.h>
1112:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1113:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1114:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1115:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1116:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1117:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************** MOTORS DECLARATION **************
1118:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1119:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(triConfig)
1120:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined (MOTOR_STM32)
1121:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define MOTORS_STM32_TRI
1122:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #include <Motors_STM32.h>    
1123:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
1124:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #include <Motors_Tri.h>
1125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(MOTOR_PWM)
1127:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Motors_PWM.h>
1128:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(MOTOR_PWM_Timer)
1129:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Motors_PWM_Timer.h>
1130:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(MOTOR_APM)
1131:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Motors_APM.h>
1132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(MOTOR_I2C)
1133:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Motors_I2C.h>
1134:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(MOTOR_STM32)
1135:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Motors_STM32.h>    
1136:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1137:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1139:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******* HEADING HOLD MAGNETOMETER DECLARATION **********
1140:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1141:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(HMC5843)
1142:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <HeadingFusionProcessorMARG.h>
1143:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Magnetometer_HMC5843.h>
1144:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(SPARKFUN_9DOF_5883L) || defined(SPARKFUN_5883L_BOB) || defined(HMC5883L)
1145:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <HeadingFusionProcessorMARG.h>
1146:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Magnetometer_HMC5883L.h>
1147:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(COMPASS_CHR6DM)
1148:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1149:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1150:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1151:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******* ALTITUDE HOLD BAROMETER DECLARATION ************
1152:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1153:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(BMP085)
1154:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <BarometricSensor_BMP085.h>
1155:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(MS5611)
1156:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  #include <BarometricSensor_MS5611.h>
1157:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1158:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(XLMAXSONAR)
1159:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <MaxSonarRangeFinder.h>
1160:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif 
1161:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1162:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //*************** BATTERY MONITOR DECLARATION ************
1163:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1164:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef BattMonitor
1165:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <BatteryMonitor.h>
1166:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifndef BattCustomConfig
1167:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BattCustomConfig BattDefaultConfig
1168:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1169:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   struct BatteryData batteryData[] = {BattCustomConfig};
1170:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1171:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1172:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //************** CAMERA CONTROL DECLARATION **************
1173:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1174:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** // used only on mega for now
1175:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(CameraControl_STM32)
1176:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <CameraStabilizer_STM32.h>
1177:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(CameraControl)
1178:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <CameraStabilizer_Aeroquad.h>
1179:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1180:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1181:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined (CameraTXControl)
1182:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <CameraStabilizer_TXControl.h>
1183:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1184:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1185:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1186:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******** FLIGHT CONFIGURATION DECLARATION **************
1187:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1188:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(quadXConfig)
1189:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlQuadX.h"
1190:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(quadPlusConfig)
1191:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlQuadPlus.h"
1192:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(hexPlusConfig)
1193:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlHexPlus.h"
1194:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(hexXConfig)
1195:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlHexX.h"
1196:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(triConfig)
1197:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlTri.h"
1198:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(quadY4Config)
1199:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlQuadY4.h"
1200:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(hexY6Config)
1201:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlHexY6.h"
1202:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(octoX8Config)
1203:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlOctoX8.h"
1204:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(octoXConfig)
1205:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlOctoX.h"
1206:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(octoPlusConfig)
1207:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlOctoPlus.h"
1208:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1209:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1210:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1211:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************** GPS DECLARATION *********************
1212:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1213:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseGPS)
1214:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if !defined(HeadingMagHold)
1215:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #error We need the magnetometer to use the GPS
1216:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif 
1217:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <GpsAdapter.h>
1218:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "GpsNavigator.h"
1219:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1220:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1221:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1222:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************** OSD DEVICE DECLARATION **************
1223:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1224:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef MAX7456_OSD     // only OSD supported for now is the MAX7456
1225:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_SPI.h>
1226:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "OSDDisplayController.h"
1227:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "MAX7456.h"
1228:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1229:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1230:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(SERIAL_LCD)
1231:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "SerialLCD.h"
1232:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1233:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1234:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef OSD_SYSTEM_MENU
1235:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if !defined(MAX7456_OSD) && !defined(SERIAL_LCD)
1236:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #error "Menu cannot be used without OSD or LCD"
1237:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1238:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "OSDMenu.h"
1239:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1240:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1241:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1242:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1243:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************** SERIAL PORT DECLARATION *************
1244:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
1245:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(WirelessTelemetry) 
1246:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
1247:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SERIAL_PORT Serial3
1248:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else    // force 328p to use the normal port
1249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SERIAL_PORT Serial
1250:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1251:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #else  
1252:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(SERIAL_USES_USB)   // STM32 Maple
1253:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SERIAL_PORT SerialUSB
1254:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BAUD
1255:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BAUD
1256:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
1257:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SERIAL_PORT Serial
1258:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1259:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif  
1260:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1261:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef SlowTelemetry
1262:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <AQ_RSCode.h>
1263:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1264:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1265:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef SoftModem
1266:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <AQ_SoftModem.h>
1267:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1268:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1269:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1270:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** // Include this last as it contains objects from above declarations
1271:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "AltitudeControlProcessor.h"
1272:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "FlightControlProcessor.h"
1273:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "FlightCommandProcessor.h"
1274:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "HeadingHoldProcessor.h"
1275:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "DataStorage.h"
1276:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1277:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseGPS) || defined(BattMonitor)
1278:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "LedStatusProcessor.h"
1279:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif  
1280:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1281:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(MavLink)
1282:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "MavLink.h"
1283:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #else
1284:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "SerialCom.h"
1285:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
1286:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1287:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1288:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1289:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
1290:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * Main setup function, called one time at bootup
1291:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * initialize all system and sub system of the
1292:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * Aeroquad
1293:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
1294:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void setup() {
1295:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   SERIAL_BEGIN(BAUD);
1296:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   pinMode(LED_Green, OUTPUT);
1297:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   digitalWrite(LED_Green, LOW);
1298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1299:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initCommunication();
1300:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1301:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readEEPROM(); // defined in DataStorage.h
1302:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   boolean firstTimeBoot = false;
1303:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (readFloat(SOFTWARE_VERSION_ADR) != SOFTWARE_VERSION) { // If we detect the wrong soft version
1304:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeEEPROM();
1305:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     writeEEPROM();
1306:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     firstTimeBoot = true;
1307:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
1308:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1309:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initPlatform();
1310:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1311:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config) || defined(triConfig
1312:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      initializeMotors(FOUR_Motors);
1313:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #elif defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Config)
1314:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      initializeMotors(SIX_Motors);
1315:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #elif defined(octoX8Config) || defined(octoXConfig) || defined(octoPlusConfig)
1316:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      initializeMotors(EIGHT_Motors);
1317:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1318:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeReceiver(LASTCHANNEL);
1320:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initReceiverFromEEPROM();
1321:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Initialize sensors
1323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // If sensors have a common initialization routine
1324:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // insert it into the gyro class because it executes first
1325:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeGyro(); // defined in Gyro.h
1326:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   while (!calibrateGyro()); // this make sure the craft is still befor to continue init process
1327:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeAccel(); // defined in Accel.h
1328:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (firstTimeBoot) {
1329:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     computeAccelBias();
1330:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     writeEEPROM();
1331:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
1332:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   setupFourthOrder();
1333:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initSensorsZeroFromEEPROM();
1334:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1335:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Integral Limit for attitude mode
1336:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // This overrides default set in readEEPROM()
1337:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Set for 1/2 max attitude command (+/-0.75 radians)
1338:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Rate integral not used for now
1339:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PID[ATTITUDE_XAXIS_PID_IDX].windupGuard = 0.375;
1340:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PID[ATTITUDE_YAXIS_PID_IDX].windupGuard = 0.375;
1341:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1342:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Flight angle estimation
1343:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeKinematics();
1344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1345:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef HeadingMagHold
1346:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= HEADINGHOLD_ENABLED;
1347:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeMagnetometer();
1348:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeHeadingFusion();
1349:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1350:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1351:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Optional Sensors
1352:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldBaro
1353:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeBaro();
1354:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
1355:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1356:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
1357:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     inititalizeRangeFinders();
1358:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= RANGE_ENABLED;
1359:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = PID[BARO_ALTITUDE_HOLD_PID_IDX].P*2;
1360:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = PID[BARO_ALTITUDE_HOLD_PID_IDX].I;
1361:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = PID[BARO_ALTITUDE_HOLD_PID_IDX].D;
1362:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard;
1363:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1364:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1365:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
1366:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeBatteryMonitor(sizeof(batteryData) / sizeof(struct BatteryData), batteryMonitorAlarmV
1367:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= BATTMONITOR_ENABLED;
1368:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1369:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1370:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(CameraControl)
1371:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeCameraStabilization();
1372:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= CAMERASTABLE_ENABLED;
1373:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1374:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1375:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(MAX7456_OSD)
1376:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeSPI();
1377:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeOSD();
1378:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1379:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1380:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(SERIAL_LCD)
1381:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     InitSerialLCD();
1382:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1383:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1384:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(BinaryWrite) || defined(BinaryWritePID)
1385:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef OpenlogBinaryWrite
1386:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       binaryPort = &Serial1;
1387:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       binaryPort->begin(115200);
1388:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       delay(1000);
1389:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #else
1390:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      binaryPort = &Serial;
1391:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
1392:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1393:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1394:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(UseGPS)
1395:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeGps();
1396:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif 
1397:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1398:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef SlowTelemetry
1399:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      initSlowTelemetry();
1400:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1401:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1402:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   previousTime = micros();
1403:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   digitalWrite(LED_Green, HIGH);
1404:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   safetyCheck = 0;
1405:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
1406:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1407:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1408:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
1409:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * 100Hz task
1410:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
1411:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process100HzTask() {
1412:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
1414:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hundredHZpreviousTime = currentTime;
1415:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1416:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateGyroRate();
1417:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateMetersPerSec();
1418:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1419:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
1420:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
1421:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
1422:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1423:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   calculateKinematics(gyroRate[XAXIS], gyroRate[YAXIS], gyroRate[ZAXIS], filteredAccel[XAXIS], filt
1424:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1425:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
1426:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     zVelocity = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + isq(fi
1427:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (!runtimaZBiasInitialized) {
1428:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       runtimeZBias = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + i
1429:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       runtimaZBiasInitialized = true;
1430:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1431:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity += zVelocity;
1432:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity = (velocityCompFilter1 * zVelocity) + (velocityCompFilter2 * estimatedZVeloc
1433:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif    
1434:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1435:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(AltitudeHoldBaro)
1436:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureBaroSum(); 
1437:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % THROTTLE_ADJUST_TASK_SPEED == 0) {  //  50 Hz tasks
1438:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       evaluateBaroAltitude();
1439:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1440:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1441:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         
1442:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   processFlightControl();
1443:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1444:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1445:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(BinaryWrite)
1446:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (fastTransfer == ON) {
1447:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       // write out fastTelemetry to Configurator or openLog
1448:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       fastTelemetry();
1449:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1450:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif      
1451:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1452:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef SlowTelemetry
1453:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     updateSlowTelemetry100Hz();
1454:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1455:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1456:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(UseGPS)
1457:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     updateGps();
1458:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif      
1459:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1460:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(CameraControl)
1461:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     moveCamera(kinematicsAngle[YAXIS],kinematicsAngle[XAXIS],kinematicsAngle[ZAXIS]);
1462:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #if defined CameraTXControl
1463:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       processCameraTXControl();
1464:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
1465:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif       
1466:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1467:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
1468:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1469:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
1470:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * 50Hz task
1471:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
1472:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process50HzTask() {
1473:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
1474:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   fiftyHZpreviousTime = currentTime;
1475:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1476:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Reads external pilot commands and performs functions based on stick configuration
1477:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readPilotCommands(); 
1478:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1479:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(UseAnalogRSSIReader) || defined(UseEzUHFRSSIReader) || defined(UseSBUSRSSIReader)
1480:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     readRSSI();
1481:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1482:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1483:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
1484:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     updateRangeFinders();
1485:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1486:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1487:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(UseGPS)
1488:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (haveAGpsLock() && !isHomeBaseInitialized()) {
1489:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       initHomeBase();
1490:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1491:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif      
1492:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
1493:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1494:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
1495:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * 10Hz task
1496:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
1497:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask1() {
1498:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1499:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(HeadingMagHold)
1500:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1501:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
1502:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     tenHZpreviousTime = currentTime;
1503:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      
1504:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureMagnetometer(kinematicsAngle[XAXIS], kinematicsAngle[YAXIS]);
1505:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1506:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     calculateHeading();
1507:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1508:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1509:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
1510:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1511:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
1512:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * low priority 10Hz task 2
1513:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
1514:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask2() {
1515:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
1516:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   lowPriorityTenHZpreviousTime = currentTime;
1517:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1518:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(BattMonitor)
1519:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureBatteryVoltage(G_Dt*1000.0);
1520:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1521:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1522:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Listen for configuration commands and reports telemetry
1523:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readSerialCommand();
1524:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   sendSerialTelemetry();
1525:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
1526:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1527:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
1528:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * low priority 10Hz task 3
1529:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
1530:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask3() {
1531:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
1532:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     lowPriorityTenHZpreviousTime2 = currentTime;
1533:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1534:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef OSD_SYSTEM_MENU
1535:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       updateOSDMenu();
1536:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
1537:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1538:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef MAX7456_OSD
1539:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       updateOSD();
1540:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
1541:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1542:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #if defined(UseGPS) || defined(BattMonitor)
1543:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       processLedStatus();
1544:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
1545:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1546:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef SlowTelemetry
1547:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       updateSlowTelemetry10Hz();
1548:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
1549:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
1550:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1551:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
1552:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * 1Hz task 
1553:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
1554:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process1HzTask() {
1555:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef MavLink
1556:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - oneHZpreviousTime) / 1000000.0;
1557:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     oneHZpreviousTime = currentTime;
1558:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1559:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     sendSerialHeartbeat();   
1560:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
1561:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
1562:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1563:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
1564:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * Main loop funtions
1565:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
1566:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void loop () {
1567:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1568:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   currentTime = micros();
1569:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
1570:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1571:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   measureCriticalSensors();
1572:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1573:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // ================================================================
1574:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // 100Hz task loop
1575:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // ================================================================
1576:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (deltaTime >= 10000) {
1577:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1578:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     frameCounter++;
1579:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1580:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     process100HzTask();
1581:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1582:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
1583:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // 50Hz task loop
1584:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
1585:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_50HZ == 0) {  //  50 Hz tasks
1586:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process50HzTask();
1587:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1588:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
1589:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
1590:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // 10Hz task loop
1591:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
1592:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_10HZ == 0) {  //   10 Hz tasks
1593:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask1();
1594:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1595:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime) > 100000) {
1596:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask2();
1597:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1598:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime2) > 100000) {
1599:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask3();
1600:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1601:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1602:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
1603:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // 1Hz task loop
1604:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
1605:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_1HZ == 0) {  //   1 Hz tasks
1606:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process1HzTask();
1607:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
1608:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
1609:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     previousTime = currentTime;
1610:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
1611:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
1612:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (frameCounter >= 100) {
1613:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       frameCounter = 0;
1614:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
1615:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 4170              		.loc 18 1615 0 discriminator 2
 4171 001a 5968     		ldr	r1, [r3, #4]
 4172              		.loc 17 75 0 discriminator 2
 4173 001c 0868     		ldr	r0, [r1, #0]
 4174 001e 597B     		ldrb	r1, [r3, #13]	@ zero_extendqisi2
 4175 0020 FFF7FEFF 		bl	timer_set_compare.isra.2
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4176              		.loc 17 74 0 discriminator 2
 4177 0024 0134     		adds	r4, r4, #1
 4178              	.LVL208:
 4179              	.L229:
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4180              		.loc 17 74 0 is_stmt 0 discriminator 1
 4181 0026 0549     		ldr	r1, .L231+12
 4182 0028 0B68     		ldr	r3, [r1, #0]
 4183 002a 9C42     		cmp	r4, r3
 4184 002c ECDB     		blt	.L230
 4185              	.LBE96:
  76:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  77:../Libraries/AQ_Motors/Motors_STM32.h **** }
 4186              		.loc 17 77 0 is_stmt 1
 4187 002e 38BD     		pop	{r3, r4, r5, pc}
 4188              	.L232:
 4189              		.align	2
 4190              	.L231:
 4191 0030 FCFFFFFF 		.word	.LANCHOR56-4
 4192 0034 00000000 		.word	.LANCHOR57
 4193 0038 00000000 		.word	PIN_MAP
 4194 003c 00000000 		.word	.LANCHOR58
 4195              		.cfi_endproc
 4196              	.LFE189:
 4198              		.section	.text._Z16commandAllMotorsi,"ax",%progbits
 4199              		.align	1
 4200              		.global	_Z16commandAllMotorsi
 4201              		.thumb
 4202              		.thumb_func
 4204              	_Z16commandAllMotorsi:
 4205              	.LFB190:
  78:../Libraries/AQ_Motors/Motors_STM32.h **** 
  79:../Libraries/AQ_Motors/Motors_STM32.h **** void commandAllMotors(int _motorCommand) {   // Send same command to all motors
 4206              		.loc 17 79 0
 4207              		.cfi_startproc
 4208              		@ args = 0, pretend = 0, frame = 0
 4209              		@ frame_needed = 0, uses_anonymous_args = 0
 4210              	.LVL209:
 4211 0000 38B5     		push	{r3, r4, r5, lr}
 4212              	.LCFI40:
 4213              		.cfi_def_cfa_offset 16
 4214              		.cfi_offset 14, -4
 4215              		.cfi_offset 5, -8
 4216              		.cfi_offset 4, -12
 4217              		.cfi_offset 3, -16
 4218              		.loc 17 79 0
 4219 0002 0546     		mov	r5, r0
 4220              	.LBB97:
  80:../Libraries/AQ_Motors/Motors_STM32.h **** 
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4221              		.loc 17 81 0
 4222 0004 0024     		movs	r4, #0
 4223 0006 0BE0     		b	.L234
 4224              	.LVL210:
 4225              	.L235:
  82:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_compare(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PIN_MAP[STM32_MOTOR_MAP[motor]]
 4226              		.loc 17 82 0 discriminator 2
 4227 0008 084B     		ldr	r3, .L236
 4228 000a 0948     		ldr	r0, .L236+4
 4229 000c E15C     		ldrb	r1, [r4, r3]	@ zero_extendqisi2
 4230 000e 00EB0113 		add	r3, r0, r1, lsl #4
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4231              		.loc 17 81 0 discriminator 2
 4232 0012 0134     		adds	r4, r4, #1
 4233              	.LVL211:
 4234              		.loc 18 1615 0 discriminator 2
 4235 0014 5A68     		ldr	r2, [r3, #4]
 4236              		.loc 17 82 0 discriminator 2
 4237 0016 597B     		ldrb	r1, [r3, #13]	@ zero_extendqisi2
 4238 0018 1068     		ldr	r0, [r2, #0]
 4239 001a AAB2     		uxth	r2, r5
 4240 001c FFF7FEFF 		bl	timer_set_compare.isra.2
 4241              	.LVL212:
 4242              	.L234:
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4243              		.loc 17 81 0 discriminator 1
 4244 0020 0448     		ldr	r0, .L236+8
 4245 0022 0268     		ldr	r2, [r0, #0]
 4246 0024 9442     		cmp	r4, r2
 4247 0026 EFDB     		blt	.L235
 4248              	.LBE97:
  83:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  84:../Libraries/AQ_Motors/Motors_STM32.h **** }
 4249              		.loc 17 84 0
 4250 0028 38BD     		pop	{r3, r4, r5, pc}
 4251              	.L237:
 4252 002a 00BF     		.align	2
 4253              	.L236:
 4254 002c 00000000 		.word	.LANCHOR57
 4255 0030 00000000 		.word	PIN_MAP
 4256 0034 00000000 		.word	.LANCHOR58
 4257              		.cfi_endproc
 4258              	.LFE190:
 4260              		.section	.text._Z16initializeMotors9NB_Motors,"ax",%progbits
 4261              		.align	1
 4262              		.global	_Z16initializeMotors9NB_Motors
 4263              		.thumb
 4264              		.thumb_func
 4266              	_Z16initializeMotors9NB_Motors:
 4267              	.LFB188:
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
 4268              		.loc 17 33 0
 4269              		.cfi_startproc
 4270              		@ args = 0, pretend = 0, frame = 0
 4271              		@ frame_needed = 0, uses_anonymous_args = 0
 4272              	.LVL213:
 4273 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4274              	.LCFI41:
 4275              		.cfi_def_cfa_offset 24
 4276              		.cfi_offset 14, -4
 4277              		.cfi_offset 7, -8
 4278              		.cfi_offset 6, -12
 4279              		.cfi_offset 5, -16
 4280              		.cfi_offset 4, -20
 4281              		.cfi_offset 3, -24
 4282 0002 1D4E     		ldr	r6, .L244
 4283              	.LBB98:
  39:../Libraries/AQ_Motors/Motors_STM32.h ****     _stm32_motor_number = numbers;
 4284              		.loc 17 39 0
 4285 0004 0728     		cmp	r0, #7
 4286 0006 C8BF     		it	gt
 4287 0008 0820     		movgt	r0, #8
 4288              	.LVL214:
 4289 000a 3060     		str	r0, [r6, #0]
 4290              	.LBE98:
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
 4291              		.loc 17 33 0
 4292 000c 0024     		movs	r4, #0
 4293 000e 1CE0     		b	.L240
 4294              	.LVL215:
 4295              	.L241:
 4296              	.LBB102:
 4297              	.LBB99:
 4298              	.LBB100:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 4299              		.loc 17 44 0 discriminator 2
 4300 0010 1A4F     		ldr	r7, .L244+4
 4301 0012 1B4D     		ldr	r5, .L244+8
 4302 0014 E75D     		ldrb	r7, [r4, r7]	@ zero_extendqisi2
 4303 0016 05EB0715 		add	r5, r5, r7, lsl #4
 4304              	.LBE100:
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4305              		.loc 17 42 0 discriminator 2
 4306 001a 0134     		adds	r4, r4, #1
 4307              	.LVL216:
 4308              	.LBB101:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 4309              		.loc 17 44 0 discriminator 2
 4310 001c 6968     		ldr	r1, [r5, #4]
 4311 001e 0879     		ldrb	r0, [r1, #4]	@ zero_extendqisi2
 4312 0020 FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 4313              	.LVL217:
 4314 0024 174B     		ldr	r3, .L244+12
 4315              		.loc 18 1615 0 discriminator 2
 4316 0026 6A68     		ldr	r2, [r5, #4]
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 4317              		.loc 17 44 0 discriminator 2
 4318 0028 B0FBF3F0 		udiv	r0, r0, r3
 4319              	.LVL218:
 4320 002c 411E     		subs	r1, r0, #1
 4321              	.LVL219:
  46:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_prescaler(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, prescaler);
 4322              		.loc 17 46 0 discriminator 2
 4323 002e 89B2     		uxth	r1, r1
 4324              	.LVL220:
 4325 0030 1068     		ldr	r0, [r2, #0]
 4326 0032 FFF7FEFF 		bl	timer_set_prescaler.isra.0
 4327              		.loc 18 1615 0 discriminator 2
 4328 0036 6B68     		ldr	r3, [r5, #4]
  57:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_PERIODE);
 4329              		.loc 17 57 0 discriminator 2
 4330 0038 40F6C411 		movw	r1, #2500
 4331 003c 1868     		ldr	r0, [r3, #0]
 4332 003e FFF7FEFF 		bl	timer_set_reload.isra.1
  60:../Libraries/AQ_Motors/Motors_STM32.h ****     pinMode(STM32_MOTOR_MAP[motor], PWM);
 4333              		.loc 17 60 0 discriminator 2
 4334 0042 3846     		mov	r0, r7
 4335 0044 0721     		movs	r1, #7
 4336 0046 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 4337              	.LVL221:
 4338              	.L240:
 4339              	.LBE101:
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4340              		.loc 17 42 0 discriminator 1
 4341 004a 3568     		ldr	r5, [r6, #0]
 4342 004c AC42     		cmp	r4, r5
 4343 004e DFDB     		blt	.L241
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4344              		.loc 17 42 0 is_stmt 0
 4345 0050 0024     		movs	r4, #0
 4346              	.LVL222:
 4347 0052 09E0     		b	.L242
 4348              	.LVL223:
 4349              	.L243:
 4350              	.LBE99:
  65:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_generate_update(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device);
 4351              		.loc 17 65 0 is_stmt 1 discriminator 2
 4352 0054 094A     		ldr	r2, .L244+4
 4353 0056 0A4B     		ldr	r3, .L244+8
 4354 0058 A15C     		ldrb	r1, [r4, r2]	@ zero_extendqisi2
 4355 005a 03EB0110 		add	r0, r3, r1, lsl #4
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4356              		.loc 17 64 0 discriminator 2
 4357 005e 0134     		adds	r4, r4, #1
 4358              	.LVL224:
 4359              		.loc 18 1615 0 discriminator 2
 4360 0060 4268     		ldr	r2, [r0, #4]
  65:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_generate_update(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device);
 4361              		.loc 17 65 0 discriminator 2
 4362 0062 1068     		ldr	r0, [r2, #0]
 4363 0064 FFF7FEFF 		bl	timer_generate_update.isra.3
 4364              	.LVL225:
 4365              	.L242:
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4366              		.loc 17 64 0 discriminator 1
 4367 0068 AC42     		cmp	r4, r5
 4368 006a F3DB     		blt	.L243
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
 4369              		.loc 17 68 0
 4370 006c 4FF47A70 		mov	r0, #1000
 4371              	.LBE102:
  70:../Libraries/AQ_Motors/Motors_STM32.h **** }
 4372              		.loc 17 70 0
 4373 0070 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 4374              	.LBB103:
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
 4375              		.loc 17 68 0
 4376 0074 FFF7FEBF 		b	_Z16commandAllMotorsi
 4377              	.L245:
 4378              		.align	2
 4379              	.L244:
 4380 0078 00000000 		.word	.LANCHOR58
 4381 007c 00000000 		.word	.LANCHOR57
 4382 0080 00000000 		.word	PIN_MAP
 4383 0084 40420F00 		.word	1000000
 4384              	.LBE103:
 4385              		.cfi_endproc
 4386              	.LFE188:
 4388              		.section	.text._Z11pulseMotorsh,"ax",%progbits
 4389              		.align	1
 4390              		.global	_Z11pulseMotorsh
 4391              		.thumb
 4392              		.thumb_func
 4394              	_Z11pulseMotorsh:
 4395              	.LFB187:
 4396              		.file 19 "../Libraries/AQ_Motors/Motors.h"
   1:../Libraries/AQ_Motors/Motors.h **** /*
   2:../Libraries/AQ_Motors/Motors.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Motors/Motors.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Motors/Motors.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Motors/Motors.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Motors/Motors.h ****  
   7:../Libraries/AQ_Motors/Motors.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Motors/Motors.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Motors/Motors.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Motors/Motors.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Motors/Motors.h **** 
  12:../Libraries/AQ_Motors/Motors.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Motors/Motors.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Motors/Motors.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Motors/Motors.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Motors/Motors.h **** 
  17:../Libraries/AQ_Motors/Motors.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Motors/Motors.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Motors/Motors.h **** */
  20:../Libraries/AQ_Motors/Motors.h **** 
  21:../Libraries/AQ_Motors/Motors.h **** 
  22:../Libraries/AQ_Motors/Motors.h **** #ifndef _AEROQUAD_MOTORS_H_
  23:../Libraries/AQ_Motors/Motors.h **** #define _AEROQUAD_MOTORS_H_
  24:../Libraries/AQ_Motors/Motors.h **** 
  25:../Libraries/AQ_Motors/Motors.h **** #include "Arduino.h"
  26:../Libraries/AQ_Motors/Motors.h **** 
  27:../Libraries/AQ_Motors/Motors.h **** #define MOTOR1 0
  28:../Libraries/AQ_Motors/Motors.h **** #define MOTOR2 1
  29:../Libraries/AQ_Motors/Motors.h **** #define MOTOR3 2
  30:../Libraries/AQ_Motors/Motors.h **** #define MOTOR4 3
  31:../Libraries/AQ_Motors/Motors.h **** #define MOTOR5 4
  32:../Libraries/AQ_Motors/Motors.h **** #define MOTOR6 5
  33:../Libraries/AQ_Motors/Motors.h **** #define MOTOR7 6
  34:../Libraries/AQ_Motors/Motors.h **** #define MOTOR8 7
  35:../Libraries/AQ_Motors/Motors.h **** #define MINCOMMAND 1000
  36:../Libraries/AQ_Motors/Motors.h **** #define MAXCOMMAND 2000
  37:../Libraries/AQ_Motors/Motors.h **** 
  38:../Libraries/AQ_Motors/Motors.h **** enum NB_Motors{
  39:../Libraries/AQ_Motors/Motors.h ****   FOUR_Motors = 4,
  40:../Libraries/AQ_Motors/Motors.h ****   SIX_Motors = 6,
  41:../Libraries/AQ_Motors/Motors.h ****   EIGHT_Motors = 8
  42:../Libraries/AQ_Motors/Motors.h **** };
  43:../Libraries/AQ_Motors/Motors.h **** 
  44:../Libraries/AQ_Motors/Motors.h **** NB_Motors numberOfMotors = FOUR_Motors;
  45:../Libraries/AQ_Motors/Motors.h **** int motorCommand[8] = {0,0,0,0,0,0,0,0};  // LASTMOTOR not know here, so, default at 8 @todo : Kenn
  46:../Libraries/AQ_Motors/Motors.h ****   
  47:../Libraries/AQ_Motors/Motors.h **** void initializeMotors(NB_Motors numbers = FOUR_Motors);
  48:../Libraries/AQ_Motors/Motors.h **** void writeMotors();
  49:../Libraries/AQ_Motors/Motors.h **** void commandAllMotors(int command);
  50:../Libraries/AQ_Motors/Motors.h **** 
  51:../Libraries/AQ_Motors/Motors.h **** void pulseMotors(byte nbPulse) {
 4397              		.loc 19 51 0
 4398              		.cfi_startproc
 4399              		@ args = 0, pretend = 0, frame = 0
 4400              		@ frame_needed = 0, uses_anonymous_args = 0
 4401              	.LVL226:
 4402 0000 38B5     		push	{r3, r4, r5, lr}
 4403              	.LCFI42:
 4404              		.cfi_def_cfa_offset 16
 4405              		.cfi_offset 14, -4
 4406              		.cfi_offset 5, -8
 4407              		.cfi_offset 4, -12
 4408              		.cfi_offset 3, -16
 4409              		.loc 19 51 0
 4410 0002 0546     		mov	r5, r0
 4411              	.LBB104:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4412              		.loc 19 52 0
 4413 0004 0024     		movs	r4, #0
 4414 0006 0FE0     		b	.L247
 4415              	.LVL227:
 4416              	.L248:
  53:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND + 100);
 4417              		.loc 19 53 0 discriminator 2
 4418 0008 40F24C40 		movw	r0, #1100
 4419 000c FFF7FEFF 		bl	_Z16commandAllMotorsi
  54:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 4420              		.loc 19 54 0 discriminator 2
 4421 0010 FA20     		movs	r0, #250
 4422 0012 FFF7FEFF 		bl	_Z5delaym
  55:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND);
 4423              		.loc 19 55 0 discriminator 2
 4424 0016 4FF47A70 		mov	r0, #1000
 4425 001a FFF7FEFF 		bl	_Z16commandAllMotorsi
  56:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 4426              		.loc 19 56 0 discriminator 2
 4427 001e FA20     		movs	r0, #250
 4428 0020 FFF7FEFF 		bl	_Z5delaym
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4429              		.loc 19 52 0 discriminator 2
 4430 0024 0134     		adds	r4, r4, #1
 4431              	.LVL228:
 4432 0026 E4B2     		uxtb	r4, r4
 4433              	.LVL229:
 4434              	.L247:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4435              		.loc 19 52 0 is_stmt 0 discriminator 1
 4436 0028 AC42     		cmp	r4, r5
 4437 002a EDD1     		bne	.L248
 4438              	.LBE104:
  57:../Libraries/AQ_Motors/Motors.h ****   }
  58:../Libraries/AQ_Motors/Motors.h **** }
 4439              		.loc 19 58 0 is_stmt 1
 4440 002c 38BD     		pop	{r3, r4, r5, pc}
 4441              		.cfi_endproc
 4442              	.LFE187:
 4444              		.section	.text._Z17cameraControlMoveiii,"ax",%progbits
 4445              		.align	1
 4446              		.global	_Z17cameraControlMoveiii
 4447              		.thumb
 4448              		.thumb_func
 4450              	_Z17cameraControlMoveiii:
 4451              	.LFB194:
 4452              		.file 20 "../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h"
   1:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** /*
   2:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   AeroQuad v3.1.x - August 2012
   3:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   www.AeroQuad.com
   4:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   Copyright (c) 2012 AeroQuad developers.  All rights reserved.
   5:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****  
   7:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   (at your option) any later version. 
  11:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  12:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  17:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** */
  20:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  21:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** #ifndef _AEROQUAD_CAMERA_STABILIZER_STM32_H_
  22:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** #define _AEROQUAD_CAMERA_STABILIZER_STM32_H_
  23:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  24:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** #if !defined(AeroQuadSTM32)
  25:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   #error This code only works on STM32
  26:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** #endif
  27:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  28:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** #include "CameraStabilizer.h"
  29:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  30:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** #define SERVO_FREQUENCY 50 // 50 Hz for analog servo
  31:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** //#define SERVO_FREQUENCY 400 // 300 Hz for digital high speed servo
  32:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  33:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** #define SERVO_PERIOD (1000000/SERVO_FREQUENCY)
  34:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  35:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** static byte servopins[3] = {
  36:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   Port2Pin('A', 2), // SRV1 -- TIM5CH3
  37:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   Port2Pin('A', 1), // SRV2 -- TIM5CH2
  38:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   Port2Pin('A', 0), // SRV3 -- TIM5CH1
  39:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** };
  40:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  41:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  42:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** void initializeCameraControl() {
  43:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  44:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   int servo;
  45:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  46:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   for ( servo = 0; servo < 3; servo++) {
  47:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[servopins[servo]].timer_device->clk_id)/1000000
  48:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     timer_set_prescaler(PIN_MAP[servopins[servo]].timer_device, prescaler);
  49:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     timer_set_reload(PIN_MAP[servopins[servo]].timer_device, SERVO_PERIOD);
  50:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     pinMode(servopins[servo], PWM);
  51:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   }
  52:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  53:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   for ( servo = 0; servo < 3; servo++) {
  54:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     timer_generate_update(PIN_MAP[servopins[servo]].timer_device);
  55:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   }
  56:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  57:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   cameraControlMove(1500,1500,1500);
  58:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** }
  59:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  60:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** void cameraControlMove(int servoPitch, int servoRoll, int servoYaw) {
 4453              		.loc 20 60 0
 4454              		.cfi_startproc
 4455              		@ args = 0, pretend = 0, frame = 0
 4456              		@ frame_needed = 0, uses_anonymous_args = 0
 4457              	.LVL230:
 4458 0000 70B5     		push	{r4, r5, r6, lr}
 4459              	.LCFI43:
 4460              		.cfi_def_cfa_offset 16
 4461              		.cfi_offset 14, -4
 4462              		.cfi_offset 6, -8
 4463              		.cfi_offset 5, -12
 4464              		.cfi_offset 4, -16
  61:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 
  62:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   timer_set_compare(PIN_MAP[servopins[0]].timer_device,
  63:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 		    PIN_MAP[servopins[0]].timer_channel,
  64:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 		    servoPitch);
 4465              		.loc 20 64 0
 4466 0002 0C4C     		ldr	r4, .L250
  60:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** void cameraControlMove(int servoPitch, int servoRoll, int servoYaw) {
 4467              		.loc 20 60 0
 4468 0004 0E46     		mov	r6, r1
 4469              		.loc 18 1615 0
 4470 0006 616A     		ldr	r1, [r4, #36]
 4471              	.LVL231:
  60:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** void cameraControlMove(int servoPitch, int servoRoll, int servoYaw) {
 4472              		.loc 20 60 0
 4473 0008 1546     		mov	r5, r2
 4474              		.loc 20 64 0
 4475 000a 82B2     		uxth	r2, r0
 4476              	.LVL232:
 4477 000c 0868     		ldr	r0, [r1, #0]
 4478              	.LVL233:
 4479 000e 94F82D10 		ldrb	r1, [r4, #45]	@ zero_extendqisi2
 4480 0012 FFF7FEFF 		bl	timer_set_compare.isra.2
 4481              		.loc 18 1615 0
 4482 0016 6069     		ldr	r0, [r4, #20]
  65:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   timer_set_compare(PIN_MAP[servopins[1]].timer_device,
  66:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 		    PIN_MAP[servopins[1]].timer_channel,
  67:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 		    servoRoll);
 4483              		.loc 20 67 0
 4484 0018 617F     		ldrb	r1, [r4, #29]	@ zero_extendqisi2
 4485 001a 0068     		ldr	r0, [r0, #0]
 4486 001c B2B2     		uxth	r2, r6
 4487 001e FFF7FEFF 		bl	timer_set_compare.isra.2
 4488              		.loc 18 1615 0
 4489 0022 6368     		ldr	r3, [r4, #4]
  68:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   timer_set_compare(PIN_MAP[servopins[2]].timer_device,
  69:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 		    PIN_MAP[servopins[2]].timer_channel,
  70:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 		    servoYaw);
 4490              		.loc 20 70 0
 4491 0024 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 4492 0026 1868     		ldr	r0, [r3, #0]
 4493 0028 AAB2     		uxth	r2, r5
  71:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** }
 4494              		.loc 20 71 0
 4495 002a BDE87040 		pop	{r4, r5, r6, lr}
  70:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** 		    servoYaw);
 4496              		.loc 20 70 0
 4497 002e FFF7FEBF 		b	timer_set_compare.isra.2
 4498              	.L251:
 4499 0032 00BF     		.align	2
 4500              	.L250:
 4501 0034 00000000 		.word	PIN_MAP
 4502              		.cfi_endproc
 4503              	.LFE194:
 4505              		.section	.text._Z23initializeCameraControlv,"ax",%progbits
 4506              		.align	1
 4507              		.global	_Z23initializeCameraControlv
 4508              		.thumb
 4509              		.thumb_func
 4511              	_Z23initializeCameraControlv:
 4512              	.LFB193:
  42:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** void initializeCameraControl() {
 4513              		.loc 20 42 0
 4514              		.cfi_startproc
 4515              		@ args = 0, pretend = 0, frame = 0
 4516              		@ frame_needed = 0, uses_anonymous_args = 0
 4517              	.LVL234:
 4518 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 4519              	.LCFI44:
 4520              		.cfi_def_cfa_offset 24
 4521              		.cfi_offset 14, -4
 4522              		.cfi_offset 8, -8
 4523              		.cfi_offset 7, -12
 4524              		.cfi_offset 6, -16
 4525              		.cfi_offset 5, -20
 4526              		.cfi_offset 4, -24
  46:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   for ( servo = 0; servo < 3; servo++) {
 4527              		.loc 20 46 0
 4528 0004 0024     		movs	r4, #0
 4529              	.LVL235:
 4530              	.L253:
 4531              	.LBB105:
 4532              	.LBB106:
 4533              	.LBB107:
  47:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[servopins[servo]].timer_device->clk_id)/1000000
 4534              		.loc 20 47 0 discriminator 2
 4535 0006 1A4F     		ldr	r7, .L257
 4536 0008 1A4E     		ldr	r6, .L257+4
 4537 000a 14F80780 		ldrb	r8, [r4, r7]	@ zero_extendqisi2
 4538 000e 06EB0815 		add	r5, r6, r8, lsl #4
 4539              	.LBE107:
  46:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   for ( servo = 0; servo < 3; servo++) {
 4540              		.loc 20 46 0 discriminator 2
 4541 0012 0134     		adds	r4, r4, #1
 4542              	.LBB108:
  47:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[servopins[servo]].timer_device->clk_id)/1000000
 4543              		.loc 20 47 0 discriminator 2
 4544 0014 6968     		ldr	r1, [r5, #4]
 4545 0016 0879     		ldrb	r0, [r1, #4]	@ zero_extendqisi2
 4546 0018 FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 4547              	.LVL236:
 4548 001c 164B     		ldr	r3, .L257+8
 4549              		.loc 18 1615 0 discriminator 2
 4550 001e 6A68     		ldr	r2, [r5, #4]
  47:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[servopins[servo]].timer_device->clk_id)/1000000
 4551              		.loc 20 47 0 discriminator 2
 4552 0020 B0FBF3F0 		udiv	r0, r0, r3
 4553              	.LVL237:
 4554 0024 411E     		subs	r1, r0, #1
 4555              	.LVL238:
  48:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     timer_set_prescaler(PIN_MAP[servopins[servo]].timer_device, prescaler);
 4556              		.loc 20 48 0 discriminator 2
 4557 0026 89B2     		uxth	r1, r1
 4558              	.LVL239:
 4559 0028 1068     		ldr	r0, [r2, #0]
 4560 002a FFF7FEFF 		bl	timer_set_prescaler.isra.0
 4561              		.loc 18 1615 0 discriminator 2
 4562 002e 6B68     		ldr	r3, [r5, #4]
  49:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     timer_set_reload(PIN_MAP[servopins[servo]].timer_device, SERVO_PERIOD);
 4563              		.loc 20 49 0 discriminator 2
 4564 0030 44F62061 		movw	r1, #20000
 4565 0034 1868     		ldr	r0, [r3, #0]
 4566 0036 FFF7FEFF 		bl	timer_set_reload.isra.1
  50:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     pinMode(servopins[servo], PWM);
 4567              		.loc 20 50 0 discriminator 2
 4568 003a 0721     		movs	r1, #7
 4569 003c 4046     		mov	r0, r8
 4570 003e FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 4571              	.LVL240:
 4572              	.LBE108:
  46:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   for ( servo = 0; servo < 3; servo++) {
 4573              		.loc 20 46 0 discriminator 2
 4574 0042 032C     		cmp	r4, #3
 4575 0044 DFD1     		bne	.L253
  46:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   for ( servo = 0; servo < 3; servo++) {
 4576              		.loc 20 46 0 is_stmt 0
 4577 0046 0024     		movs	r4, #0
 4578              	.LVL241:
 4579              	.L254:
 4580              	.LBE106:
  54:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     timer_generate_update(PIN_MAP[servopins[servo]].timer_device);
 4581              		.loc 20 54 0 is_stmt 1 discriminator 2
 4582 0048 17F804C0 		ldrb	ip, [r7, r4]	@ zero_extendqisi2
 4583 004c 06EB0C10 		add	r0, r6, ip, lsl #4
  53:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   for ( servo = 0; servo < 3; servo++) {
 4584              		.loc 20 53 0 discriminator 2
 4585 0050 0134     		adds	r4, r4, #1
 4586              		.loc 18 1615 0 discriminator 2
 4587 0052 4268     		ldr	r2, [r0, #4]
  54:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****     timer_generate_update(PIN_MAP[servopins[servo]].timer_device);
 4588              		.loc 20 54 0 discriminator 2
 4589 0054 1068     		ldr	r0, [r2, #0]
 4590 0056 FFF7FEFF 		bl	timer_generate_update.isra.3
 4591              	.LVL242:
  53:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   for ( servo = 0; servo < 3; servo++) {
 4592              		.loc 20 53 0 discriminator 2
 4593 005a 032C     		cmp	r4, #3
 4594 005c F4D1     		bne	.L254
  57:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   cameraControlMove(1500,1500,1500);
 4595              		.loc 20 57 0
 4596 005e 40F2DC50 		movw	r0, #1500
 4597 0062 0146     		mov	r1, r0
 4598 0064 0246     		mov	r2, r0
 4599              	.LBE105:
  58:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h **** }
 4600              		.loc 20 58 0
 4601 0066 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 4602              	.LBB109:
  57:../Libraries/AQ_CameraStabilizer/CameraStabilizer_STM32.h ****   cameraControlMove(1500,1500,1500);
 4603              		.loc 20 57 0
 4604 006a FFF7FEBF 		b	_Z17cameraControlMoveiii
 4605              	.L258:
 4606 006e 00BF     		.align	2
 4607              	.L257:
 4608 0070 00000000 		.word	.LANCHOR59
 4609 0074 00000000 		.word	PIN_MAP
 4610 0078 40420F00 		.word	1000000
 4611              	.LBE109:
 4612              		.cfi_endproc
 4613              	.LFE193:
 4615              		.section	.text._Z10moveCamerafff,"ax",%progbits
 4616              		.align	1
 4617              		.global	_Z10moveCamerafff
 4618              		.thumb
 4619              		.thumb_func
 4621              	_Z10moveCamerafff:
 4622              	.LFB191:
 4623              		.file 21 "../Libraries/AQ_CameraStabilizer/CameraStabilizer.h"
   1:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** /*
   2:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   www.AeroQuad.com
   4:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****  
   7:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   (at your option) any later version. 
  11:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  12:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  17:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** */
  20:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  21:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** #ifndef _AEROQUAD_CAMERA_STABILIZER_H_
  22:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** #define _AEROQUAD_CAMERA_STABILIZER_H_
  23:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  24:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  25:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** #if defined(CameraControl)
  26:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  27:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** // Written by CupOfTea:
  28:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** // http://aeroquad.com/showthread.php?1484-Camera-Stablisation
  29:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** // http://aeroquad.com/showthread.php?1491-Camera-Stablisation-continued
  30:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  31:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** // ***********************************************************************
  32:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** // *********************** Camera Control ***************************
  33:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** // ***********************************************************************
  34:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** /*Some basics about the 16 bit timer:
  35:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** - The timer counts clock ticks derived from the CPU clock. Using 16MHz CPU clock
  36:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   and a prescaler of 8 gives a timer clock of 2MHz, one tick every 0.5?s. This
  37:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   is also called timer resolution.
  38:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** - The timer is used as cyclic upwards counter, the counter periode is set in the
  39:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   ICRx register. IIRC periode-1 has to be set in the ICRx register.
  40:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** - When the counter reaches 0, the outputs are set
  41:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** - When the counter reaches OCRxy, the corresponding output is cleared.
  42:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** In the code below, the periode shall be 20ms, so the ICRx register is set to 
  43:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****  40000 ticks of 0.5?s/tick. It probably should be 39999, but who cares about
  44:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****  this 0.5?s for the periode.
  45:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** The high time shall be 1500?s, so the OCRxy register is set to 3000. A change of
  46:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****  the timer periode does not change this setting, as the clock rate is still one
  47:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****  tick every 0.5?s. If the prescaler was changed, the OCRxy register value would
  48:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****  be different. 
  49:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** */
  50:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  51:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int cameraMode;         // 0 = off,  1 = onboard stabilisation, 2 = serialCom/debug/adjust center 
  52:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** float mCameraPitch;     // scale angle...  the default 318.3 assumes that a rotation of
  53:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** float mCameraRoll;      //  +/- 90deg ie pi radians will move your hardware in the same ratio
  54:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** float mCameraYaw;
  55:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoCenterPitch;   // (bCamera) Center of stabilisation in mode 1,  point here in mode 2
  56:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoCenterRoll;
  57:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoCenterYaw;
  58:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoMinPitch;      // limit servo movement
  59:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoMinRoll;
  60:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoMinYaw;
  61:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoMaxPitch;
  62:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoMaxRoll;
  63:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** int servoMaxYaw;
  64:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   
  65:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** void initializeCameraControl();
  66:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** void cameraControlMove (int, int, int);
  67:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  68:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** void moveCamera(float anglePitch, float angleRoll, float angleYaw) {
 4624              		.loc 21 68 0
 4625              		.cfi_startproc
 4626              		@ args = 0, pretend = 0, frame = 0
 4627              		@ frame_needed = 0, uses_anonymous_args = 0
 4628              	.LVL243:
 4629 0000 06EE100A 		fmsr	s12, r0
  69:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   if (cameraMode == 1) {
 4630              		.loc 21 69 0
 4631 0004 5048     		ldr	r0, .L294
 4632              	.LVL244:
 4633 0006 0368     		ldr	r3, [r0, #0]
 4634 0008 5048     		ldr	r0, .L294+4
 4635 000a 012B     		cmp	r3, #1
  68:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** void moveCamera(float anglePitch, float angleRoll, float angleYaw) {
 4636              		.loc 21 68 0
 4637 000c 70B5     		push	{r4, r5, r6, lr}
 4638              	.LCFI45:
 4639              		.cfi_def_cfa_offset 16
 4640              		.cfi_offset 14, -4
 4641              		.cfi_offset 6, -8
 4642              		.cfi_offset 5, -12
 4643              		.cfi_offset 4, -16
  68:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** void moveCamera(float anglePitch, float angleRoll, float angleYaw) {
 4644              		.loc 21 68 0
 4645 000e 06EE901A 		fmsr	s13, r1
 4646 0012 05EE902A 		fmsr	s11, r2
 4647 0016 4E4D     		ldr	r5, .L294+8
 4648 0018 4E4C     		ldr	r4, .L294+12
 4649 001a 4F49     		ldr	r1, .L294+16
 4650              	.LVL245:
 4651 001c 4F4B     		ldr	r3, .L294+20
 4652 001e 504A     		ldr	r2, .L294+24
 4653              	.LVL246:
 4654              		.loc 21 69 0
 4655 0020 72D1     		bne	.L260
  70:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****     cameraControlMove(constrain((mCameraPitch * anglePitch) + servoCenterPitch , servoMinPitch , se
  71:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****                       constrain((mCameraRoll * angleRoll) + servoCenterRoll , servoMinRoll , servoM
  72:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****                       constrain((mCameraYaw * angleYaw) + servoCenterYaw , servoMinYaw , servoMaxYa
 4656              		.loc 21 72 0
 4657 0022 2D68     		ldr	r5, [r5, #0]
 4658 0024 4F4E     		ldr	r6, .L294+28
 4659 0026 0068     		ldr	r0, [r0, #0]
 4660 0028 05EE105A 		fmsr	s10, r5	@ int
 4661 002c 96ED000A 		flds	s0, [r6, #0]
 4662 0030 F8EEC57A 		fsitos	s15, s10
 4663 0034 46EE007A 		fmacs	s15, s12, s0
 4664 0038 07EE100A 		fmsr	s14, r0	@ int
 4665 003c B8EEC76A 		fsitos	s12, s14
 4666              	.LVL247:
 4667 0040 F4EEC67A 		fcmpes	s15, s12
 4668 0044 F1EE10FA 		fmstat
 4669 0048 0AD4     		bmi	.L291
 4670              	.L285:
 4671              		.loc 21 72 0 is_stmt 0 discriminator 2
 4672 004a 4748     		ldr	r0, .L294+32
 4673 004c 0068     		ldr	r0, [r0, #0]
 4674 004e 00EE900A 		fmsr	s1, r0	@ int
 4675 0052 B8EEE06A 		fsitos	s12, s1
 4676 0056 F4EEC67A 		fcmpes	s15, s12
 4677 005a F1EE10FA 		fmstat
 4678 005e 02DD     		ble	.L286
 4679              	.L291:
 4680              		.loc 21 72 0 discriminator 3
 4681 0060 BDEEC66A 		ftosizs	s12, s12
 4682 0064 01E0     		b	.L263
 4683              	.L286:
 4684              		.loc 21 72 0 discriminator 4
 4685 0066 BDEEE76A 		ftosizs	s12, s15
 4686              	.L263:
 4687              		.loc 21 72 0 discriminator 6
 4688 006a 4048     		ldr	r0, .L294+36
 4689 006c 0968     		ldr	r1, [r1, #0]
 4690 006e D0ED001A 		flds	s3, [r0, #0]
 4691 0072 2068     		ldr	r0, [r4, #0]
 4692 0074 02EE100A 		fmsr	s4, r0	@ int
 4693 0078 F8EEC27A 		fsitos	s15, s4
 4694 007c 46EEA17A 		fmacs	s15, s13, s3
 4695 0080 01EE101A 		fmsr	s2, r1	@ int
 4696 0084 F8EEC16A 		fsitos	s13, s2
 4697              	.LVL248:
 4698 0088 F4EEE67A 		fcmpes	s15, s13
 4699 008c F1EE10FA 		fmstat
 4700 0090 0AD4     		bmi	.L292
 4701              	.L287:
 4702              		.loc 21 72 0 discriminator 8
 4703 0092 3748     		ldr	r0, .L294+40
 4704 0094 0168     		ldr	r1, [r0, #0]
 4705 0096 02EE901A 		fmsr	s5, r1	@ int
 4706 009a F8EEE26A 		fsitos	s13, s5
 4707 009e F4EEE67A 		fcmpes	s15, s13
 4708 00a2 F1EE10FA 		fmstat
 4709 00a6 02DD     		ble	.L288
 4710              	.L292:
 4711              		.loc 21 72 0 discriminator 9
 4712 00a8 FDEEE66A 		ftosizs	s13, s13
 4713 00ac 01E0     		b	.L268
 4714              	.L288:
 4715              		.loc 21 72 0 discriminator 10
 4716 00ae FDEEE76A 		ftosizs	s13, s15
 4717              	.L268:
 4718              		.loc 21 72 0 discriminator 12
 4719 00b2 1B68     		ldr	r3, [r3, #0]
 4720 00b4 2F49     		ldr	r1, .L294+44
 4721 00b6 1268     		ldr	r2, [r2, #0]
 4722 00b8 03EE903A 		fmsr	s7, r3	@ int
 4723 00bc 91ED003A 		flds	s6, [r1, #0]
 4724 00c0 F8EEE37A 		fsitos	s15, s7
 4725 00c4 45EE837A 		fmacs	s15, s11, s6
 4726 00c8 05EE902A 		fmsr	s11, r2	@ int
 4727              	.LVL249:
 4728 00cc B8EEE57A 		fsitos	s14, s11
 4729 00d0 F4EEC77A 		fcmpes	s15, s14
 4730 00d4 F1EE10FA 		fmstat
 4731 00d8 0AD4     		bmi	.L293
 4732              	.L289:
 4733              		.loc 21 72 0 discriminator 14
 4734 00da 274A     		ldr	r2, .L294+48
 4735 00dc 1068     		ldr	r0, [r2, #0]
 4736 00de 04EE100A 		fmsr	s8, r0	@ int
 4737 00e2 B8EEC47A 		fsitos	s14, s8
 4738 00e6 F4EEC77A 		fcmpes	s15, s14
 4739 00ea F1EE10FA 		fmstat
 4740 00ee 02DD     		ble	.L290
 4741              	.L293:
 4742              		.loc 21 72 0 discriminator 15
 4743 00f0 BDEEC77A 		ftosizs	s14, s14
 4744 00f4 01E0     		b	.L273
 4745              	.L290:
 4746              		.loc 21 72 0 discriminator 16
 4747 00f6 BDEEE77A 		ftosizs	s14, s15
 4748              	.L273:
 4749              		.loc 21 72 0 discriminator 18
 4750 00fa 16EE100A 		fmrs	r0, s12	@ int
 4751 00fe 16EE901A 		fmrs	r1, s13	@ int
 4752 0102 17EE102A 		fmrs	r2, s14	@ int
 4753 0106 1AE0     		b	.L278
 4754              	.LVL250:
 4755              	.L260:
  73:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   }
  74:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   else {
  75:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****     cameraControlMove(constrain(servoCenterPitch , servoMinPitch , servoMaxPitch),
  76:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****                       constrain(servoCenterRoll , servoMinRoll , servoMaxRoll),
  77:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****                       constrain(servoCenterYaw , servoMinYaw , servoMaxYaw));
 4756              		.loc 21 77 0 is_stmt 1
 4757 0108 2D68     		ldr	r5, [r5, #0]
 4758 010a 0068     		ldr	r0, [r0, #0]
 4759 010c 8542     		cmp	r5, r0
 4760 010e 04DB     		blt	.L276
 4761              		.loc 21 77 0 is_stmt 0 discriminator 2
 4762 0110 1548     		ldr	r0, .L294+32
 4763 0112 0068     		ldr	r0, [r0, #0]
 4764 0114 8542     		cmp	r5, r0
 4765 0116 B8BF     		it	lt
 4766 0118 2846     		movlt	r0, r5
 4767              	.L276:
 4768              		.loc 21 77 0 discriminator 6
 4769 011a 2468     		ldr	r4, [r4, #0]
 4770 011c 0968     		ldr	r1, [r1, #0]
 4771 011e 8C42     		cmp	r4, r1
 4772 0120 04DB     		blt	.L277
 4773              		.loc 21 77 0 discriminator 8
 4774 0122 1349     		ldr	r1, .L294+40
 4775 0124 0968     		ldr	r1, [r1, #0]
 4776 0126 8C42     		cmp	r4, r1
 4777 0128 B8BF     		it	lt
 4778 012a 2146     		movlt	r1, r4
 4779              	.L277:
 4780              		.loc 21 77 0 discriminator 12
 4781 012c 1B68     		ldr	r3, [r3, #0]
 4782 012e 1268     		ldr	r2, [r2, #0]
 4783 0130 9342     		cmp	r3, r2
 4784 0132 04DB     		blt	.L278
 4785              		.loc 21 77 0 discriminator 14
 4786 0134 104A     		ldr	r2, .L294+48
 4787 0136 1268     		ldr	r2, [r2, #0]
 4788 0138 9342     		cmp	r3, r2
 4789 013a B8BF     		it	lt
 4790 013c 1A46     		movlt	r2, r3
 4791              	.LVL251:
 4792              	.L278:
  78:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   }
  79:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** }
 4793              		.loc 21 79 0 is_stmt 1 discriminator 18
 4794 013e BDE87040 		pop	{r4, r5, r6, lr}
  77:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****                       constrain(servoCenterYaw , servoMinYaw , servoMaxYaw));
 4795              		.loc 21 77 0 discriminator 18
 4796 0142 FFF7FEBF 		b	_Z17cameraControlMoveiii
 4797              	.L295:
 4798 0146 00BF     		.align	2
 4799              	.L294:
 4800 0148 00000000 		.word	.LANCHOR60
 4801 014c 00000000 		.word	.LANCHOR63
 4802 0150 00000000 		.word	.LANCHOR62
 4803 0154 00000000 		.word	.LANCHOR66
 4804 0158 00000000 		.word	.LANCHOR67
 4805 015c 00000000 		.word	.LANCHOR70
 4806 0160 00000000 		.word	.LANCHOR71
 4807 0164 00000000 		.word	.LANCHOR61
 4808 0168 00000000 		.word	.LANCHOR64
 4809 016c 00000000 		.word	.LANCHOR65
 4810 0170 00000000 		.word	.LANCHOR68
 4811 0174 00000000 		.word	.LANCHOR69
 4812 0178 00000000 		.word	.LANCHOR72
 4813              		.cfi_endproc
 4814              	.LFE191:
 4816              		.section	.text._Z29initializeCameraStabilizationv,"ax",%progbits
 4817              		.align	1
 4818              		.global	_Z29initializeCameraStabilizationv
 4819              		.thumb
 4820              		.thumb_func
 4822              	_Z29initializeCameraStabilizationv:
 4823              	.LFB192:
  80:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** 
  81:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** void initializeCameraStabilization() {
 4824              		.loc 21 81 0
 4825              		.cfi_startproc
 4826              		@ args = 0, pretend = 0, frame = 0
 4827              		@ frame_needed = 0, uses_anonymous_args = 0
 4828 0000 08B5     		push	{r3, lr}
 4829              	.LCFI46:
 4830              		.cfi_def_cfa_offset 8
 4831              		.cfi_offset 14, -4
 4832              		.cfi_offset 3, -8
  82:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   initializeCameraControl(); // specific init for timer chosen
 4833              		.loc 21 82 0
 4834 0002 FFF7FEFF 		bl	_Z23initializeCameraControlv
  83:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   moveCamera(0,0,0); 
 4835              		.loc 21 83 0
 4836 0006 0020     		movs	r0, #0
 4837 0008 0146     		mov	r1, r0	@ float
 4838 000a 0246     		mov	r2, r0	@ float
  84:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h **** }
 4839              		.loc 21 84 0
 4840 000c BDE80840 		pop	{r3, lr}
  83:../Libraries/AQ_CameraStabilizer/CameraStabilizer.h ****   moveCamera(0,0,0); 
 4841              		.loc 21 83 0
 4842 0010 FFF7FEBF 		b	_Z10moveCamerafff
 4843              		.cfi_endproc
 4844              	.LFE192:
 4846              		.section	.text._Z17applyMotorCommandv,"ax",%progbits
 4847              		.align	1
 4848              		.global	_Z17applyMotorCommandv
 4849              		.thumb
 4850              		.thumb_func
 4852              	_Z17applyMotorCommandv:
 4853              	.LFB195:
 4854              		.file 22 "../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h"
   1:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** /*
   2:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   www.AeroQuad.com
   4:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
   7:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   (at your option) any later version. 
  11:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
  12:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
  17:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** */
  20:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  21:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_X_MODE_H_
  22:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_X_MODE_H_
  23:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  24:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** /*
  25:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****        CW  0....Front....0 CCW
  26:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  27:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  28:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  29:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****       CCW  0....Back.....0  CW
  30:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** */
  31:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  32:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #include "FlightControlVariable.h"
  33:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  34:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #ifdef OLD_MOTOR_NUMBERING  
  35:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_LEFT  MOTOR1
  36:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_RIGHT  MOTOR2
  37:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_RIGHT MOTOR3
  38:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_LEFT   MOTOR4
  39:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #else
  40:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_LEFT  MOTOR1
  41:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_RIGHT MOTOR2
  42:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_RIGHT  MOTOR3
  43:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_LEFT   MOTOR4
  44:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #endif
  45:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #define LASTMOTOR   (MOTOR4+1)
  46:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  47:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorMaxCommand[4] = {0,0,0,0};
  48:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorMinCommand[4] = {0,0,0,0};
  49:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorConfiguratorCommand[4] = {0,0,0,0};
  50:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  51:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** void applyMotorCommand() {
 4855              		.loc 22 51 0
 4856              		.cfi_startproc
 4857              		@ args = 0, pretend = 0, frame = 0
 4858              		@ frame_needed = 0, uses_anonymous_args = 0
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 4859              		.loc 22 52 0
 4860 0000 0D48     		ldr	r0, .L298
 4861 0002 0E49     		ldr	r1, .L298+4
 4862 0004 0E4A     		ldr	r2, .L298+8
 4863 0006 0F4B     		ldr	r3, .L298+12
  51:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** void applyMotorCommand() {
 4864              		.loc 22 51 0
 4865 0008 70B5     		push	{r4, r5, r6, lr}
 4866              	.LCFI47:
 4867              		.cfi_def_cfa_offset 16
 4868              		.cfi_offset 14, -4
 4869              		.cfi_offset 6, -8
 4870              		.cfi_offset 5, -12
 4871              		.cfi_offset 4, -16
 4872              		.loc 22 52 0
 4873 000a 0468     		ldr	r4, [r0, #0]
 4874 000c 0868     		ldr	r0, [r1, #0]
 4875 000e 1168     		ldr	r1, [r2, #0]
 4876 0010 1A68     		ldr	r2, [r3, #0]
 4877 0012 0D4B     		ldr	r3, .L298+16
 4878 0014 C0EB040C 		rsb	ip, r0, r4
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 4879              		.loc 22 54 0
 4880 0018 2018     		adds	r0, r4, r0
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 4881              		.loc 22 52 0
 4882 001a 0CEB0106 		add	r6, ip, r1
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 4883              		.loc 22 53 0
 4884 001e C1EB0C05 		rsb	r5, r1, ip
 4885              		.loc 22 54 0
 4886 0022 4418     		adds	r4, r0, r1
  55:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_RIGHT]  = throttle + motorAxisCommandPitch - motorAxisCommandRoll - (YAW_DIRECT
 4887              		.loc 22 55 0
 4888 0024 411A     		subs	r1, r0, r1
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 4889              		.loc 22 52 0
 4890 0026 B61A     		subs	r6, r6, r2
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 4891              		.loc 22 53 0
 4892 0028 AD18     		adds	r5, r5, r2
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 4893              		.loc 22 54 0
 4894 002a A418     		adds	r4, r4, r2
 4895              		.loc 22 55 0
 4896 002c 8A1A     		subs	r2, r1, r2
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 4897              		.loc 22 52 0
 4898 002e 1E60     		str	r6, [r3, #0]
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 4899              		.loc 22 53 0
 4900 0030 5D60     		str	r5, [r3, #4]
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 4901              		.loc 22 54 0
 4902 0032 DC60     		str	r4, [r3, #12]
 4903              		.loc 22 55 0
 4904 0034 9A60     		str	r2, [r3, #8]
  56:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** }
 4905              		.loc 22 56 0
 4906 0036 70BD     		pop	{r4, r5, r6, pc}
 4907              	.L299:
 4908              		.align	2
 4909              	.L298:
 4910 0038 00000000 		.word	.LANCHOR73
 4911 003c 00000000 		.word	.LANCHOR74
 4912 0040 00000000 		.word	.LANCHOR75
 4913 0044 00000000 		.word	.LANCHOR76
 4914 0048 00000000 		.word	.LANCHOR56
 4915              		.cfi_endproc
 4916              	.LFE195:
 4918              		.section	.text._Z20calculateFlightErrorv,"ax",%progbits
 4919              		.align	1
 4920              		.global	_Z20calculateFlightErrorv
 4921              		.thumb
 4922              		.thumb_func
 4924              	_Z20calculateFlightErrorv:
 4925              	.LFB196:
 4926              		.file 23 "/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h"
   1:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /*
   2:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   www.AeroQuad.com
   4:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  
   7:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   (at your option) any later version. 
  11:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  
  12:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   GNU General Public License for more details. 
  16:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  
  17:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** */
  20:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  21:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  24:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  25:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_H_
  26:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_H_
  27:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  28:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #define ATTITUDE_SCALING (0.75 * PWM2RAD)
  29:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  30:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  31:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
  32:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * calculateFlightError
  33:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
  34:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Calculate roll/pitch axis error with gyro/accel data to
  35:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * compute motor command thrust so used command are executed
  36:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
  37:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void calculateFlightError()
  38:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** {
 4927              		.loc 23 38 0
 4928              		.cfi_startproc
 4929              		@ args = 0, pretend = 0, frame = 0
 4930              		@ frame_needed = 0, uses_anonymous_args = 0
 4931 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 4932              	.LCFI48:
 4933              		.cfi_def_cfa_offset 32
 4934              		.cfi_offset 14, -4
 4935              		.cfi_offset 10, -8
 4936              		.cfi_offset 9, -12
 4937              		.cfi_offset 8, -16
 4938              		.cfi_offset 7, -20
 4939              		.cfi_offset 6, -24
 4940              		.cfi_offset 5, -28
 4941              		.cfi_offset 4, -32
 4942 0004 2DED028B 		fstmfdd	sp!, {d8}
 4943              	.LCFI49:
 4944              		.cfi_def_cfa_offset 40
 4945              		.cfi_offset 80, -40
 4946              	.LBB110:
  39:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined (UseGPSNavigator)
  40:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
  41:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS] + gpsRollAxi
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS] + gpsPitchAx
  43:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAX
  45:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
  46:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     else
  47:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif
  48:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 4947              		.loc 23 48 0
 4948 0008 3D48     		ldr	r0, .L303
 4949 000a 3E4C     		ldr	r4, .L303+4
 4950 000c 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 4951 000e 3E4E     		ldr	r6, .L303+8
 4952 0010 3E4D     		ldr	r5, .L303+12
 4953 0012 012B     		cmp	r3, #1
 4954 0014 46D1     		bne	.L301
 4955              	.LBB111:
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 4956              		.loc 23 49 0
 4957 0016 DFF81C91 		ldr	r9, .L303+52
 4958 001a DFF81C81 		ldr	r8, .L303+56
 4959 001e D9F80020 		ldr	r2, [r9, #0]
 4960 0022 D8F80070 		ldr	r7, [r8, #0]
 4961 0026 D11B     		subs	r1, r2, r7
 4962 0028 03EE101A 		fmsr	s6, r1	@ int
 4963 002c 9FED388A 		flds	s16, .L303+16
 4964 0030 F8EEC32A 		fsitos	s5, s6
 4965 0034 374F     		ldr	r7, .L303+20
 4966 0036 384A     		ldr	r2, .L303+24
 4967 0038 3968     		ldr	r1, [r7, #0]	@ float
 4968 003a 22EE882A 		fmuls	s4, s5, s16
 4969 003e 12EE100A 		fmrs	r0, s4
 4970 0042 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 4971              		.loc 23 50 0
 4972 0046 D8F80430 		ldr	r3, [r8, #4]
 4973 004a 7A68     		ldr	r2, [r7, #4]	@ float
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 4974              		.loc 23 49 0
 4975 004c 8246     		mov	sl, r0	@ float
 4976              	.LVL252:
 4977              		.loc 23 50 0
 4978 004e D9F80400 		ldr	r0, [r9, #4]
 4979              	.LVL253:
 4980 0052 C3EB000C 		rsb	ip, r3, r0
 4981 0056 01EE90CA 		fmsr	s3, ip	@ int
 4982 005a B8EEE11A 		fsitos	s2, s3
 4983 005e 82F00041 		eor	r1, r2, #-2147483648
 4984 0062 21EE087A 		fmuls	s14, s2, s16
 4985 0066 2D4A     		ldr	r2, .L303+28
 4986 0068 17EE100A 		fmrs	r0, s14
 4987 006c FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 4988              		.loc 23 51 0
 4989 0070 2168     		ldr	r1, [r4, #0]	@ float
 4990 0072 2B4A     		ldr	r2, .L303+32
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 4991              		.loc 23 50 0
 4992 0074 0746     		mov	r7, r0	@ float
 4993              	.LVL254:
 4994              		.loc 23 51 0
 4995 0076 5046     		mov	r0, sl	@ float
 4996              	.LVL255:
 4997 0078 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 4998 007c 00EE900A 		fmsr	s1, r0
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAXIS
 4999              		.loc 23 52 0
 5000 0080 6168     		ldr	r1, [r4, #4]	@ float
 5001 0082 284A     		ldr	r2, .L303+36
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 5002              		.loc 23 51 0
 5003 0084 FDEEE07A 		ftosizs	s15, s1
 5004              		.loc 23 52 0
 5005 0088 3846     		mov	r0, r7	@ float
 5006 008a 81F00041 		eor	r1, r1, #-2147483648
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 5007              		.loc 23 51 0
 5008 008e C6ED007A 		fsts	s15, [r6, #0]	@ int
 5009              		.loc 23 52 0
 5010 0092 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 5011 0096 00EE100A 		fmsr	s0, r0
 5012 009a FDEEC06A 		ftosizs	s13, s0
 5013 009e C5ED006A 		fsts	s13, [r5, #0]	@ int
 5014 00a2 28E0     		b	.L300
 5015              	.LVL256:
 5016              	.L301:
 5017              	.LBE111:
  53:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
  54:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   else {
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 5018              		.loc 23 55 0
 5019 00a4 204F     		ldr	r7, .L303+40
 5020 00a6 0020     		movs	r0, #0
 5021 00a8 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 5022 00ac D4ED000A 		flds	s1, [r4, #0]
 5023 00b0 D7ED007A 		flds	s15, [r7, #0]
 5024 00b4 20EEA70A 		fmuls	s0, s1, s15
 5025 00b8 1C4A     		ldr	r2, .L303+44
 5026 00ba 10EE101A 		fmrs	r1, s0
 5027 00be FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 5028 00c2 06EE900A 		fmsr	s13, r0
 5029 00c6 BDEEE66A 		ftosizs	s12, s13
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandPitch = updatePID(getReceiverSIData(YAXIS), -gyroRate[YAXIS]*rotationSpeedFacto
 5030              		.loc 23 56 0
 5031 00ca 0120     		movs	r0, #1
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 5032              		.loc 23 55 0
 5033 00cc 86ED006A 		fsts	s12, [r6, #0]	@ int
 5034              		.loc 23 56 0
 5035 00d0 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 5036 00d4 94ED015A 		flds	s10, [r4, #4]
 5037 00d8 D7ED005A 		flds	s11, [r7, #0]
 5038 00dc 65EE654A 		fnmuls	s9, s10, s11
 5039 00e0 134A     		ldr	r2, .L303+48
 5040 00e2 14EE901A 		fmrs	r1, s9
 5041 00e6 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 5042 00ea 04EE100A 		fmsr	s8, r0
 5043 00ee FDEEC43A 		ftosizs	s7, s8
 5044 00f2 C5ED003A 		fsts	s7, [r5, #0]	@ int
 5045              	.L300:
 5046              	.LBE110:
  57:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 5047              		.loc 23 58 0
 5048 00f6 BDEC028B 		fldmfdd	sp!, {d8}
 5049 00fa BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 5050              	.L304:
 5051 00fe 00BF     		.align	2
 5052              	.L303:
 5053 0100 00000000 		.word	.LANCHOR77
 5054 0104 00000000 		.word	.LANCHOR19
 5055 0108 00000000 		.word	.LANCHOR75
 5056 010c 00000000 		.word	.LANCHOR74
 5057 0110 A69BC43A 		.word	985963430
 5058 0114 00000000 		.word	.LANCHOR33
 5059 0118 54000000 		.word	.LANCHOR9+84
 5060 011c 70000000 		.word	.LANCHOR9+112
 5061 0120 A8000000 		.word	.LANCHOR9+168
 5062 0124 C4000000 		.word	.LANCHOR9+196
 5063 0128 00000000 		.word	.LANCHOR78
 5064 012c 00000000 		.word	.LANCHOR9
 5065 0130 1C000000 		.word	.LANCHOR9+28
 5066 0134 00000000 		.word	.LANCHOR1
 5067 0138 00000000 		.word	.LANCHOR3
 5068              		.cfi_endproc
 5069              	.LFE196:
 5071              		.section	.text._Z19processCalibrateESCv,"ax",%progbits
 5072              		.align	1
 5073              		.global	_Z19processCalibrateESCv
 5074              		.thumb
 5075              		.thumb_func
 5077              	_Z19processCalibrateESCv:
 5078              	.LFB197:
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
  61:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processCalibrateESC
  62:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * 
  63:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Proces esc calibration command with the help of the configurator
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processCalibrateESC()
  66:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** {
 5079              		.loc 23 66 0
 5080              		.cfi_startproc
 5081              		@ args = 0, pretend = 0, frame = 0
 5082              		@ frame_needed = 0, uses_anonymous_args = 0
 5083              		@ link register save eliminated.
 5084              	.LBB112:
 5085              	.LBB113:
  67:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 5086              		.loc 23 67 0
 5087 0000 1B4B     		ldr	r3, .L319
 5088 0002 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 5089 0004 1B4B     		ldr	r3, .L319+4
 5090 0006 032A     		cmp	r2, #3
 5091 0008 0CD0     		beq	.L308
 5092 000a 052A     		cmp	r2, #5
 5093 000c 19D0     		beq	.L314
 5094 000e 012A     		cmp	r2, #1
 5095              	.LVL257:
 5096              	.LBB114:
 5097              	.LBB115:
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   case 1:
  69:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = MAXCOMMAND;
 5098              		.loc 23 70 0
 5099 0010 0CBF     		ite	eq
 5100 0012 4FF4FA62 		moveq	r2, #2000
 5101              	.LVL258:
 5102              	.LBE115:
 5103              	.LBB116:
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     break;
  72:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   case 3:
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
  75:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     break;
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   case 5:
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
  79:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     safetyCheck = ON;
  80:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     break;
  81:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   default:
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = MINCOMMAND;
 5104              		.loc 23 83 0
 5105 0016 4FF47A72 		movne	r2, #1000
 5106              	.LVL259:
 5107              	.L318:
 5108              		.loc 23 83 0 is_stmt 0 discriminator 1
 5109 001a 1A60     		str	r2, [r3, #0]
 5110              	.LVL260:
 5111 001c 5A60     		str	r2, [r3, #4]
 5112              	.LVL261:
 5113 001e 9A60     		str	r2, [r3, #8]
 5114              	.LVL262:
 5115 0020 DA60     		str	r2, [r3, #12]
 5116              	.LVL263:
 5117 0022 23E0     		b	.L310
 5118              	.LVL264:
 5119              	.L308:
 5120              	.LBE116:
 5121              	.LBB117:
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
 5122              		.loc 23 74 0 is_stmt 1
 5123 0024 1448     		ldr	r0, .L319+8
 5124 0026 0268     		ldr	r2, [r0, #0]
 5125 0028 B2F5966F 		cmp	r2, #1200
 5126 002c B4BF     		ite	lt
 5127 002e 1146     		movlt	r1, r2
 5128 0030 4FF49661 		movge	r1, #1200
 5129 0034 B2F57A7F 		cmp	r2, #1000
 5130 0038 ACBF     		ite	ge
 5131 003a 0A46     		movge	r2, r1
 5132 003c 4FF47A72 		movlt	r2, #1000
 5133 0040 EBE7     		b	.L318
 5134              	.L314:
 5135              	.LBE117:
 5136              	.LBE114:
  67:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 5137              		.loc 23 67 0
 5138 0042 0022     		movs	r2, #0
 5139              	.L309:
 5140              	.LBB119:
 5141              	.LBB118:
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 5142              		.loc 23 78 0
 5143 0044 0D49     		ldr	r1, .L319+12
 5144 0046 5158     		ldr	r1, [r2, r1]
 5145 0048 B1F57A7F 		cmp	r1, #1000
 5146 004c 05DB     		blt	.L315
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 5147              		.loc 23 78 0 is_stmt 0 discriminator 1
 5148 004e B1F5966F 		cmp	r1, #1200
 5149 0052 A8BF     		it	ge
 5150 0054 4FF49661 		movge	r1, #1200
 5151 0058 01E0     		b	.L313
 5152              	.L315:
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 5153              		.loc 23 78 0
 5154 005a 4FF47A71 		mov	r1, #1000
 5155              	.L313:
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 5156              		.loc 23 78 0 discriminator 3
 5157 005e 9950     		str	r1, [r3, r2]
 5158 0060 0432     		adds	r2, r2, #4
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
 5159              		.loc 23 77 0 is_stmt 1 discriminator 3
 5160 0062 102A     		cmp	r2, #16
 5161 0064 EED1     		bne	.L309
 5162              	.LBE118:
  79:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     safetyCheck = ON;
 5163              		.loc 23 79 0
 5164 0066 064B     		ldr	r3, .L319+16
 5165 0068 0122     		movs	r2, #1
 5166 006a 1A70     		strb	r2, [r3, #0]
 5167              	.LVL265:
 5168              	.L310:
 5169              	.LBE119:
 5170              	.LBE113:
 5171              	.LBE112:
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
  85:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // Send calibration commands to motors
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 5172              		.loc 23 87 0
 5173              	.LBB120:
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
 5174              		.loc 23 86 0
 5175 006c FFF7FEBF 		b	_Z11writeMotorsv
 5176              	.L320:
 5177              		.align	2
 5178              	.L319:
 5179 0070 00000000 		.word	.LANCHOR79
 5180 0074 00000000 		.word	.LANCHOR56
 5181 0078 00000000 		.word	.LANCHOR80
 5182 007c 00000000 		.word	.LANCHOR81
 5183 0080 00000000 		.word	.LANCHOR82
 5184              	.LBE120:
 5185              		.cfi_endproc
 5186              	.LFE197:
 5188              		.section	.text._Z25processThrottleCorrectionv,"ax",%progbits
 5189              		.align	1
 5190              		.global	_Z25processThrottleCorrectionv
 5191              		.thumb
 5192              		.thumb_func
 5194              	_Z25processThrottleCorrectionv:
 5195              	.LFB198:
  88:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  89:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
  90:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processBatteryMonitorThrottleAdjustment
  91:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Check battery alarm and if in alarm, increment a counter
  93:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * When this counter reach BATTERY_MONITOR_MAX_ALARM_COUNT, then
  94:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * we are now in auto-descent mode.
  95:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
  96:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * When in auto-descent mode, the user can pass throttle keep when the
  97:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * alarm was reach, and the throttle is slowly decrease for a minute til
  98:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * batteryMonitorThrottle that is configurable with the configurator
  99:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 100:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #if defined BattMonitor && defined BattMonitorAutoDescent
 101:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   void processBatteryMonitorThrottleAdjustment() {
 102:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 103:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (batteryMonitorAlarmCounter < BATTERY_MONITOR_MAX_ALARM_COUNT) {
 104:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (batteryAlarm) {
 105:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         batteryMonitorAlarmCounter++;
 106:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 108:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     else {
 109:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 110:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         if (altitudeHoldState == ON) {
 111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           #if defined AltitudeHoldBaro
 112:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             baroAltitudeToHoldTarget -= 0.01;
 113:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           #endif
 114:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           #if defined AltitudeHoldRangeFinder
 115:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             if (sonarAltitudeToHoldTarget != INVALID_RANGE) {
 116:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****               sonarAltitudeToHoldTarget -= 0.01;
 117:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             }
 118:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           #endif
 119:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 120:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         else {
 121:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #endif
 122:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           if (batteryMonitorStartThrottle == 0) {  // init battery monitor throttle correction!
 123:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             batteryMonitorStartTime = millis();
 124:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             if (throttle < batteryMonitorThrottleTarget) {
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****               batteryMonitorStartThrottle = batteryMonitorThrottleTarget;
 126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             }
 127:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             else {
 128:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****               batteryMonitorStartThrottle = throttle; 
 129:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             }
 130:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           }
 131:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           int batteryMonitorThrottle = map(millis()-batteryMonitorStartTime, 0, batteryMonitorGoing
 132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           if (batteryMonitorThrottle < batteryMonitorThrottleTarget) {
 133:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             batteryMonitorThrottle = batteryMonitorThrottleTarget;
 134:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           }
 135:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           if (throttle < batteryMonitorThrottle) {
 136:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = 0;
 137:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           }
 138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           else {
 139:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = batteryMonitorThrottle - throttle;
 140:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           }
 141:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 142:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 143:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #endif
 144:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 145:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 146:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #endif  
 147:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 148:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 149:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #if defined AutoLanding
 150:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #define BARO_AUTO_LANDING_DESCENT_SPEED 0.008
 151:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #define SONAR_AUTO_LANDING_DESCENT_SPEED 0.005
 152:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   void processAutoLandingAltitudeCorrection() {
 153:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (autoLandingState != OFF) {   
 154:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 155:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (autoLandingState == BARO_AUTO_DESCENT_STATE) {
 156:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 157:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) { 
 158:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           autoLandingState = SONAR_AUTO_DESCENT_STATE;
 159:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 160:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 161:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       else if (autoLandingState == SONAR_AUTO_DESCENT_STATE) {
 162:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 163:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 164:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         if (rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] < 0.5) {
 165:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           autoLandingState = MOTOR_AUTO_DESCENT_STATE;
 166:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 167:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 168:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       else {
 169:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         autoLandingThrottleCorrection -= 1;
 170:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 171:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 172:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 173:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         if (((throttle + autoLandingThrottleCorrection) < 1000) || (rangeFinderRange[ALTITUDE_RANGE
 174:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           commandAllMotors(MINCOMMAND);
 175:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           motorArmed = OFF;
 176:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 177:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 178:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 179:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  }
 180:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #endif
 181:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 182:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 183:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
 184:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processThrottleCorrection
 185:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * 
 186:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * This function will add some throttle imput if the craft is angled
 187:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * this prevent the craft to loose altitude when angled.
 188:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * it also add the battery throttle correction in case
 189:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * of we are in auto-descent.
 190:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * 
 191:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Special thank to Ziojo for this.
 192:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 193:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processThrottleCorrection() {
 5196              		.loc 23 193 0
 5197              		.cfi_startproc
 5198              		@ args = 0, pretend = 0, frame = 0
 5199              		@ frame_needed = 0, uses_anonymous_args = 0
 5200              		@ link register save eliminated.
 5201              	.LVL266:
 5202              	.LBB121:
 194:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  
 195:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   int throttleAdjust = 0;
 196:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined UseGPSNavigator
 197:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
 198:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       throttleAdjust = throttle / (cos (kinematicsAngle[XAXIS]*0.55) * cos (kinematicsAngle[YAXIS]*
 199:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       throttleAdjust = constrain ((throttleAdjust - throttle), 0, 50); //compensate max  +/- 25 deg
 200:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 201:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif
 202:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined BattMonitorAutoDescent
 203:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     throttleAdjust += batteyMonitorThrottleCorrection;
 204:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif
 205:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined (AutoLanding)
 206:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined BattMonitorAutoDescent
 207:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (batteyMonitorThrottleCorrection != 0) { // don't auto land in the same time that the batt
 208:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         throttleAdjust += autoLandingThrottleCorrection;
 209:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 210:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #else
 211:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       throttleAdjust += autoLandingThrottleCorrection;
 212:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 213:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif
 214:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 215:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   throttle = constrain((throttle + throttleAdjust),MINCOMMAND,MAXCOMMAND-150);  // limmit throttle 
 5203              		.loc 23 215 0
 5204 0000 074A     		ldr	r2, .L324
 5205 0002 1368     		ldr	r3, [r2, #0]
 5206 0004 B3F57A7F 		cmp	r3, #1000
 5207 0008 05DB     		blt	.L323
 5208              		.loc 23 215 0 is_stmt 0 discriminator 1
 5209 000a 40F23A71 		movw	r1, #1850
 5210 000e 8B42     		cmp	r3, r1
 5211 0010 A8BF     		it	ge
 5212 0012 0B46     		movge	r3, r1
 5213 0014 01E0     		b	.L322
 5214              	.L323:
 5215              		.loc 23 215 0
 5216 0016 4FF47A73 		mov	r3, #1000
 5217              	.L322:
 5218              		.loc 23 215 0 discriminator 3
 5219 001a 1360     		str	r3, [r2, #0]
 5220              	.LBE121:
 216:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 5221              		.loc 23 216 0 is_stmt 1 discriminator 3
 5222 001c 7047     		bx	lr
 5223              	.L325:
 5224 001e 00BF     		.align	2
 5225              	.L324:
 5226 0020 00000000 		.word	.LANCHOR73
 5227              		.cfi_endproc
 5228              	.LFE198:
 5230              		.section	.text._Z20processHardManueversv,"ax",%progbits
 5231              		.align	1
 5232              		.global	_Z20processHardManueversv
 5233              		.thumb
 5234              		.thumb_func
 5236              	_Z20processHardManueversv:
 5237              	.LFB199:
 217:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 218:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 219:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
 220:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processHardManuevers
 221:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
 222:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * In case of a roll/pitch stick at one edge to do a loop, this function
 223:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * will prevent the lower throttle motor side to have too much low throtte.
 224:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 225:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processHardManuevers() {
 5238              		.loc 23 225 0
 5239              		.cfi_startproc
 5240              		@ args = 0, pretend = 0, frame = 0
 5241              		@ frame_needed = 0, uses_anonymous_args = 0
 5242              		@ link register save eliminated.
 5243              	.LBB122:
 226:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 227:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 5244              		.loc 23 227 0
 5245 0000 0F4A     		ldr	r2, .L332
 5246 0002 1068     		ldr	r0, [r2, #0]
 5247 0004 A0F58863 		sub	r3, r0, #1088
 5248 0008 0C3B     		subs	r3, r3, #12
 5249 000a B3F5487F 		cmp	r3, #800
 5250 000e 04D8     		bhi	.L327
 228:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       (receiverCommand[XAXIS] > MAXCHECK) ||
 229:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       (receiverCommand[YAXIS] < MINCHECK) ||
 5251              		.loc 23 229 0 discriminator 1
 5252 0010 5368     		ldr	r3, [r2, #4]
 227:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 5253              		.loc 23 227 0 discriminator 1
 5254 0012 40F24B42 		movw	r2, #1099
 5255 0016 9342     		cmp	r3, r2
 5256 0018 03DC     		bgt	.L328
 5257              	.L327:
 5258              	.LBB123:
 230:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       (receiverCommand[YAXIS] > MAXCHECK)) {  
 231:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         
 232:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 233:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 5259              		.loc 23 233 0 discriminator 2
 5260 001a 0A49     		ldr	r1, .L332+4
 5261 001c 0023     		movs	r3, #0
 5262 001e 0A68     		ldr	r2, [r1, #0]
 5263 0020 04E0     		b	.L329
 5264              	.L328:
 5265              	.LBE123:
 227:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 5266              		.loc 23 227 0 discriminator 2
 5267 0022 40F26C70 		movw	r0, #1900
 5268 0026 8342     		cmp	r3, r0
 5269 0028 F7DC     		bgt	.L327
 5270 002a 7047     		bx	lr
 5271              	.L329:
 5272              	.LBB124:
 5273              		.loc 23 233 0 discriminator 2
 5274 002c 0648     		ldr	r0, .L332+8
 234:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMaxCommand[motor] = MAXCOMMAND;
 5275              		.loc 23 234 0 discriminator 2
 5276 002e 0749     		ldr	r1, .L332+12
 233:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 5277              		.loc 23 233 0 discriminator 2
 5278 0030 1A50     		str	r2, [r3, r0]
 5279              		.loc 23 234 0 discriminator 2
 5280 0032 4FF4FA60 		mov	r0, #2000
 5281 0036 5850     		str	r0, [r3, r1]
 5282 0038 0433     		adds	r3, r3, #4
 232:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 5283              		.loc 23 232 0 discriminator 2
 5284 003a 102B     		cmp	r3, #16
 5285 003c F6D1     		bne	.L329
 5286 003e 7047     		bx	lr
 5287              	.L333:
 5288              		.align	2
 5289              	.L332:
 5290 0040 00000000 		.word	.LANCHOR1
 5291 0044 00000000 		.word	.LANCHOR83
 5292 0048 00000000 		.word	.LANCHOR84
 5293 004c 00000000 		.word	.LANCHOR85
 5294              	.LBE124:
 5295              	.LBE122:
 5296              		.cfi_endproc
 5297              	.LFE199:
 5299              		.section	.text._Z20processMinMaxCommandv,"ax",%progbits
 5300              		.align	1
 5301              		.global	_Z20processMinMaxCommandv
 5302              		.thumb
 5303              		.thumb_func
 5305              	_Z20processMinMaxCommandv:
 5306              	.LFB200:
 235:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 236:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 237:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 238:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 239:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
 240:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processMinMaxCommand
 241:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
 242:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * This function correct too low/max throttle when manuevering
 243:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * preventing some wobbling behavior
 244:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 245:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processMinMaxCommand()
 246:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** {
 5307              		.loc 23 246 0
 5308              		.cfi_startproc
 5309              		@ args = 0, pretend = 0, frame = 0
 5310              		@ frame_needed = 0, uses_anonymous_args = 0
 5311              	.LVL267:
 5312              	.LBB125:
 5313              	.LBB126:
 247:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++)
 248:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   {
 249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 5314              		.loc 23 249 0
 5315 0000 154A     		ldr	r2, .L338
 250:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorMaxCommand[motor] = MAXCOMMAND;
 5316              		.loc 23 250 0
 5317 0002 164B     		ldr	r3, .L338+4
 249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 5318              		.loc 23 249 0
 5319 0004 1068     		ldr	r0, [r2, #0]
 5320 0006 1649     		ldr	r1, .L338+8
 5321              		.loc 23 250 0
 5322 0008 4FF4FA62 		mov	r2, #2000
 5323              	.LBE126:
 5324              	.LBE125:
 246:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** {
 5325              		.loc 23 246 0
 5326 000c 10B5     		push	{r4, lr}
 5327              	.LCFI50:
 5328              		.cfi_def_cfa_offset 8
 5329              		.cfi_offset 14, -4
 5330              		.cfi_offset 4, -8
 5331              	.LBB131:
 5332              	.LBB127:
 5333              		.loc 23 250 0
 5334 000e 9A60     		str	r2, [r3, #8]
 5335 0010 DA60     		str	r2, [r3, #12]
 5336 0012 1A60     		str	r2, [r3, #0]
 5337              	.LVL268:
 5338 0014 5A60     		str	r2, [r3, #4]
 5339              	.LVL269:
 5340              	.LBE127:
 251:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 252:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 253:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   int maxMotor = motorCommand[0];
 5341              		.loc 23 253 0
 5342 0016 134B     		ldr	r3, .L338+12
 5343              	.LBB128:
 249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 5344              		.loc 23 249 0
 5345 0018 0860     		str	r0, [r1, #0]
 5346 001a 4860     		str	r0, [r1, #4]
 5347 001c 8860     		str	r0, [r1, #8]
 5348 001e C860     		str	r0, [r1, #12]
 5349              	.LBE128:
 5350              		.loc 23 253 0
 5351 0020 93E80600 		ldmia	r3, {r1, r2}
 5352 0024 9868     		ldr	r0, [r3, #8]
 5353 0026 9142     		cmp	r1, r2
 5354 0028 B8BF     		it	lt
 5355 002a 1146     		movlt	r1, r2
 5356              	.LVL270:
 5357 002c DA68     		ldr	r2, [r3, #12]
 5358 002e 8142     		cmp	r1, r0
 5359 0030 B8BF     		it	lt
 5360 0032 0146     		movlt	r1, r0
 5361              	.LVL271:
 5362 0034 9142     		cmp	r1, r2
 5363 0036 B8BF     		it	lt
 5364 0038 1146     		movlt	r1, r2
 5365              	.LVL272:
 5366              	.LBB129:
 254:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 255:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor=1; motor < LASTMOTOR; motor++) {
 256:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (motorCommand[motor] > maxMotor) {
 5367              		.loc 23 256 0
 5368 003a 0022     		movs	r2, #0
 5369              	.LVL273:
 5370              	.L336:
 5371              	.LBE129:
 5372              	.LBB130:
 257:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       maxMotor = motorCommand[motor];
 258:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 259:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 260:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 261:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 262:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (maxMotor > MAXCOMMAND) {
 5373              		.loc 23 262 0
 5374 003c B1F5FA6F 		cmp	r1, #2000
 5375 0040 05DD     		ble	.L335
 263:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] =  motorCommand[motor] - (maxMotor - MAXCOMMAND);
 5376              		.loc 23 263 0
 5377 0042 9C58     		ldr	r4, [r3, r2]
 5378 0044 C1F5FA6C 		rsb	ip, r1, #2000
 5379 0048 04EB0C00 		add	r0, r4, ip
 5380 004c 9850     		str	r0, [r3, r2]
 5381              	.L335:
 5382 004e 0432     		adds	r2, r2, #4
 261:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 5383              		.loc 23 261 0
 5384 0050 102A     		cmp	r2, #16
 5385 0052 F3D1     		bne	.L336
 5386              	.LBE130:
 5387              	.LBE131:
 264:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 265:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 266:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 5388              		.loc 23 266 0
 5389 0054 10BD     		pop	{r4, pc}
 5390              	.L339:
 5391 0056 00BF     		.align	2
 5392              	.L338:
 5393 0058 00000000 		.word	.LANCHOR83
 5394 005c 00000000 		.word	.LANCHOR85
 5395 0060 00000000 		.word	.LANCHOR84
 5396 0064 00000000 		.word	.LANCHOR56
 5397              		.cfi_endproc
 5398              	.LFE200:
 5400              		.section	.text._Z14processHeadingv,"ax",%progbits
 5401              		.align	1
 5402              		.global	_Z14processHeadingv
 5403              		.thumb
 5404              		.thumb_func
 5406              	_Z14processHeadingv:
 5407              	.LFB204:
 5408              		.file 24 "/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h"
   1:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** /*
   2:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   www.AeroQuad.com
   4:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   An Open Source Arduino based multicopter.
   6:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  
   7:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   (at your option) any later version. 
  11:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  
  12:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   GNU General Public License for more details. 
  16:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  
  17:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** */
  20:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  21:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  22:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** #ifndef _AQ_HEADING_CONTROL_PROCESSOR_H_
  23:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** #define _AQ_HEADING_CONTROL_PROCESSOR_H_
  24:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  25:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  26:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** float setHeading          = 0;
  27:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** unsigned long headingTime = micros();
  28:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  29:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  30:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** /**
  31:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  * processHeading
  32:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  *
  33:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  * This function will calculate the craft heading correction depending 
  34:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  * of the users command. Heading correction is process with the gyro
  35:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  * or a magnetometer
  36:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  */
  37:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** void processHeading()
  38:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** {
 5409              		.loc 24 38 0
 5410              		.cfi_startproc
 5411              		@ args = 0, pretend = 0, frame = 0
 5412              		@ frame_needed = 0, uses_anonymous_args = 0
 5413 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5414              	.LCFI51:
 5415              		.cfi_def_cfa_offset 24
 5416              		.cfi_offset 14, -4
 5417              		.cfi_offset 7, -8
 5418              		.cfi_offset 6, -12
 5419              		.cfi_offset 5, -16
 5420              		.cfi_offset 4, -20
 5421              		.cfi_offset 3, -24
 5422              	.LBB132:
  39:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   if (headingHoldConfig == ON) {
 5423              		.loc 24 39 0
 5424 0002 5C48     		ldr	r0, .L361
 5425 0004 5C4E     		ldr	r6, .L361+4
 5426 0006 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 5427 0008 5C4C     		ldr	r4, .L361+8
 5428 000a 012B     		cmp	r3, #1
 5429 000c 7ED1     		bne	.L341
  40:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  41:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     #if defined(HeadingMagHold)
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
  43:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     #else
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 5430              		.loc 24 44 0
 5431 000e 5C4A     		ldr	r2, .L361+12
 5432 0010 5C49     		ldr	r1, .L361+16
  45:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     #endif
  46:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  47:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // Always center relative heading around absolute heading chosen during yaw command
  48:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // This assumes that an incorrect yaw can't be forced on the AeroQuad >180 or <-180 degrees
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // This is done so that AeroQuad does not accidentally hit transition between 0 and 360 or -180
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // AKA - THERE IS A BUG HERE - if relative heading is greater than 180 degrees, the PID will sw
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // Doubt that will happen as it would have to be uncommanded.
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 5433              		.loc 24 52 0
 5434 0012 5D4B     		ldr	r3, .L361+20
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 5435              		.loc 24 44 0
 5436 0014 92ED007A 		flds	s14, [r2, #0]
 5437 0018 DFED5C7A 		flds	s15, .L361+24
 5438              		.loc 24 52 0
 5439 001c 5C4A     		ldr	r2, .L361+28
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 5440              		.loc 24 44 0
 5441 001e 67EE277A 		fmuls	s15, s14, s15
  53:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     if (heading <= (setHeading - 180)) {
 5442              		.loc 24 53 0
 5443 0022 9FED5C6A 		flds	s12, .L361+32
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 5444              		.loc 24 52 0
 5445 0026 92ED007A 		flds	s14, [r2, #0]
 5446              		.loc 24 53 0
 5447 002a 77EE465A 		fsubs	s11, s14, s12
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 5448              		.loc 24 52 0
 5449 002e 77EEC76A 		fsubs	s13, s15, s14
 5450              		.loc 24 53 0
 5451 0032 F4EEE57A 		fcmpes	s15, s11
 5452 0036 F1EE10FA 		fmstat
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 5453              		.loc 24 44 0
 5454 003a C1ED007A 		fsts	s15, [r1, #0]
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 5455              		.loc 24 52 0
 5456 003e C3ED006A 		fsts	s13, [r3, #0]
 5457              		.loc 24 53 0
 5458 0042 05D8     		bhi	.L342
  54:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       relativeHeading += 360;
 5459              		.loc 24 54 0
 5460 0044 9FED540A 		flds	s0, .L361+36
 5461 0048 76EE806A 		fadds	s13, s13, s0
 5462 004c C3ED006A 		fsts	s13, [r3, #0]
 5463              	.L342:
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     }
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     if (heading >= (setHeading + 180)) {
 5464              		.loc 24 56 0
 5465 0050 77EE060A 		fadds	s1, s14, s12
 5466 0054 F4EEE07A 		fcmpes	s15, s1
 5467 0058 F1EE10FA 		fmstat
 5468 005c 07DB     		blt	.L344
  57:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       relativeHeading -= 360;
 5469              		.loc 24 57 0
 5470 005e 93ED002A 		flds	s4, [r3, #0]
 5471 0062 DFED4D1A 		flds	s3, .L361+36
 5472 0066 32EE611A 		fsubs	s2, s4, s3
 5473 006a 83ED001A 		fsts	s2, [r3, #0]
 5474              	.L344:
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     }
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // Apply heading hold only when throttle high enough to start flight
  61:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     if (receiverCommand[THROTTLE] > MINCHECK ) { 
 5475              		.loc 24 61 0
 5476 006e F068     		ldr	r0, [r6, #12]
 5477 0070 40F24C4C 		movw	ip, #1100
 5478 0074 6045     		cmp	r0, ip
 5479 0076 42DD     		ble	.L346
  62:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       
  63:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       #if defined (UseGPSNavigator)
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         if (( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) > (MIDCOMMAND + 25)) || 
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             ( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) < (MIDCOMMAND - 25))) {
  66:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       #else
  67:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         if ((receiverCommand[ZAXIS] > (MIDCOMMAND + 25)) || 
 5480              		.loc 24 67 0
 5481 0078 3F48     		ldr	r0, .L361+4
 5482 007a 8168     		ldr	r1, [r0, #8]
 5483 007c A1F5B860 		sub	r0, r1, #1472
 5484 0080 C11E     		subs	r1, r0, #3
 5485 0082 3229     		cmp	r1, #50
 5486 0084 0ED9     		bls	.L347
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             (receiverCommand[ZAXIS] < (MIDCOMMAND - 25))) {
  69:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       #endif
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         
  72:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         // If commanding yaw, turn off heading hold and store latest heading
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         setHeading = heading;
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHold = 0;
  75:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 5487              		.loc 24 75 0
 5488 0086 4549     		ldr	r1, .L361+40
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHold = 0;
 5489              		.loc 24 74 0
 5490 0088 0023     		movs	r3, #0
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         setHeading = heading;
 5491              		.loc 24 73 0
 5492 008a C2ED007A 		fsts	s15, [r2, #0]
 5493              		.loc 24 75 0
 5494 008e C1F8A030 		str	r3, [r1, #160]	@ float
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHoldState = OFF;
 5495              		.loc 24 76 0
 5496 0092 434A     		ldr	r2, .L361+44
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingTime = currentTime;
 5497              		.loc 24 77 0
 5498 0094 4349     		ldr	r1, .L361+48
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHold = 0;
 5499              		.loc 24 74 0
 5500 0096 2360     		str	r3, [r4, #0]	@ float
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHoldState = OFF;
 5501              		.loc 24 76 0
 5502 0098 0020     		movs	r0, #0
 5503 009a 1070     		strb	r0, [r2, #0]
 5504              		.loc 24 77 0
 5505 009c 424B     		ldr	r3, .L361+52
 5506 009e 0A68     		ldr	r2, [r1, #0]
 5507 00a0 1A60     		str	r2, [r3, #0]
 5508 00a2 33E0     		b	.L341
 5509              	.L347:
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       }
  79:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       else {
  80:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         if (relativeHeading < 0.25 && relativeHeading > -0.25) {
 5510              		.loc 24 80 0
 5511 00a4 93ED007A 		flds	s14, [r3, #0]
 5512 00a8 F5EE002A 		fconsts	s5, #80
 5513 00ac B4EEE27A 		fcmpes	s14, s5
 5514 00b0 F1EE10FA 		fmstat
 5515 00b4 06D5     		bpl	.L348
 5516              		.loc 24 80 0 is_stmt 0 discriminator 1
 5517 00b6 BDEE003A 		fconsts	s6, #208
 5518 00ba B4EEC37A 		fcmpes	s14, s6
 5519 00be F1EE10FA 		fmstat
 5520 00c2 1EDC     		bgt	.L360
 5521              	.L348:
  81:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           headingHold = 0;
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           PID[HEADING_HOLD_PID_IDX].integratedError = 0;
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         }
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         else if (headingHoldState == OFF) { // quick fix to soften heading hold on new heading
 5522              		.loc 24 84 0 is_stmt 1
 5523 00c4 3649     		ldr	r1, .L361+44
 5524 00c6 384D     		ldr	r5, .L361+52
 5525 00c8 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 5526 00ca 364F     		ldr	r7, .L361+48
 5527 00cc 68B9     		cbnz	r0, .L351
  85:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           if ((currentTime - headingTime) > 500000) {
 5528              		.loc 24 85 0
 5529 00ce 3B68     		ldr	r3, [r7, #0]
 5530 00d0 2F68     		ldr	r7, [r5, #0]
 5531 00d2 3648     		ldr	r0, .L361+56
 5532 00d4 DF1B     		subs	r7, r3, r7
 5533 00d6 8742     		cmp	r7, r0
 5534 00d8 18D9     		bls	.L341
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingHoldState = ON;
 5535              		.loc 24 86 0
 5536 00da 0120     		movs	r0, #1
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingTime = currentTime;
  88:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             setHeading = heading;
 5537              		.loc 24 88 0
 5538 00dc C2ED007A 		fsts	s15, [r2, #0]
  89:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingHold = 0;
 5539              		.loc 24 89 0
 5540 00e0 0022     		movs	r2, #0
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingHoldState = ON;
 5541              		.loc 24 86 0
 5542 00e2 0870     		strb	r0, [r1, #0]
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingTime = currentTime;
 5543              		.loc 24 87 0
 5544 00e4 2B60     		str	r3, [r5, #0]
 5545              		.loc 24 89 0
 5546 00e6 2260     		str	r2, [r4, #0]	@ float
 5547 00e8 10E0     		b	.L341
 5548              	.L351:
  90:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           }
  91:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         }
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         else {
  93:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         // No new yaw input, calculate current heading vs. desired heading heading hold
  94:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         // Relative heading is always centered around zero
  95:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 5549              		.loc 24 95 0
 5550 00ea 17EE101A 		fmrs	r1, s14
 5551 00ee 0020     		movs	r0, #0
 5552 00f0 2F4A     		ldr	r2, .L361+60
 5553 00f2 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  96:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           headingTime = currentTime; // quick fix to soften heading hold, wait 100ms before applyin
 5554              		.loc 24 96 0
 5555 00f6 3968     		ldr	r1, [r7, #0]
  95:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 5556              		.loc 24 95 0
 5557 00f8 2060     		str	r0, [r4, #0]	@ float
 5558              		.loc 24 96 0
 5559 00fa 2960     		str	r1, [r5, #0]
 5560 00fc 06E0     		b	.L341
 5561              	.L346:
  97:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         }
  98:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       }
  99:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     }
 100:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     else {
 101:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       // minimum throttle not reached, use off settings
 102:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       setHeading = heading;
 5562              		.loc 24 102 0
 5563 00fe C2ED007A 		fsts	s15, [r2, #0]
 5564              	.L360:
 103:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       headingHold = 0;
 104:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 5565              		.loc 24 104 0
 5566 0102 264A     		ldr	r2, .L361+40
 103:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       headingHold = 0;
 5567              		.loc 24 103 0
 5568 0104 0023     		movs	r3, #0
 5569 0106 2360     		str	r3, [r4, #0]	@ float
 5570              		.loc 24 104 0
 5571 0108 C2F8A030 		str	r3, [r2, #160]	@ float
 5572              	.L341:
 5573              	.LVL274:
 105:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     }
 106:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   }
 107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   // NEW SI Version
 108:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   #if defined (UseGPSNavigator) 
 109:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS] + gpsYawAxisCorrection) * 
 110:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   #else
 111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 5574              		.loc 24 111 0
 5575 010c 294B     		ldr	r3, .L361+64
 5576 010e B268     		ldr	r2, [r6, #8]
 5577 0110 9968     		ldr	r1, [r3, #8]
 5578 0112 501A     		subs	r0, r2, r1
 5579 0114 07EE900A 		fmsr	s15, r0	@ int
 112:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   #endif
 113:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   
 114:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   const float commandedYaw = constrain(receiverSiData + radians(headingHold), -PI, PI);
 5580              		.loc 24 114 0
 5581 0118 D4ED004A 		flds	s9, [r4, #0]
 111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 5582              		.loc 24 111 0
 5583 011c F8EEE73A 		fsitos	s7, s15
 5584              		.loc 24 114 0
 5585 0120 DFED257A 		flds	s15, .L361+68
 5586 0124 9FED254A 		flds	s8, .L361+72
 5587 0128 64EEA77A 		fmuls	s15, s9, s15
 5588 012c 43EE847A 		fmacs	s15, s7, s8
 5589 0130 9FED237A 		flds	s14, .L361+76
 5590 0134 F4EEC77A 		fcmpes	s15, s14
 5591 0138 F1EE10FA 		fmstat
 5592 013c 0BD4     		bmi	.L354
 5593              		.loc 24 114 0 is_stmt 0 discriminator 2
 5594 013e 9FED215A 		flds	s10, .L361+80
 5595 0142 F4EE457A 		fcmps	s15, s10
 5596 0146 F1EE10FA 		fmstat
 5597 014a CCBF     		ite	gt
 5598 014c 15EE100A 		fmrsgt	r0, s10
 5599 0150 17EE900A 		fmrsle	r0, s15
 5600 0154 01E0     		b	.L352
 5601              	.L354:
 5602              		.loc 24 114 0
 5603 0156 17EE100A 		fmrs	r0, s14
 5604              	.L352:
 115:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   motorAxisCommandYaw = updatePID(commandedYaw, gyroRate[ZAXIS], &PID[ZAXIS_PID_IDX]);
 5605              		.loc 24 115 0 is_stmt 1 discriminator 6
 5606 015a 1B49     		ldr	r1, .L361+84
 5607 015c 1B4A     		ldr	r2, .L361+88
 5608 015e 8968     		ldr	r1, [r1, #8]	@ float
 5609 0160 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 5610              	.LVL275:
 5611 0164 05EE900A 		fmsr	s11, r0
 5612 0168 1948     		ldr	r0, .L361+92
 5613 016a BDEEE56A 		ftosizs	s12, s11
 5614 016e 80ED006A 		fsts	s12, [r0, #0]	@ int
 5615              	.LBE132:
 116:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** }
 5616              		.loc 24 116 0 discriminator 6
 5617 0172 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5618              	.L362:
 5619              		.align	2
 5620              	.L361:
 5621 0174 00000000 		.word	.LANCHOR86
 5622 0178 00000000 		.word	.LANCHOR1
 5623 017c 00000000 		.word	.LANCHOR90
 5624 0180 00000000 		.word	.LANCHOR20
 5625 0184 00000000 		.word	.LANCHOR87
 5626 0188 00000000 		.word	.LANCHOR89
 5627 018c E12E6542 		.word	1113927393
 5628 0190 00000000 		.word	.LANCHOR88
 5629 0194 00003443 		.word	1127481344
 5630 0198 0000B443 		.word	1135869952
 5631 019c 00000000 		.word	.LANCHOR9
 5632 01a0 00000000 		.word	.LANCHOR91
 5633 01a4 00000000 		.word	.LANCHOR7
 5634 01a8 00000000 		.word	.LANCHOR92
 5635 01ac 20A10700 		.word	500000
 5636 01b0 8C000000 		.word	.LANCHOR9+140
 5637 01b4 00000000 		.word	.LANCHOR3
 5638 01b8 35FA8E3C 		.word	1016003125
 5639 01bc 0BD7A33B 		.word	1000593163
 5640 01c0 DB0F49C0 		.word	-1068953637
 5641 01c4 DB0F4940 		.word	1078530011
 5642 01c8 00000000 		.word	.LANCHOR19
 5643 01cc 38000000 		.word	.LANCHOR9+56
 5644 01d0 00000000 		.word	.LANCHOR76
 5645              		.cfi_endproc
 5646              	.LFE204:
 5648              		.section	.text._Z20processFlightControlv,"ax",%progbits
 5649              		.align	1
 5650              		.global	_Z20processFlightControlv
 5651              		.thumb
 5652              		.thumb_func
 5654              	_Z20processFlightControlv:
 5655              	.LFB201:
 267:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 268:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
 269:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processFlightControl
 270:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
 271:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Main flight control processos function
 272:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 273:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processFlightControl() {
 5656              		.loc 23 273 0
 5657              		.cfi_startproc
 5658              		@ args = 0, pretend = 0, frame = 0
 5659              		@ frame_needed = 0, uses_anonymous_args = 0
 5660 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5661              	.LCFI52:
 5662              		.cfi_def_cfa_offset 24
 5663              		.cfi_offset 14, -4
 5664              		.cfi_offset 7, -8
 5665              		.cfi_offset 6, -12
 5666              		.cfi_offset 5, -16
 5667              		.cfi_offset 4, -20
 5668              		.cfi_offset 3, -24
 5669              	.LBB133:
 274:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 275:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // ********************** Calculate Flight Error ***************************
 276:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   calculateFlightError();
 5670              		.loc 23 276 0
 5671 0002 FFF7FEFF 		bl	_Z20calculateFlightErrorv
 277:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 278:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // ********************** Update Yaw ***************************************
 279:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   processHeading();
 5672              		.loc 23 279 0
 5673 0006 FFF7FEFF 		bl	_Z14processHeadingv
 280:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 281:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (frameCounter % THROTTLE_ADJUST_TASK_SPEED == 0) {  // 50hz task
 5674              		.loc 23 281 0
 5675 000a 2948     		ldr	r0, .L378
 5676 000c 294D     		ldr	r5, .L378+4
 5677 000e 0368     		ldr	r3, [r0, #0]
 5678 0010 13F0010F 		tst	r3, #1
 5679 0014 04D1     		bne	.L364
 282:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 283:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process position hold or navigation **************************
 284:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined (UseGPS)
 285:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #if defined (UseGPSNavigator)
 286:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         processGpsNavigation();
 287:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #endif  
 288:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 289:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 290:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process Altitude hold **************************
 291:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 292:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       processAltitudeHold();
 293:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #else
 294:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       throttle = receiverCommand[THROTTLE];
 5680              		.loc 23 294 0
 5681 0016 EA68     		ldr	r2, [r5, #12]
 5682 0018 2749     		ldr	r1, .L378+8
 5683 001a 0A60     		str	r2, [r1, #0]
 295:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 296:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 297:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process Battery monitor hold **************************
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined BattMonitor && defined BattMonitorAutoDescent
 299:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       processBatteryMonitorThrottleAdjustment();
 300:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 301:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 302:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process Auto-Descent  **************************
 303:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined AutoLanding
 304:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       processAutoLandingAltitudeCorrection();
 305:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 306:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 307:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process throttle correction ********************
 308:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     processThrottleCorrection();
 5684              		.loc 23 308 0
 5685 001c FFF7FEFF 		bl	_Z25processThrottleCorrectionv
 5686              	.L364:
 309:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 310:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 311:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // ********************** Calculate Motor Commands *************************
 312:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (motorArmed && safetyCheck) {
 5687              		.loc 23 312 0
 5688 0020 264C     		ldr	r4, .L378+12
 5689 0022 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 5690 0024 23B1     		cbz	r3, .L365
 5691              		.loc 23 312 0 is_stmt 0 discriminator 1
 5692 0026 264A     		ldr	r2, .L378+16
 5693 0028 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 5694 002a 08B1     		cbz	r0, .L365
 313:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     applyMotorCommand();
 5695              		.loc 23 313 0 is_stmt 1
 5696 002c FFF7FEFF 		bl	_Z17applyMotorCommandv
 5697              	.L365:
 314:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   } 
 315:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 316:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // *********************** process min max motor command *******************
 317:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   processMinMaxCommand();
 5698              		.loc 23 317 0
 5699 0030 FFF7FEFF 		bl	_Z20processMinMaxCommandv
 5700              	.LBB134:
 318:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // If throttle in minimum position, don't apply yaw
 320:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 5701              		.loc 23 320 0
 5702 0034 ED68     		ldr	r5, [r5, #12]
 5703 0036 40F24B41 		movw	r1, #1099
 5704 003a 8D42     		cmp	r5, r1
 5705 003c 2149     		ldr	r1, .L378+20
 5706 003e 01DD     		ble	.L366
 5707              	.L370:
 5708              	.LVL276:
 5709              	.LBB135:
 321:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 324:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         motorMaxCommand[motor] = MAXCOMMAND;
 325:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 326:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       else {
 327:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         motorMaxCommand[motor] = minArmedThrottle;
 5710              		.loc 23 327 0 discriminator 1
 5711 0040 0023     		movs	r3, #0
 5712 0042 15E0     		b	.L367
 5713              	.LVL277:
 5714              	.L366:
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 5715              		.loc 23 323 0
 5716 0044 204E     		ldr	r6, .L378+24
 5717 0046 214F     		ldr	r7, .L378+28
 322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 5718              		.loc 23 322 0
 5719 0048 214B     		ldr	r3, .L378+32
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 5720              		.loc 23 323 0
 5721 004a 3678     		ldrb	r6, [r6, #0]	@ zero_extendqisi2
 5722 004c 3D78     		ldrb	r5, [r7, #0]	@ zero_extendqisi2
 322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 5723              		.loc 23 322 0
 5724 004e 1A68     		ldr	r2, [r3, #0]
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 5725              		.loc 23 323 0
 5726 0050 0023     		movs	r3, #0
 5727              	.L369:
 322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 5728              		.loc 23 322 0
 5729 0052 CA50     		str	r2, [r1, r3]
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 5730              		.loc 23 323 0
 5731 0054 2EB1     		cbz	r6, .L374
 5732              		.loc 23 327 0 discriminator 1
 5733 0056 002D     		cmp	r5, #0
 5734 0058 14BF     		ite	ne
 5735 005a 1046     		movne	r0, r2
 5736 005c 4FF4FA60 		moveq	r0, #2000
 5737 0060 00E0     		b	.L368
 5738              	.L374:
 5739              		.loc 23 327 0 is_stmt 0
 5740 0062 1046     		mov	r0, r2
 5741              	.L368:
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 5742              		.loc 23 323 0 is_stmt 1
 5743 0064 1B4F     		ldr	r7, .L378+36
 5744 0066 D851     		str	r0, [r3, r7]
 5745 0068 0433     		adds	r3, r3, #4
 321:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 5746              		.loc 23 321 0
 5747 006a 102B     		cmp	r3, #16
 5748 006c F1D1     		bne	.L369
 5749 006e E7E7     		b	.L370
 5750              	.LVL278:
 5751              	.L367:
 5752              	.LBE135:
 5753              	.LBE134:
 5754              	.LBB136:
 328:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 329:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 330:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 331:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 332:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // Apply limits to motor commands
 333:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 334:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorCommand[motor] = constrain(motorCommand[motor], motorMinCommand[motor], motorMaxCommand[mo
 5755              		.loc 23 334 0
 5756 0070 1948     		ldr	r0, .L378+40
 5757 0072 CA58     		ldr	r2, [r1, r3]
 5758 0074 1D58     		ldr	r5, [r3, r0]
 5759 0076 9542     		cmp	r5, r2
 5760 0078 04DB     		blt	.L371
 5761              		.loc 23 334 0 is_stmt 0 discriminator 2
 5762 007a 164A     		ldr	r2, .L378+36
 5763 007c 9A58     		ldr	r2, [r3, r2]
 5764 007e 9542     		cmp	r5, r2
 5765 0080 B8BF     		it	lt
 5766 0082 2A46     		movlt	r2, r5
 5767              	.L371:
 5768              		.loc 23 334 0 discriminator 6
 5769 0084 C250     		str	r2, [r0, r3]
 5770 0086 0433     		adds	r3, r3, #4
 333:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 5771              		.loc 23 333 0 is_stmt 1 discriminator 6
 5772 0088 102B     		cmp	r3, #16
 5773 008a F1D1     		bne	.L367
 5774              	.LBE136:
 335:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 336:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 337:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // ESC Calibration
 338:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (motorArmed == OFF) {
 5775              		.loc 23 338 0
 5776 008c 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 5777 008e 08B9     		cbnz	r0, .L372
 339:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     processCalibrateESC();
 5778              		.loc 23 339 0
 5779 0090 FFF7FEFF 		bl	_Z19processCalibrateESCv
 5780              	.L372:
 340:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 341:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 342:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // *********************** Command Motors **********************
 343:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (motorArmed == ON && safetyCheck == ON) {
 5781              		.loc 23 343 0
 5782 0094 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 5783 0096 0129     		cmp	r1, #1
 5784 0098 09D1     		bne	.L363
 5785              		.loc 23 343 0 is_stmt 0 discriminator 1
 5786 009a 094B     		ldr	r3, .L378+16
 5787 009c 93F800C0 		ldrb	ip, [r3, #0]	@ zero_extendqisi2
 5788 00a0 BCF1010F 		cmp	ip, #1
 5789 00a4 03D1     		bne	.L363
 5790              	.LBE133:
 344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     writeMotors();
 345:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 346:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 5791              		.loc 23 346 0 is_stmt 1
 5792 00a6 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 5793              	.LBB137:
 344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     writeMotors();
 5794              		.loc 23 344 0
 5795 00aa FFF7FEBF 		b	_Z11writeMotorsv
 5796              	.L363:
 5797 00ae F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5798              	.L379:
 5799              		.align	2
 5800              	.L378:
 5801 00b0 00000000 		.word	.LANCHOR93
 5802 00b4 00000000 		.word	.LANCHOR1
 5803 00b8 00000000 		.word	.LANCHOR73
 5804 00bc 00000000 		.word	.LANCHOR94
 5805 00c0 00000000 		.word	.LANCHOR82
 5806 00c4 00000000 		.word	.LANCHOR84
 5807 00c8 00000000 		.word	.LANCHOR8
 5808 00cc 00000000 		.word	.LANCHOR77
 5809 00d0 00000000 		.word	.LANCHOR83
 5810 00d4 00000000 		.word	.LANCHOR85
 5811 00d8 00000000 		.word	.LANCHOR56
 5812              	.LBE137:
 5813              		.cfi_endproc
 5814              	.LFE201:
 5816              		.section	.text._Z12nvrReadFloati,"ax",%progbits
 5817              		.align	1
 5818              		.global	_Z12nvrReadFloati
 5819              		.thumb
 5820              		.thumb_func
 5822              	_Z12nvrReadFloati:
 5823              	.LFB205:
 5824              		.file 25 "/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h"
   1:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** /*
   2:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   www.AeroQuad.com
   4:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   An Open Source Arduino based multicopter.
   6:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
   7:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   This program is free software: you can redistribute it and/or modify
   8:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   it under the terms of the GNU General Public License as published by
   9:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   the Free Software Foundation, either version 3 of the License, or
  10:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   (at your option) any later version.
  11:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  12:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   This program is distributed in the hope that it will be useful,
  13:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   GNU General Public License for more details.
  16:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  17:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   You should have received a copy of the GNU General Public License
  18:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** */
  20:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  21:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** // Special thanks for 1k space optimization update from Ala42
  22:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** // http://aeroquad.com/showthread.php?1369-The-big-enhancement-addition-to-2.0-code&p=13359&viewful
  23:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  24:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifndef _AQ_DATA_STORAGE_H_
  25:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #define _AQ_DATA_STORAGE_H_
  26:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  27:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** // Utilities for writing and reading from the EEPROM
  28:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** float nvrReadFloat(int address) {
 5825              		.loc 25 28 0
 5826              		.cfi_startproc
 5827              		@ args = 0, pretend = 0, frame = 0
 5828              		@ frame_needed = 0, uses_anonymous_args = 0
 5829              	.LVL279:
 5830 0000 38B5     		push	{r3, r4, r5, lr}
 5831              	.LCFI53:
 5832              		.cfi_def_cfa_offset 16
 5833              		.cfi_offset 14, -4
 5834              		.cfi_offset 5, -8
 5835              		.cfi_offset 4, -12
 5836              		.cfi_offset 3, -16
 5837              	.LBB138:
 5838              	.LBB139:
  29:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   union floatStore {
  30:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     byte floatByte[4];
  31:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     unsigned short floatUShort[2];
  32:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     float floatVal;
  33:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   } floatOut;
  34:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  35:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  36:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 2; i++) {
  37:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     floatOut.floatUShort[i] = EEPROM.read(address + 2*i);
 5839              		.loc 25 37 0
 5840 0002 85B2     		uxth	r5, r0
 5841 0004 2946     		mov	r1, r5
 5842 0006 0748     		ldr	r0, .L381
 5843              	.LVL280:
 5844 0008 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 5845 000c 0024     		movs	r4, #0
 5846              	.LVL281:
 5847 000e A91C     		adds	r1, r5, #2
 5848 0010 60F30F04 		bfi	r4, r0, #0, #16
 5849              	.LVL282:
 5850 0014 89B2     		uxth	r1, r1
 5851 0016 0348     		ldr	r0, .L381
 5852 0018 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 5853 001c 60F31F44 		bfi	r4, r0, #16, #16
 5854              	.LVL283:
 5855              	.LBE139:
  38:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  39:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #else
  40:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 4; i++) {
  41:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     floatOut.floatByte[i] = EEPROM.read(address + i);
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  43:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #endif
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  45:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   return floatOut.floatVal;
 5856              		.loc 25 45 0
 5857 0020 2046     		mov	r0, r4	@ float
 5858              	.LBE138:
  46:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 5859              		.loc 25 46 0
 5860 0022 38BD     		pop	{r3, r4, r5, pc}
 5861              	.L382:
 5862              		.align	2
 5863              	.L381:
 5864 0024 00000000 		.word	EEPROM
 5865              		.cfi_endproc
 5866              	.LFE205:
 5868              		.section	.text._Z13nvrWriteFloatfi,"ax",%progbits
 5869              		.align	1
 5870              		.global	_Z13nvrWriteFloatfi
 5871              		.thumb
 5872              		.thumb_func
 5874              	_Z13nvrWriteFloatfi:
 5875              	.LFB206:
  47:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  48:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrWriteFloat(float value, int address) {
 5876              		.loc 25 48 0
 5877              		.cfi_startproc
 5878              		@ args = 0, pretend = 0, frame = 0
 5879              		@ frame_needed = 0, uses_anonymous_args = 0
 5880              	.LVL284:
 5881 0000 38B5     		push	{r3, r4, r5, lr}
 5882              	.LCFI54:
 5883              		.cfi_def_cfa_offset 16
 5884              		.cfi_offset 14, -4
 5885              		.cfi_offset 5, -8
 5886              		.cfi_offset 4, -12
 5887              		.cfi_offset 3, -16
 5888              	.LBB140:
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   union floatStore {
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     byte floatByte[4];
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     unsigned short floatUShort[2];
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     float floatVal;
  53:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   } floatIn;
  54:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   floatIn.floatVal = value;
 5889              		.loc 25 55 0
 5890 0002 0446     		mov	r4, r0	@ float
 5891              	.LVL285:
 5892              	.LBB141:
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  57:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 2; i++) {
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 5893              		.loc 25 58 0
 5894 0004 8DB2     		uxth	r5, r1
 5895 0006 2946     		mov	r1, r5
 5896              	.LVL286:
 5897 0008 A2B2     		uxth	r2, r4
 5898 000a 0548     		ldr	r0, .L384
 5899              	.LVL287:
 5900 000c FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 5901              	.LVL288:
 5902 0010 A91C     		adds	r1, r5, #2
 5903 0012 0348     		ldr	r0, .L384
 5904 0014 89B2     		uxth	r1, r1
 5905 0016 220C     		lsrs	r2, r4, #16
 5906              	.LBE141:
 5907              	.LBE140:
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #else
  61:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 4; i++) {
  62:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + i, floatIn.floatByte[i]);
  63:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #endif
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 5908              		.loc 25 65 0
 5909 0018 BDE83840 		pop	{r3, r4, r5, lr}
 5910              	.LBB143:
 5911              	.LBB142:
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 5912              		.loc 25 58 0
 5913 001c FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 5914              	.L385:
 5915              		.align	2
 5916              	.L384:
 5917 0020 00000000 		.word	EEPROM
 5918              	.LBE142:
 5919              	.LBE143:
 5920              		.cfi_endproc
 5921              	.LFE206:
 5923              		.section	.text._Z11nvrReadLongi,"ax",%progbits
 5924              		.align	1
 5925              		.global	_Z11nvrReadLongi
 5926              		.thumb
 5927              		.thumb_func
 5929              	_Z11nvrReadLongi:
 5930              	.LFB207:
  66:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  67:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** long nvrReadLong(int address) {
 5931              		.loc 25 67 0
 5932              		.cfi_startproc
 5933              		@ args = 0, pretend = 0, frame = 0
 5934              		@ frame_needed = 0, uses_anonymous_args = 0
 5935              	.LVL289:
 5936 0000 38B5     		push	{r3, r4, r5, lr}
 5937              	.LCFI55:
 5938              		.cfi_def_cfa_offset 16
 5939              		.cfi_offset 14, -4
 5940              		.cfi_offset 5, -8
 5941              		.cfi_offset 4, -12
 5942              		.cfi_offset 3, -16
 5943              	.LBB144:
 5944              	.LBB145:
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   union longStore {
  69:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     byte longByte[4];
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     unsigned short longUShort[2];
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     long longVal;
  72:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   } longOut;  
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  75:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 2; i++) {
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     longOut.longUShort[i] = EEPROM.read(address + 2*i);
 5945              		.loc 25 76 0
 5946 0002 85B2     		uxth	r5, r0
 5947 0004 2946     		mov	r1, r5
 5948 0006 0748     		ldr	r0, .L387
 5949              	.LVL290:
 5950 0008 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 5951 000c 0024     		movs	r4, #0
 5952              	.LVL291:
 5953 000e A91C     		adds	r1, r5, #2
 5954 0010 60F30F04 		bfi	r4, r0, #0, #16
 5955              	.LVL292:
 5956 0014 89B2     		uxth	r1, r1
 5957 0016 0348     		ldr	r0, .L387
 5958 0018 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 5959 001c 60F31F44 		bfi	r4, r0, #16, #16
 5960              	.LVL293:
 5961              	.LBE145:
 5962              	.LBE144:
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #else
  79:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte i = 0; i < 4; i++) {
  80:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     longOut.longByte[i] = EEPROM.read(address + i);
  81:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #endif
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   return longOut.longVal;
  85:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 5963              		.loc 25 85 0
 5964 0020 2046     		mov	r0, r4
 5965 0022 38BD     		pop	{r3, r4, r5, pc}
 5966              	.L388:
 5967              		.align	2
 5968              	.L387:
 5969 0024 00000000 		.word	EEPROM
 5970              		.cfi_endproc
 5971              	.LFE207:
 5973              		.section	.text._Z12nvrWriteLongli,"ax",%progbits
 5974              		.align	1
 5975              		.global	_Z12nvrWriteLongli
 5976              		.thumb
 5977              		.thumb_func
 5979              	_Z12nvrWriteLongli:
 5980              	.LFB208:
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrWriteLong(long value, int address) {
 5981              		.loc 25 87 0
 5982              		.cfi_startproc
 5983              		@ args = 0, pretend = 0, frame = 0
 5984              		@ frame_needed = 0, uses_anonymous_args = 0
 5985              	.LVL294:
 5986 0000 38B5     		push	{r3, r4, r5, lr}
 5987              	.LCFI56:
 5988              		.cfi_def_cfa_offset 16
 5989              		.cfi_offset 14, -4
 5990              		.cfi_offset 5, -8
 5991              		.cfi_offset 4, -12
 5992              		.cfi_offset 3, -16
 5993              		.loc 25 87 0
 5994 0002 0446     		mov	r4, r0
 5995              	.LBB146:
 5996              	.LBB147:
  88:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   union longStore {
  89:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     byte longByte[4];
  90:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     unsigned short longUShort[2];
  91:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     long longVal;
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   } longIn;  
  93:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  94:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   longIn.longVal = value;
  95:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
  96:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  97:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 2; i++) {
  98:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 5997              		.loc 25 98 0
 5998 0004 8DB2     		uxth	r5, r1
 5999 0006 2946     		mov	r1, r5
 6000              	.LVL295:
 6001 0008 A2B2     		uxth	r2, r4
 6002 000a 0548     		ldr	r0, .L390
 6003              	.LVL296:
 6004 000c FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 6005              	.LVL297:
 6006 0010 A91C     		adds	r1, r5, #2
 6007 0012 0348     		ldr	r0, .L390
 6008 0014 89B2     		uxth	r1, r1
 6009 0016 220C     		lsrs	r2, r4, #16
 6010              	.LBE147:
 6011              	.LBE146:
  99:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 100:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #else
 101:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 4; i++) {
 102:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + i, longIn.longByte[i]);
 103:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 104:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #endif
 105:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 6012              		.loc 25 105 0
 6013 0018 BDE83840 		pop	{r3, r4, r5, lr}
 6014              	.LBB149:
 6015              	.LBB148:
  98:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 6016              		.loc 25 98 0
 6017 001c FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 6018              	.L391:
 6019              		.align	2
 6020              	.L390:
 6021 0020 00000000 		.word	EEPROM
 6022              	.LBE148:
 6023              	.LBE149:
 6024              		.cfi_endproc
 6025              	.LFE208:
 6027              		.section	.text._Z10nvrReadPIDhj,"ax",%progbits
 6028              		.align	1
 6029              		.global	_Z10nvrReadPIDhj
 6030              		.thumb
 6031              		.thumb_func
 6033              	_Z10nvrReadPIDhj:
 6034              	.LFB209:
 106:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 6035              		.loc 25 107 0
 6036              		.cfi_startproc
 6037              		@ args = 0, pretend = 0, frame = 0
 6038              		@ frame_needed = 0, uses_anonymous_args = 0
 6039              	.LVL298:
 6040              	.LBB150:
 108:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 6041              		.loc 25 108 0
 6042 0000 0B4A     		ldr	r2, .L393
 6043              	.LBE150:
 107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 6044              		.loc 25 107 0
 6045 0002 38B5     		push	{r3, r4, r5, lr}
 6046              	.LCFI57:
 6047              		.cfi_def_cfa_offset 16
 6048              		.cfi_offset 14, -4
 6049              		.cfi_offset 5, -8
 6050              		.cfi_offset 4, -12
 6051              		.cfi_offset 3, -16
 6052              	.LBB151:
 6053              		.loc 25 108 0
 6054 0004 1C24     		movs	r4, #28
 6055 0006 04FB0024 		mla	r4, r4, r0, r2
 6056              	.LVL299:
 109:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->P = nvrReadFloat(IDEeprom);
 6057              		.loc 25 109 0
 6058 000a 0846     		mov	r0, r1
 6059              	.LVL300:
 6060              	.LBE151:
 107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 6061              		.loc 25 107 0
 6062 000c 0D46     		mov	r5, r1
 6063              	.LBB152:
 6064              		.loc 25 109 0
 6065 000e FFF7FEFF 		bl	_Z12nvrReadFloati
 6066              	.LVL301:
 6067 0012 2060     		str	r0, [r4, #0]	@ float
 110:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->I = nvrReadFloat(IDEeprom+4);
 6068              		.loc 25 110 0
 6069 0014 281D     		adds	r0, r5, #4
 6070 0016 FFF7FEFF 		bl	_Z12nvrReadFloati
 6071 001a 6060     		str	r0, [r4, #4]	@ float
 111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 6072              		.loc 25 111 0
 6073 001c 05F10800 		add	r0, r5, #8
 6074 0020 FFF7FEFF 		bl	_Z12nvrReadFloati
 112:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->lastError = 0;
 6075              		.loc 25 112 0
 6076 0024 0023     		movs	r3, #0
 111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 6077              		.loc 25 111 0
 6078 0026 A060     		str	r0, [r4, #8]	@ float
 6079              		.loc 25 112 0
 6080 0028 E360     		str	r3, [r4, #12]	@ float
 113:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->integratedError = 0;
 6081              		.loc 25 113 0
 6082 002a 6361     		str	r3, [r4, #20]	@ float
 6083              	.LBE152:
 114:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 6084              		.loc 25 114 0
 6085 002c 38BD     		pop	{r3, r4, r5, pc}
 6086              	.L394:
 6087 002e 00BF     		.align	2
 6088              	.L393:
 6089 0030 00000000 		.word	.LANCHOR9
 6090              		.cfi_endproc
 6091              	.LFE209:
 6093              		.section	.text._Z11nvrWritePIDhj,"ax",%progbits
 6094              		.align	1
 6095              		.global	_Z11nvrWritePIDhj
 6096              		.thumb
 6097              		.thumb_func
 6099              	_Z11nvrWritePIDhj:
 6100              	.LFB210:
 115:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 116:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 6101              		.loc 25 116 0
 6102              		.cfi_startproc
 6103              		@ args = 0, pretend = 0, frame = 0
 6104              		@ frame_needed = 0, uses_anonymous_args = 0
 6105              	.LVL302:
 6106 0000 38B5     		push	{r3, r4, r5, lr}
 6107              	.LCFI58:
 6108              		.cfi_def_cfa_offset 16
 6109              		.cfi_offset 14, -4
 6110              		.cfi_offset 5, -8
 6111              		.cfi_offset 4, -12
 6112              		.cfi_offset 3, -16
 6113              	.LBB153:
 117:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 6114              		.loc 25 117 0
 6115 0002 094B     		ldr	r3, .L396
 6116 0004 1C24     		movs	r4, #28
 6117 0006 04FB0034 		mla	r4, r4, r0, r3
 6118              	.LVL303:
 6119              	.LBE153:
 116:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 6120              		.loc 25 116 0
 6121 000a 0D46     		mov	r5, r1
 6122              	.LBB154:
 118:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   nvrWriteFloat(pid->P, IDEeprom);
 6123              		.loc 25 118 0
 6124 000c 2068     		ldr	r0, [r4, #0]	@ float
 6125              	.LVL304:
 6126 000e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 6127              	.LVL305:
 119:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   nvrWriteFloat(pid->I, IDEeprom+4);
 6128              		.loc 25 119 0
 6129 0012 6068     		ldr	r0, [r4, #4]	@ float
 6130 0014 291D     		adds	r1, r5, #4
 6131 0016 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 120:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 6132              		.loc 25 120 0
 6133 001a A068     		ldr	r0, [r4, #8]	@ float
 6134 001c 05F10801 		add	r1, r5, #8
 6135              	.LBE154:
 121:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 6136              		.loc 25 121 0
 6137 0020 BDE83840 		pop	{r3, r4, r5, lr}
 6138              	.LBB155:
 120:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 6139              		.loc 25 120 0
 6140 0024 FFF7FEBF 		b	_Z13nvrWriteFloatfi
 6141              	.L397:
 6142              		.align	2
 6143              	.L396:
 6144 0028 00000000 		.word	.LANCHOR9
 6145              	.LBE155:
 6146              		.cfi_endproc
 6147              	.LFE210:
 6149              		.section	.text._Z16initializeEEPROMv,"ax",%progbits
 6150              		.align	1
 6151              		.global	_Z16initializeEEPROMv
 6152              		.thumb
 6153              		.thumb_func
 6155              	_Z16initializeEEPROMv:
 6156              	.LFB211:
 122:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 123:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** // contains all default values when re-writing EEPROM
 124:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void initializeEEPROM() {
 6157              		.loc 25 124 0
 6158              		.cfi_startproc
 6159              		@ args = 0, pretend = 0, frame = 0
 6160              		@ frame_needed = 0, uses_anonymous_args = 0
 6161 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 6162              	.LCFI59:
 6163              		.cfi_def_cfa_offset 24
 6164              		.cfi_offset 14, -4
 6165              		.cfi_offset 7, -8
 6166              		.cfi_offset 6, -12
 6167              		.cfi_offset 5, -16
 6168              		.cfi_offset 4, -20
 6169              		.cfi_offset 3, -24
 6170              	.LBB156:
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 127:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 128:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 129:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 150.0;
 130:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -350.0;
 131:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 3.5;
 6171              		.loc 25 131 0
 6172 0002 4349     		ldr	r1, .L401
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 6173              		.loc 25 125 0
 6174 0004 434C     		ldr	r4, .L401+4
 127:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 6175              		.loc 25 127 0
 6176 0006 444E     		ldr	r6, .L401+8
 132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 133:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 134:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].P = 3.5;
 135:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 136:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 137:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 6177              		.loc 25 137 0
 6178 0008 444F     		ldr	r7, .L401+12
 126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 6179              		.loc 25 126 0
 6180 000a 454D     		ldr	r5, .L401+16
 131:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 3.5;
 6181              		.loc 25 131 0
 6182 000c 6165     		str	r1, [r4, #84]	@ float
 134:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].P = 3.5;
 6183              		.loc 25 134 0
 6184 000e 2167     		str	r1, [r4, #112]	@ float
 138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 139:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 140:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 141:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 142:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 143:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // AKA PID experiements
 144:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 145:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 146:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -350.0;
 147:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 148:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 149:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -350.0;
 150:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   rotationSpeedFactor = 1.0;
 6185              		.loc 25 150 0
 6186 0010 4449     		ldr	r1, .L401+20
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 6187              		.loc 25 125 0
 6188 0012 454A     		ldr	r2, .L401+24
 140:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 6189              		.loc 25 140 0
 6190 0014 4548     		ldr	r0, .L401+28
 141:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 6191              		.loc 25 141 0
 6192 0016 464B     		ldr	r3, .L401+32
 127:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 6193              		.loc 25 127 0
 6194 0018 A660     		str	r6, [r4, #8]	@ float
 130:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -350.0;
 6195              		.loc 25 130 0
 6196 001a 6662     		str	r6, [r4, #36]	@ float
 137:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 6197              		.loc 25 137 0
 6198 001c A763     		str	r7, [r4, #56]	@ float
 146:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -350.0;
 6199              		.loc 25 146 0
 6200 001e C4F8B060 		str	r6, [r4, #176]	@ float
 149:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -350.0;
 6201              		.loc 25 149 0
 6202 0022 C4F8CC60 		str	r6, [r4, #204]	@ float
 138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 6203              		.loc 25 138 0
 6204 0026 434F     		ldr	r7, .L401+36
 126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 6205              		.loc 25 126 0
 6206 0028 6560     		str	r5, [r4, #4]	@ float
 6207              		.loc 25 150 0
 6208 002a 4FF07E56 		mov	r6, #1065353216
 129:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 150.0;
 6209              		.loc 25 129 0
 6210 002e 2562     		str	r5, [r4, #32]	@ float
 6211              		.loc 25 150 0
 6212 0030 0E60     		str	r6, [r1, #0]	@ float
 132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 6213              		.loc 25 132 0
 6214 0032 0025     		movs	r5, #0
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 6215              		.loc 25 125 0
 6216 0034 2260     		str	r2, [r4, #0]	@ float
 128:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 6217              		.loc 25 128 0
 6218 0036 E261     		str	r2, [r4, #28]	@ float
 140:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 6219              		.loc 25 140 0
 6220 0038 C4F88C00 		str	r0, [r4, #140]	@ float
 141:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 6221              		.loc 25 141 0
 6222 003c C4F89030 		str	r3, [r4, #144]	@ float
 144:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 6223              		.loc 25 144 0
 6224 0040 C4F8A820 		str	r2, [r4, #168]	@ float
 147:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 6225              		.loc 25 147 0
 6226 0044 C4F8C420 		str	r2, [r4, #196]	@ float
 132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 6227              		.loc 25 132 0
 6228 0048 A565     		str	r5, [r4, #88]	@ float
 133:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 6229              		.loc 25 133 0
 6230 004a E565     		str	r5, [r4, #92]	@ float
 135:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 6231              		.loc 25 135 0
 6232 004c 6567     		str	r5, [r4, #116]	@ float
 136:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 6233              		.loc 25 136 0
 6234 004e A567     		str	r5, [r4, #120]	@ float
 138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 6235              		.loc 25 138 0
 6236 0050 E763     		str	r7, [r4, #60]	@ float
 139:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 6237              		.loc 25 139 0
 6238 0052 2564     		str	r5, [r4, #64]	@ float
 142:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 6239              		.loc 25 142 0
 6240 0054 C4F89450 		str	r5, [r4, #148]	@ float
 145:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 6241              		.loc 25 145 0
 6242 0058 C4F8AC50 		str	r5, [r4, #172]	@ float
 148:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 6243              		.loc 25 148 0
 6244 005c C4F8C850 		str	r5, [r4, #200]	@ float
 151:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 152:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (AltitudeHoldBaro)
 153:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 154:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 155:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 156:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too 
 157:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].P = 0.0;
 158:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].I = 0.0;
 159:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].D = 0.0;
 160:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 161:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 162:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = 50.0;
 163:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 164:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 165:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too
 166:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 167:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 168:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 169:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 170:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     minThrottleAdjust = -50.0;
 171:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     maxThrottleAdjust = 50.0; //we don't want it to be able to take over totally
 172:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 173:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       baroSmoothFactor = 0.1;
 174:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 175:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldBump = 90;
 176:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldPanicStickMovement = 250;
 177:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 178:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 179:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   initializePlatformSpecificAccelCalibration();
 6245              		.loc 25 179 0
 6246 0060 FFF7FEFF 		bl	_Z42initializePlatformSpecificAccelCalibrationv
 180:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 181:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   windupGuard = 1000.0;
 6247              		.loc 25 181 0
 6248 0064 344B     		ldr	r3, .L401+40
 6249 0066 3548     		ldr	r0, .L401+44
 182:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 183:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // AKA - added so that each PID has its own windupGuard, will need to be removed once each PID's 
 184:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 185:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 186:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       if (i != BARO_ALTITUDE_HOLD_PID_IDX) {
 187:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****         PID[i].windupGuard = windupGuard;
 188:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       }
 189:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #else
 190:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       PID[i].windupGuard = windupGuard;
 191:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 192:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 193:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
 194:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverXmitFactor = 1.0;
 6250              		.loc 25 194 0
 6251 0068 354A     		ldr	r2, .L401+48
 181:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   windupGuard = 1000.0;
 6252              		.loc 25 181 0
 6253 006a 0360     		str	r3, [r0, #0]	@ float
 6254              	.LVL306:
 195:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   minArmedThrottle = 1150;
 6255              		.loc 25 195 0
 6256 006c 3549     		ldr	r1, .L401+52
 6257              	.LBB157:
 190:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       PID[i].windupGuard = windupGuard;
 6258              		.loc 25 190 0
 6259 006e A361     		str	r3, [r4, #24]	@ float
 6260              	.LVL307:
 6261 0070 6363     		str	r3, [r4, #52]	@ float
 6262              	.LVL308:
 6263 0072 2365     		str	r3, [r4, #80]	@ float
 6264              	.LVL309:
 6265 0074 E366     		str	r3, [r4, #108]	@ float
 6266              	.LVL310:
 6267 0076 C4F88830 		str	r3, [r4, #136]	@ float
 6268              	.LVL311:
 6269 007a C4F8A430 		str	r3, [r4, #164]	@ float
 6270              	.LVL312:
 6271 007e C4F8C030 		str	r3, [r4, #192]	@ float
 6272              	.LVL313:
 6273 0082 C4F8DC30 		str	r3, [r4, #220]	@ float
 6274              	.LVL314:
 6275              	.LBE157:
 194:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverXmitFactor = 1.0;
 6276              		.loc 25 194 0
 6277 0086 1660     		str	r6, [r2, #0]	@ float
 196:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // AKA - old setOneG not in SI - accel->setOneG(500);
 197:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelOneG = -9.80665; // AKA set one G to 9.8 m/s^2
 6278              		.loc 25 197 0
 6279 0088 2F4B     		ldr	r3, .L401+56
 6280 008a 304A     		ldr	r2, .L401+60
 195:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   minArmedThrottle = 1150;
 6281              		.loc 25 195 0
 6282 008c 40F27E40 		movw	r0, #1150
 6283 0090 0860     		str	r0, [r1, #0]
 6284              		.loc 25 197 0
 6285 0092 1A60     		str	r2, [r3, #0]	@ float
 6286              	.LVL315:
 6287 0094 2E48     		ldr	r0, .L401+64
 6288 0096 2F49     		ldr	r1, .L401+68
 6289 0098 2F4A     		ldr	r2, .L401+72
 6290 009a 0823     		movs	r3, #8
 6291              	.LVL316:
 6292              	.L399:
 6293              	.LBB158:
 198:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 199:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSlope[channel] = 1.0;
 200:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverOffset[channel] = 0.0;
 201:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSmoothFactor[channel] = 1.0;
 6294              		.loc 25 201 0 discriminator 2
 6295 009c 013B     		subs	r3, r3, #1
 6296 009e DBB2     		uxtb	r3, r3
 199:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSlope[channel] = 1.0;
 6297              		.loc 25 199 0 discriminator 2
 6298 00a0 40F8046F 		str	r6, [r0, #4]!	@ float
 200:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverOffset[channel] = 0.0;
 6299              		.loc 25 200 0 discriminator 2
 6300 00a4 41F8045F 		str	r5, [r1, #4]!	@ float
 6301              		.loc 25 201 0 discriminator 2
 6302 00a8 42F8046F 		str	r6, [r2, #4]!	@ float
 198:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 6303              		.loc 25 198 0 discriminator 2
 6304 00ac 002B     		cmp	r3, #0
 6305 00ae F5D1     		bne	.L399
 6306              	.LBE158:
 202:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 203:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 6307              		.loc 25 203 0
 6308 00b0 2A4A     		ldr	r2, .L401+76
 204:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 205:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   flightMode = RATE_FLIGHT_MODE;
 6309              		.loc 25 205 0
 6310 00b2 2B49     		ldr	r1, .L401+80
 203:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 6311              		.loc 25 203 0
 6312 00b4 4FF07C50 		mov	r0, #1056964608
 6313 00b8 9060     		str	r0, [r2, #8]	@ float
 206:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = ON;
 6314              		.loc 25 206 0
 6315 00ba 2A48     		ldr	r0, .L401+84
 207:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 6316              		.loc 25 207 0
 6317 00bc 2A4A     		ldr	r2, .L401+88
 205:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   flightMode = RATE_FLIGHT_MODE;
 6318              		.loc 25 205 0
 6319 00be 0B70     		strb	r3, [r1, #0]
 206:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = ON;
 6320              		.loc 25 206 0
 6321 00c0 0123     		movs	r3, #1
 6322 00c2 0370     		strb	r3, [r0, #0]
 6323              		.loc 25 207 0
 6324 00c4 1760     		str	r7, [r2, #0]	@ float
 208:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 209:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Battery Monitor
 210:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef BattMonitor
 211:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorAlarmVoltage = 3.33;
 212:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorThrottleTarget = 1450;
 213:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorGoingDownTime = 60000;
 214:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 215:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 216:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Range Finder
 217:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 218:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     maxRangeFinderRange = 4.5;
 219:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     minRangeFinderRange = 0.0;
 220:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 221:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 222:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (UseGPSNavigator)
 223:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     missionNbPoint = 0;
 224:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].P = 0.8;
 225:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].I = 0.0;
 226:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].D = 0.0;
 227:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].P = 0.8;
 228:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].I = 0.0;
 229:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].D = 0.0;
 230:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].P = 50.0;
 231:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].I = 0.0;
 232:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].D = 0.0;
 233:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 234:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 235:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].longitude = GPS_INVALID_ANGLE;
 236:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].latitude = GPS_INVALID_ANGLE;
 237:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].altitude = GPS_INVALID_ALTITUDE;
 238:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     }
 239:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 240:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 241:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Camera Control
 242:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef CameraControl
 243:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     cameraMode = 1;
 6325              		.loc 25 243 0
 6326 00c6 2949     		ldr	r1, .L401+92
 244:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraPitch = 1273.2;    
 6327              		.loc 25 244 0
 6328 00c8 294A     		ldr	r2, .L401+96
 6329 00ca 2A48     		ldr	r0, .L401+100
 243:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     cameraMode = 1;
 6330              		.loc 25 243 0
 6331 00cc 0B60     		str	r3, [r1, #0]
 6332              		.loc 25 244 0
 6333 00ce 0260     		str	r2, [r0, #0]	@ float
 245:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraRoll = 636.6;    
 6334              		.loc 25 245 0
 6335 00d0 2949     		ldr	r1, .L401+104
 6336 00d2 2A4B     		ldr	r3, .L401+108
 246:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraYaw = 318.3;
 6337              		.loc 25 246 0
 6338 00d4 2A4A     		ldr	r2, .L401+112
 6339 00d6 2B48     		ldr	r0, .L401+116
 245:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraRoll = 636.6;    
 6340              		.loc 25 245 0
 6341 00d8 1960     		str	r1, [r3, #0]	@ float
 6342              		.loc 25 246 0
 6343 00da 0260     		str	r2, [r0, #0]	@ float
 247:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterPitch = 1500;
 6344              		.loc 25 247 0
 6345 00dc 2A4B     		ldr	r3, .L401+120
 248:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterRoll = 1500;
 6346              		.loc 25 248 0
 6347 00de 2B49     		ldr	r1, .L401+124
 249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterYaw = 1500;
 6348              		.loc 25 249 0
 6349 00e0 2B4A     		ldr	r2, .L401+128
 247:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterPitch = 1500;
 6350              		.loc 25 247 0
 6351 00e2 40F2DC50 		movw	r0, #1500
 6352 00e6 1860     		str	r0, [r3, #0]
 248:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterRoll = 1500;
 6353              		.loc 25 248 0
 6354 00e8 0860     		str	r0, [r1, #0]
 6355              		.loc 25 249 0
 6356 00ea 1060     		str	r0, [r2, #0]
 250:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinPitch = 1000;
 6357              		.loc 25 250 0
 6358 00ec 294B     		ldr	r3, .L401+132
 251:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinRoll = 1000;
 6359              		.loc 25 251 0
 6360 00ee 2A49     		ldr	r1, .L401+136
 252:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinYaw = 1000;
 6361              		.loc 25 252 0
 6362 00f0 2A4A     		ldr	r2, .L401+140
 250:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinPitch = 1000;
 6363              		.loc 25 250 0
 6364 00f2 4FF47A70 		mov	r0, #1000
 6365 00f6 1860     		str	r0, [r3, #0]
 251:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinRoll = 1000;
 6366              		.loc 25 251 0
 6367 00f8 0860     		str	r0, [r1, #0]
 6368              		.loc 25 252 0
 6369 00fa 1060     		str	r0, [r2, #0]
 253:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxPitch = 2000;
 6370              		.loc 25 253 0
 6371 00fc 284B     		ldr	r3, .L401+144
 254:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxRoll = 2000;
 6372              		.loc 25 254 0
 6373 00fe 2949     		ldr	r1, .L401+148
 255:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxYaw = 2000;
 6374              		.loc 25 255 0
 6375 0100 294A     		ldr	r2, .L401+152
 253:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxPitch = 2000;
 6376              		.loc 25 253 0
 6377 0102 4FF4FA60 		mov	r0, #2000
 6378 0106 1860     		str	r0, [r3, #0]
 254:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxRoll = 2000;
 6379              		.loc 25 254 0
 6380 0108 0860     		str	r0, [r1, #0]
 6381              		.loc 25 255 0
 6382 010a 1060     		str	r0, [r2, #0]
 6383              	.LBE156:
 256:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #ifdef CameraTXControl
 257:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       servoTXChannels = 1;
 258:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 259:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 260:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 6384              		.loc 25 260 0
 6385 010c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 6386              	.L402:
 6387 010e 00BF     		.align	2
 6388              	.L401:
 6389 0110 00006040 		.word	1080033280
 6390 0114 00000000 		.word	.LANCHOR9
 6391 0118 0000AFC3 		.word	-1011941376
 6392 011c 00004843 		.word	1128792064
 6393 0120 00001643 		.word	1125515264
 6394 0124 00000000 		.word	.LANCHOR78
 6395 0128 0000C842 		.word	1120403456
 6396 012c 00004040 		.word	1077936128
 6397 0130 CDCCCC3D 		.word	1036831949
 6398 0134 0000A040 		.word	1084227584
 6399 0138 00007A44 		.word	1148846080
 6400 013c 00000000 		.word	.LANCHOR95
 6401 0140 00000000 		.word	.LANCHOR55
 6402 0144 00000000 		.word	.LANCHOR83
 6403 0148 00000000 		.word	.LANCHOR31
 6404 014c 0AE81CC1 		.word	-1055070198
 6405 0150 FCFFFFFF 		.word	.LANCHOR4-4
 6406 0154 FCFFFFFF 		.word	.LANCHOR5-4
 6407 0158 FCFFFFFF 		.word	.LANCHOR6-4
 6408 015c 00000000 		.word	.LANCHOR6
 6409 0160 00000000 		.word	.LANCHOR77
 6410 0164 00000000 		.word	.LANCHOR86
 6411 0168 00000000 		.word	.LANCHOR96
 6412 016c 00000000 		.word	.LANCHOR60
 6413 0170 66269F44 		.word	1151280742
 6414 0174 00000000 		.word	.LANCHOR61
 6415 0178 66261F44 		.word	1142892134
 6416 017c 00000000 		.word	.LANCHOR65
 6417 0180 66269F43 		.word	1134503526
 6418 0184 00000000 		.word	.LANCHOR69
 6419 0188 00000000 		.word	.LANCHOR62
 6420 018c 00000000 		.word	.LANCHOR66
 6421 0190 00000000 		.word	.LANCHOR70
 6422 0194 00000000 		.word	.LANCHOR63
 6423 0198 00000000 		.word	.LANCHOR67
 6424 019c 00000000 		.word	.LANCHOR71
 6425 01a0 00000000 		.word	.LANCHOR64
 6426 01a4 00000000 		.word	.LANCHOR68
 6427 01a8 00000000 		.word	.LANCHOR72
 6428              		.cfi_endproc
 6429              	.LFE211:
 6431              		.section	.text._Z10readEEPROMv,"ax",%progbits
 6432              		.align	1
 6433              		.global	_Z10readEEPROMv
 6434              		.thumb
 6435              		.thumb_func
 6437              	_Z10readEEPROMv:
 6438              	.LFB212:
 261:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 262:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void readEEPROM() {
 6439              		.loc 25 262 0
 6440              		.cfi_startproc
 6441              		@ args = 0, pretend = 0, frame = 0
 6442              		@ frame_needed = 0, uses_anonymous_args = 0
 6443              	.LBB159:
 263:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(XAXIS, ROLL_PID_GAIN_ADR);
 6444              		.loc 25 263 0
 6445 0000 0020     		movs	r0, #0
 6446              	.LBE159:
 262:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void readEEPROM() {
 6447              		.loc 25 262 0
 6448 0002 08B5     		push	{r3, lr}
 6449              	.LCFI60:
 6450              		.cfi_def_cfa_offset 8
 6451              		.cfi_offset 14, -4
 6452              		.cfi_offset 3, -8
 6453              	.LBB162:
 6454              		.loc 25 263 0
 6455 0004 0146     		mov	r1, r0
 6456 0006 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 264:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(YAXIS, PITCH_PID_GAIN_ADR);
 6457              		.loc 25 264 0
 6458 000a 0120     		movs	r0, #1
 6459 000c 2421     		movs	r1, #36
 6460 000e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 265:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ZAXIS, YAW_PID_GAIN_ADR);
 6461              		.loc 25 265 0
 6462 0012 0220     		movs	r0, #2
 6463 0014 1821     		movs	r1, #24
 6464 0016 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 266:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 6465              		.loc 25 266 0
 6466 001a 0320     		movs	r0, #3
 6467 001c 0C21     		movs	r1, #12
 6468 001e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 267:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 6469              		.loc 25 267 0
 6470 0022 0420     		movs	r0, #4
 6471 0024 3021     		movs	r1, #48
 6472 0026 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 268:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 6473              		.loc 25 268 0
 6474 002a 0520     		movs	r0, #5
 6475 002c 3C21     		movs	r1, #60
 6476 002e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 269:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 6477              		.loc 25 269 0
 6478 0032 0620     		movs	r0, #6
 6479 0034 4821     		movs	r1, #72
 6480 0036 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 270:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 6481              		.loc 25 270 0
 6482 003a 5421     		movs	r1, #84
 6483 003c 0720     		movs	r0, #7
 6484 003e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 271:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 272:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   rotationSpeedFactor = readFloat(ROTATION_SPEED_FACTOR_ARD);
 6485              		.loc 25 272 0
 6486 0042 4FF4A670 		mov	r0, #332
 6487 0046 FFF7FEFF 		bl	_Z12nvrReadFloati
 6488 004a 634A     		ldr	r2, .L404
 6489 004c 1060     		str	r0, [r2, #0]	@ float
 273:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 274:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Leaving separate PID reads as commented for now
 275:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Previously had issue where EEPROM was not reading right data
 276:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 277:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 278:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloat(ALTITUDE_WINDUP_ADR);
 279:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 280:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       baroSmoothFactor = readFloat(ALTITUDE_SMOOTH_ADR);
 281:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif  
 282:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldBump = readFloat(ALTITUDE_BUMP_ADR);
 283:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 284:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 285:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     maxThrottleAdjust = readFloat(ALTITUDE_MAX_THROTTLE_ADR);
 286:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 287:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 288:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 289:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Mag calibration
 290:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef HeadingMagHold
 291:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     magBias[XAXIS]  = readFloat(XAXIS_MAG_BIAS_ADR);
 292:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     magBias[YAXIS]  = readFloat(YAXIS_MAG_BIAS_ADR);
 293:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     magBias[ZAXIS]  = readFloat(ZAXIS_MAG_BIAS_ADR);
 294:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 295:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 296:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Battery Monitor
 297:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef BattMonitor
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorAlarmVoltage = readFloat(BATT_ALARM_VOLTAGE_ADR);
 299:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorThrottleTarget = readFloat(BATT_THROTTLE_TARGET_ADR);
 300:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorGoingDownTime = readFloat(BATT_DOWN_TIME_ADR);
 301:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 302:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 303:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   windupGuard = readFloat(WINDUPGUARD_ADR);
 6490              		.loc 25 303 0
 6491 004e 4FF48C70 		mov	r0, #280
 6492 0052 FFF7FEFF 		bl	_Z12nvrReadFloati
 6493              	.LBB160:
 304:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // AKA - added so that each PID has its own windupGuard, will need to be removed once each PID's 
 305:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 306:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 307:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       if (i != BARO_ALTITUDE_HOLD_PID_IDX) {
 308:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****         PID[i].windupGuard = windupGuard;
 309:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       }
 310:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #else
 311:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       PID[i].windupGuard = windupGuard;
 6494              		.loc 25 311 0
 6495 0056 614B     		ldr	r3, .L404+4
 6496              	.LBE160:
 303:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   windupGuard = readFloat(WINDUPGUARD_ADR);
 6497              		.loc 25 303 0
 6498 0058 6149     		ldr	r1, .L404+8
 6499              	.LBB161:
 6500              		.loc 25 311 0
 6501 005a 9861     		str	r0, [r3, #24]	@ float
 6502 005c 5863     		str	r0, [r3, #52]	@ float
 6503 005e 1865     		str	r0, [r3, #80]	@ float
 6504 0060 D866     		str	r0, [r3, #108]	@ float
 6505 0062 C3F88800 		str	r0, [r3, #136]	@ float
 6506 0066 C3F8A400 		str	r0, [r3, #164]	@ float
 6507 006a C3F8C000 		str	r0, [r3, #192]	@ float
 6508 006e C3F8DC00 		str	r0, [r3, #220]	@ float
 6509              	.LBE161:
 303:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   windupGuard = readFloat(WINDUPGUARD_ADR);
 6510              		.loc 25 303 0
 6511 0072 0860     		str	r0, [r1, #0]	@ float
 6512              	.LVL317:
 312:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif      
 313:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 314:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
 315:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 6513              		.loc 25 315 0
 6514 0074 4FF49070 		mov	r0, #288
 6515 0078 FFF7FEFF 		bl	_Z12nvrReadFloati
 6516 007c 04EE100A 		fmsr	s8, r0
 6517 0080 584A     		ldr	r2, .L404+12
 6518 0082 FDEEC43A 		ftosizs	s7, s8
 316:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   aref = readFloat(AREF_ADR);
 6519              		.loc 25 316 0
 6520 0086 4FF49270 		mov	r0, #292
 315:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 6521              		.loc 25 315 0
 6522 008a C2ED003A 		fsts	s7, [r2, #0]	@ int
 6523              		.loc 25 316 0
 6524 008e FFF7FEFF 		bl	_Z12nvrReadFloati
 6525 0092 5549     		ldr	r1, .L404+16
 6526 0094 0860     		str	r0, [r1, #0]	@ float
 317:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   flightMode = readFloat(FLIGHTMODE_ADR);
 6527              		.loc 25 317 0
 6528 0096 4FF49470 		mov	r0, #296
 6529 009a FFF7FEFF 		bl	_Z12nvrReadFloati
 6530 009e 03EE100A 		fmsr	s6, r0
 6531 00a2 FCEEC32A 		ftouizs	s5, s6
 6532 00a6 5148     		ldr	r0, .L404+20
 6533 00a8 12EE90CA 		fmrs	ip, s5	@ int
 6534 00ac 80F800C0 		strb	ip, [r0, #0]
 318:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 6535              		.loc 25 318 0
 6536 00b0 4FF49870 		mov	r0, #304
 6537 00b4 FFF7FEFF 		bl	_Z12nvrReadFloati
 6538 00b8 4D4B     		ldr	r3, .L404+24
 6539 00ba 1860     		str	r0, [r3, #0]	@ float
 319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = readFloat(HEADINGHOLD_ADR);
 6540              		.loc 25 319 0
 6541 00bc 4FF49670 		mov	r0, #300
 6542 00c0 FFF7FEFF 		bl	_Z12nvrReadFloati
 6543 00c4 02EE100A 		fmsr	s4, r0
 6544 00c8 FCEEC21A 		ftouizs	s3, s4
 6545 00cc 494A     		ldr	r2, .L404+28
 6546 00ce 11EE901A 		fmrs	r1, s3	@ int
 320:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 321:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (UseGPSNavigator)
 322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     missionNbPoint = readFloat(GPS_MISSION_NB_POINT_ADR);
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 324:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 325:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 326:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
 327:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 328:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].longitude = readLong(WAYPOINT_ADR[location].longitude);
 329:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].latitude = readLong(WAYPOINT_ADR[location].latitude);
 330:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].altitude = readLong(WAYPOINT_ADR[location].altitude);
 331:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     }    
 332:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 333:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 334:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Camera Control
 335:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef CameraControl
 336:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     cameraMode = readFloat(CAMERAMODE_ADR);
 6547              		.loc 25 336 0
 6548 00d2 4FF4C470 		mov	r0, #392
 319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = readFloat(HEADINGHOLD_ADR);
 6549              		.loc 25 319 0
 6550 00d6 1170     		strb	r1, [r2, #0]
 6551              		.loc 25 336 0
 6552 00d8 FFF7FEFF 		bl	_Z12nvrReadFloati
 6553 00dc 01EE100A 		fmsr	s2, r0
 6554 00e0 4548     		ldr	r0, .L404+32
 6555 00e2 FDEEC10A 		ftosizs	s1, s2
 6556 00e6 C0ED000A 		fsts	s1, [r0, #0]	@ int
 337:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraPitch = readFloat(MCAMERAPITCH_ADR);
 6557              		.loc 25 337 0
 6558 00ea 4FF4C670 		mov	r0, #396
 6559 00ee FFF7FEFF 		bl	_Z12nvrReadFloati
 6560 00f2 424B     		ldr	r3, .L404+36
 6561 00f4 1860     		str	r0, [r3, #0]	@ float
 338:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraRoll = readFloat(MCAMERAROLL_ADR);    
 6562              		.loc 25 338 0
 6563 00f6 4FF4C870 		mov	r0, #400
 6564 00fa FFF7FEFF 		bl	_Z12nvrReadFloati
 6565 00fe 404A     		ldr	r2, .L404+40
 6566 0100 1060     		str	r0, [r2, #0]	@ float
 339:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraYaw = readFloat(MCAMERAYAW_ADR);
 6567              		.loc 25 339 0
 6568 0102 4FF4CA70 		mov	r0, #404
 6569 0106 FFF7FEFF 		bl	_Z12nvrReadFloati
 6570 010a 3E49     		ldr	r1, .L404+44
 6571 010c 0860     		str	r0, [r1, #0]	@ float
 340:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterPitch = readFloat(SERVOCENTERPITCH_ADR);
 6572              		.loc 25 340 0
 6573 010e 4FF4CC70 		mov	r0, #408
 6574 0112 FFF7FEFF 		bl	_Z12nvrReadFloati
 6575 0116 00EE100A 		fmsr	s0, r0
 6576 011a 3B4B     		ldr	r3, .L404+48
 6577 011c FDEEC07A 		ftosizs	s15, s0
 341:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterRoll = readFloat(SERVOCENTERROLL_ADR);
 6578              		.loc 25 341 0
 6579 0120 4FF4CE70 		mov	r0, #412
 340:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterPitch = readFloat(SERVOCENTERPITCH_ADR);
 6580              		.loc 25 340 0
 6581 0124 C3ED007A 		fsts	s15, [r3, #0]	@ int
 6582              		.loc 25 341 0
 6583 0128 FFF7FEFF 		bl	_Z12nvrReadFloati
 6584 012c 07EE100A 		fmsr	s14, r0
 6585 0130 364A     		ldr	r2, .L404+52
 6586 0132 FDEEC76A 		ftosizs	s13, s14
 342:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterYaw = readFloat(SERVOCENTERYAW_ADR);
 6587              		.loc 25 342 0
 6588 0136 4FF4D070 		mov	r0, #416
 341:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterRoll = readFloat(SERVOCENTERROLL_ADR);
 6589              		.loc 25 341 0
 6590 013a C2ED006A 		fsts	s13, [r2, #0]	@ int
 6591              		.loc 25 342 0
 6592 013e FFF7FEFF 		bl	_Z12nvrReadFloati
 6593 0142 06EE100A 		fmsr	s12, r0
 6594 0146 3249     		ldr	r1, .L404+56
 6595 0148 FDEEC65A 		ftosizs	s11, s12
 343:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinPitch = readFloat(SERVOMINPITCH_ADR);
 6596              		.loc 25 343 0
 6597 014c 4FF4D270 		mov	r0, #420
 342:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterYaw = readFloat(SERVOCENTERYAW_ADR);
 6598              		.loc 25 342 0
 6599 0150 C1ED005A 		fsts	s11, [r1, #0]	@ int
 6600              		.loc 25 343 0
 6601 0154 FFF7FEFF 		bl	_Z12nvrReadFloati
 6602 0158 05EE100A 		fmsr	s10, r0
 6603 015c 2D48     		ldr	r0, .L404+60
 6604 015e FDEEC54A 		ftosizs	s9, s10
 6605 0162 C0ED004A 		fsts	s9, [r0, #0]	@ int
 344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinRoll = readFloat(SERVOMINROLL_ADR);
 6606              		.loc 25 344 0
 6607 0166 4FF4D470 		mov	r0, #424
 6608 016a FFF7FEFF 		bl	_Z12nvrReadFloati
 6609 016e 04EE100A 		fmsr	s8, r0
 6610 0172 294B     		ldr	r3, .L404+64
 6611 0174 FDEEC43A 		ftosizs	s7, s8
 345:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinYaw = readFloat(SERVOMINYAW_ADR);
 6612              		.loc 25 345 0
 6613 0178 4FF4D670 		mov	r0, #428
 344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinRoll = readFloat(SERVOMINROLL_ADR);
 6614              		.loc 25 344 0
 6615 017c C3ED003A 		fsts	s7, [r3, #0]	@ int
 6616              		.loc 25 345 0
 6617 0180 FFF7FEFF 		bl	_Z12nvrReadFloati
 6618 0184 03EE100A 		fmsr	s6, r0
 6619 0188 244A     		ldr	r2, .L404+68
 6620 018a FDEEC32A 		ftosizs	s5, s6
 346:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxPitch = readFloat(SERVOMAXPITCH_ADR);
 6621              		.loc 25 346 0
 6622 018e 4FF4D870 		mov	r0, #432
 345:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinYaw = readFloat(SERVOMINYAW_ADR);
 6623              		.loc 25 345 0
 6624 0192 C2ED002A 		fsts	s5, [r2, #0]	@ int
 6625              		.loc 25 346 0
 6626 0196 FFF7FEFF 		bl	_Z12nvrReadFloati
 6627 019a 02EE100A 		fmsr	s4, r0
 6628 019e 2049     		ldr	r1, .L404+72
 6629 01a0 FDEEC21A 		ftosizs	s3, s4
 347:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxRoll = readFloat(SERVOMAXROLL_ADR);
 6630              		.loc 25 347 0
 6631 01a4 4FF4DA70 		mov	r0, #436
 346:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxPitch = readFloat(SERVOMAXPITCH_ADR);
 6632              		.loc 25 346 0
 6633 01a8 C1ED001A 		fsts	s3, [r1, #0]	@ int
 6634              		.loc 25 347 0
 6635 01ac FFF7FEFF 		bl	_Z12nvrReadFloati
 6636 01b0 01EE100A 		fmsr	s2, r0
 6637 01b4 1B48     		ldr	r0, .L404+76
 6638 01b6 FDEEC10A 		ftosizs	s1, s2
 6639 01ba C0ED000A 		fsts	s1, [r0, #0]	@ int
 348:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxYaw = readFloat(SERVOMAXYAW_ADR);
 6640              		.loc 25 348 0
 6641 01be 4FF4DC70 		mov	r0, #440
 6642 01c2 FFF7FEFF 		bl	_Z12nvrReadFloati
 6643 01c6 00EE100A 		fmsr	s0, r0
 6644 01ca 174B     		ldr	r3, .L404+80
 6645 01cc FDEEC07A 		ftosizs	s15, s0
 6646 01d0 C3ED007A 		fsts	s15, [r3, #0]	@ int
 6647              	.LBE162:
 349:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #ifdef CameraTXControl
 350:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       servoTXChannels = readFloat(SERVOTXCHANNELS_ADR);
 351:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       servoActualCenter = readFloat(SERVOCENTERPITCH_ADR);
 352:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 353:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif   
 354:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 6648              		.loc 25 354 0
 6649 01d4 08BD     		pop	{r3, pc}
 6650              	.L405:
 6651 01d6 00BF     		.align	2
 6652              	.L404:
 6653 01d8 00000000 		.word	.LANCHOR78
 6654 01dc 00000000 		.word	.LANCHOR9
 6655 01e0 00000000 		.word	.LANCHOR95
 6656 01e4 00000000 		.word	.LANCHOR83
 6657 01e8 00000000 		.word	.LANCHOR96
 6658 01ec 00000000 		.word	.LANCHOR77
 6659 01f0 00000000 		.word	.LANCHOR31
 6660 01f4 00000000 		.word	.LANCHOR86
 6661 01f8 00000000 		.word	.LANCHOR60
 6662 01fc 00000000 		.word	.LANCHOR61
 6663 0200 00000000 		.word	.LANCHOR65
 6664 0204 00000000 		.word	.LANCHOR69
 6665 0208 00000000 		.word	.LANCHOR62
 6666 020c 00000000 		.word	.LANCHOR66
 6667 0210 00000000 		.word	.LANCHOR70
 6668 0214 00000000 		.word	.LANCHOR63
 6669 0218 00000000 		.word	.LANCHOR67
 6670 021c 00000000 		.word	.LANCHOR71
 6671 0220 00000000 		.word	.LANCHOR64
 6672 0224 00000000 		.word	.LANCHOR68
 6673 0228 00000000 		.word	.LANCHOR72
 6674              		.cfi_endproc
 6675              	.LFE212:
 6677              		.section	.text._Z11writeEEPROMv,"ax",%progbits
 6678              		.align	1
 6679              		.global	_Z11writeEEPROMv
 6680              		.thumb
 6681              		.thumb_func
 6683              	_Z11writeEEPROMv:
 6684              	.LFB213:
 355:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 356:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void writeEEPROM(){
 6685              		.loc 25 356 0
 6686              		.cfi_startproc
 6687              		@ args = 0, pretend = 0, frame = 0
 6688              		@ frame_needed = 0, uses_anonymous_args = 0
 6689 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 6690              	.LCFI61:
 6691              		.cfi_def_cfa_offset 24
 6692              		.cfi_offset 14, -4
 6693              		.cfi_offset 7, -8
 6694              		.cfi_offset 6, -12
 6695              		.cfi_offset 5, -16
 6696              		.cfi_offset 4, -20
 6697              		.cfi_offset 3, -24
 6698              	.LBB169:
 6699              	.LBB170:
 6700              	.LBB171:
 6701              		.file 26 "../Libmaple/libmaple/libmaple/nvic.h"
   1:../Libmaple/libmaple/libmaple/nvic.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/nvic.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/nvic.h ****  *
   4:../Libmaple/libmaple/libmaple/nvic.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/nvic.h ****  *
   6:../Libmaple/libmaple/libmaple/nvic.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/nvic.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/nvic.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/nvic.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/nvic.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/nvic.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/nvic.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/nvic.h ****  *
  14:../Libmaple/libmaple/libmaple/nvic.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/nvic.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/nvic.h ****  *
  17:../Libmaple/libmaple/libmaple/nvic.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/nvic.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/nvic.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/nvic.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/nvic.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/nvic.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/nvic.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/nvic.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/nvic.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/nvic.h **** 
  27:../Libmaple/libmaple/libmaple/nvic.h **** /**
  28:../Libmaple/libmaple/libmaple/nvic.h ****  * @file nvic.h
  29:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Nested vector interrupt controller support.
  30:../Libmaple/libmaple/libmaple/nvic.h ****  *
  31:../Libmaple/libmaple/libmaple/nvic.h ****  * Basic usage:
  32:../Libmaple/libmaple/libmaple/nvic.h ****  *
  33:../Libmaple/libmaple/libmaple/nvic.h ****  * @code
  34:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Initialise the interrupt controller and point to the vector
  35:../Libmaple/libmaple/libmaple/nvic.h ****  *   // table at the start of flash.
  36:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_init(0x08000000, 0);
  37:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Bind in a timer interrupt handler
  38:../Libmaple/libmaple/libmaple/nvic.h ****  *   timer_attach_interrupt(TIMER_CC1_INTERRUPT, handler);
  39:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Optionally set the priority
  40:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_irq_set_priority(NVIC_TIMER1_CC, 5);
  41:../Libmaple/libmaple/libmaple/nvic.h ****  *   // All done, enable all interrupts
  42:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_globalirq_enable();
  43:../Libmaple/libmaple/libmaple/nvic.h ****  * @endcode
  44:../Libmaple/libmaple/libmaple/nvic.h ****  */
  45:../Libmaple/libmaple/libmaple/nvic.h **** 
  46:../Libmaple/libmaple/libmaple/nvic.h **** #ifndef _NVIC_H_
  47:../Libmaple/libmaple/libmaple/nvic.h **** #define _NVIC_H_
  48:../Libmaple/libmaple/libmaple/nvic.h **** 
  49:../Libmaple/libmaple/libmaple/nvic.h **** #include "libmaple_types.h"
  50:../Libmaple/libmaple/libmaple/nvic.h **** #include "util.h"
  51:../Libmaple/libmaple/libmaple/nvic.h **** 
  52:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef __cplusplus
  53:../Libmaple/libmaple/libmaple/nvic.h **** extern "C"{
  54:../Libmaple/libmaple/libmaple/nvic.h **** #endif
  55:../Libmaple/libmaple/libmaple/nvic.h **** 
  56:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map type. */
  57:../Libmaple/libmaple/libmaple/nvic.h **** typedef struct nvic_reg_map {
  58:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISER[8];      /**< Interrupt Set Enable Registers */
  59:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED0[24];     /**< Reserved */
  60:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICER[8];      /**< Interrupt Clear Enable Registers */
  61:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RSERVED1[24];      /**< Reserved */
  62:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISPR[8];      /**< Interrupt Set Pending Registers */
  63:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED2[24];     /**< Reserved */
  64:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICPR[8];      /**< Interrupt Clear Pending Registers */
  65:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED3[24];     /**< Reserved */
  66:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 IABR[8];      /**< Interrupt Active bit Registers */
  67:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED4[56];     /**< Reserved */
  68:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint8  IP[240];      /**< Interrupt Priority Registers */
  69:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED5[644];    /**< Reserved */
  70:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 STIR;         /**< Software Trigger Interrupt Registers */
  71:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_reg_map;
  72:../Libmaple/libmaple/libmaple/nvic.h **** 
  73:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map base pointer. */
  74:../Libmaple/libmaple/libmaple/nvic.h **** #define NVIC_BASE                       ((struct nvic_reg_map*)0xE000E100)
  75:../Libmaple/libmaple/libmaple/nvic.h **** 
  76:../Libmaple/libmaple/libmaple/nvic.h **** /**
  77:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Interrupt vector table interrupt numbers.
  78:../Libmaple/libmaple/libmaple/nvic.h ****  *
  79:../Libmaple/libmaple/libmaple/nvic.h ****  * Each positive-valued enumerator is the position of the
  80:../Libmaple/libmaple/libmaple/nvic.h ****  * corresponding interrupt in the vector table.  Negative-valued
  81:../Libmaple/libmaple/libmaple/nvic.h ****  * enumerators correspond to interrupts controlled by the system
  82:../Libmaple/libmaple/libmaple/nvic.h ****  * handler block.
  83:../Libmaple/libmaple/libmaple/nvic.h ****  *
  84:../Libmaple/libmaple/libmaple/nvic.h ****  * @see scb.h
  85:../Libmaple/libmaple/libmaple/nvic.h ****  */
  86:../Libmaple/libmaple/libmaple/nvic.h **** typedef enum nvic_irq_num {
  87:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_NMI            = -14,  /**< Non-maskable interrupt */
  88:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_HARDFAULT      = -13,  /**< Hard fault (all class of fault) */
  89:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_MEM_MANAGE     = -12,  /**< Memory management */
  90:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_BUS_FAULT      = -11,  /**< Bus fault: prefetch fault, memory
  91:../Libmaple/libmaple/libmaple/nvic.h ****                                      access fault. */
  92:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USAGE_FAULT    = -10,  /**< Usage fault: Undefined instruction or
  93:../Libmaple/libmaple/libmaple/nvic.h ****                                      illegal state. */
  94:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SVC            = -5,   /**< System service call via SWI insruction */
  95:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DEBUG_MON      = -4,   /**< Debug monitor */
  96:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PEND_SVC       = -2,   /**< Pendable request for system service */
  97:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SYSTICK        = -1,   /**< System tick timer */
  98:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_WWDG           = 0,    /**< Window watchdog interrupt */
  99:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PVD            = 1,    /**< PVD through EXTI line detection */
 100:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TAMPER         = 2,    /**< Tamper */
 101:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTC            = 3,    /**< Real-time clock */
 102:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FLASH          = 4,    /**< Flash */
 103:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RCC            = 5,    /**< Reset and clock control */
 104:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI0          = 6,    /**< EXTI line 0 */
 105:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI1          = 7,    /**< EXTI line 1 */
 106:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI2          = 8,    /**< EXTI line 2 */
 107:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI3          = 9,    /**< EXTI line 3 */
 108:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI4          = 10,   /**< EXTI line 4 */
 109:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH1        = 11,   /**< DMA1 channel 1 */
 110:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH2        = 12,   /**< DMA1 channel 2 */
 111:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH3        = 13,   /**< DMA1 channel 3 */
 112:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH4        = 14,   /**< DMA1 channel 4 */
 113:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH5        = 15,   /**< DMA1 channel 5 */
 114:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH6        = 16,   /**< DMA1 channel 6 */
 115:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH7        = 17,   /**< DMA1 channel 7 */
 116:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC_1_2        = 18,   /**< ADC1 and ADC2 */
 117:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_HP_CAN_TX  = 19,   /**< USB high priority or CAN TX */
 118:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_LP_CAN_RX0 = 20,   /**< USB low priority or CAN RX0 */
 119:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_RX1        = 21,   /**< CAN RX1 */
 120:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_SCE        = 22,   /**< CAN SCE */
 121:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_9_5       = 23,   /**< EXTI line [9:5] */
 122:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_BRK     = 24,   /**< Timer 1 break */
 123:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_UP      = 25,   /**< Timer 1 update */
 124:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_TRG_COM = 26,   /**< Timer 1 trigger and commutation */
 125:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_CC      = 27,   /**< Timer 1 capture/compare */
 126:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER2         = 28,   /**< Timer 2 */
 127:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER3         = 29,   /**< Timer 3 */
 128:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER4         = 30,   /**< Timer 4 */
 129:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_EV        = 31,   /**< I2C1 event */
 130:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_ER        = 32,   /**< I2C1 error */
 131:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_EV        = 33,   /**< I2C2 event */
 132:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_ER        = 34,   /**< I2C2 error */
 133:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI1           = 35,   /**< SPI1 */
 134:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI2           = 36,   /**< SPI2 */
 135:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART1         = 37,   /**< USART1 */
 136:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART2         = 38,   /**< USART2 */
 137:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART3         = 39,   /**< USART3 */
 138:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_15_10     = 40,   /**< EXTI line [15:10] */
 139:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTCALARM       = 41,   /**< RTC alarm through EXTI line */
 140:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USBWAKEUP      = 42,   /**< USB wakeup from suspend through
 141:../Libmaple/libmaple/libmaple/nvic.h ****                                      EXTI line */
 142:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_BRK     = 43,   /**< Timer 8 break */
 143:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_UP      = 44,   /**< Timer 8 update */
 144:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_TRG_COM = 45,   /**< Timer 8 trigger and commutation */
 145:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_CC      = 46,   /**< Timer 8 capture/compare */
 146:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef STM32_HIGH_DENSITY
 147:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC3           = 47,   /**< ADC3 */
 148:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FSMC           = 48,   /**< FSMC */
 149:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SDIO           = 49,   /**< SDIO */
 150:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER5         = 50,   /**< Timer 5 */
 151:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI3           = 51,   /**< SPI3 */
 152:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART4          = 52,   /**< UART4 */
 153:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART5          = 53,   /**< UART5 */
 154:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER6         = 54,   /**< Timer 6 */
 155:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER7         = 55,   /**< Timer 7 */
 156:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH1       = 56,   /**< DMA2 channel 1 */
 157:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH2       = 57,   /**< DMA2 channel 2 */
 158:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH3       = 58,   /**< DMA2 channel 3 */
 159:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH_4_5    = 59,   /**< DMA2 channels 4 and 5 */
 160:../Libmaple/libmaple/libmaple/nvic.h **** #endif
 161:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_irq_num;
 162:../Libmaple/libmaple/libmaple/nvic.h **** 
 163:../Libmaple/libmaple/libmaple/nvic.h **** /*
 164:../Libmaple/libmaple/libmaple/nvic.h ****  * Initialises the interrupt controller and sets all interrupts to the
 165:../Libmaple/libmaple/libmaple/nvic.h ****  * lowest priority.
 166:../Libmaple/libmaple/libmaple/nvic.h ****  *
 167:../Libmaple/libmaple/libmaple/nvic.h ****  * For stand-alone products, the base address is normally the start of
 168:../Libmaple/libmaple/libmaple/nvic.h ****  * flash (0x08000000).
 169:../Libmaple/libmaple/libmaple/nvic.h ****  *
 170:../Libmaple/libmaple/libmaple/nvic.h ****  * @param vector_table_address  base address of the vector table
 171:../Libmaple/libmaple/libmaple/nvic.h ****  */
 172:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_init(uint32 vector_table_address, uint32 offset);
 173:../Libmaple/libmaple/libmaple/nvic.h **** 
 174:../Libmaple/libmaple/libmaple/nvic.h **** /**
 175:../Libmaple/libmaple/libmaple/nvic.h ****  * Sets the base address of the vector table.
 176:../Libmaple/libmaple/libmaple/nvic.h ****  */
 177:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_set_vector_table(uint32 address, uint32 offset);
 178:../Libmaple/libmaple/libmaple/nvic.h **** 
 179:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_irq_set_priority(nvic_irq_num irqn, uint8 priority);
 180:../Libmaple/libmaple/libmaple/nvic.h **** 
 181:../Libmaple/libmaple/libmaple/nvic.h **** /**
 182:../Libmaple/libmaple/libmaple/nvic.h ****  * Enables interrupts and configurable fault handlers (clear PRIMASK).
 183:../Libmaple/libmaple/libmaple/nvic.h ****  */
 184:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_enable() {
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 186:../Libmaple/libmaple/libmaple/nvic.h **** }
 187:../Libmaple/libmaple/libmaple/nvic.h **** 
 188:../Libmaple/libmaple/libmaple/nvic.h **** /**
 189:../Libmaple/libmaple/libmaple/nvic.h ****  * Disable interrupts and configurable fault handlers (set PRIMASK).
 190:../Libmaple/libmaple/libmaple/nvic.h ****  */
 191:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_disable() {
 192:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsid i");
 6702              		.loc 26 192 0
 6703              	@ 192 "../Libmaple/libmaple/libmaple/nvic.h" 1
 6704 0002 72B6     		cpsid i
 6705              	@ 0 "" 2
 6706              		.thumb
 6707              	.LBE171:
 6708              	.LBE170:
 357:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   cli(); // Needed so that APM sensor data does not overflow
 358:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(XAXIS, ROLL_PID_GAIN_ADR);
 6709              		.loc 25 358 0
 6710 0004 0020     		movs	r0, #0
 6711 0006 0146     		mov	r1, r0
 6712 0008 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 359:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(YAXIS, PITCH_PID_GAIN_ADR);
 6713              		.loc 25 359 0
 6714 000c 0120     		movs	r0, #1
 6715 000e 2421     		movs	r1, #36
 6716 0010 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 360:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 6717              		.loc 25 360 0
 6718 0014 0320     		movs	r0, #3
 6719 0016 0C21     		movs	r1, #12
 6720 0018 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 361:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 6721              		.loc 25 361 0
 6722 001c 0420     		movs	r0, #4
 6723 001e 3021     		movs	r1, #48
 6724 0020 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 362:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ZAXIS, YAW_PID_GAIN_ADR);
 6725              		.loc 25 362 0
 6726 0024 0220     		movs	r0, #2
 6727 0026 1821     		movs	r1, #24
 6728 0028 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 363:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 6729              		.loc 25 363 0
 6730 002c 0520     		movs	r0, #5
 6731 002e 3C21     		movs	r1, #60
 6732 0030 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 364:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 6733              		.loc 25 364 0
 6734 0034 0620     		movs	r0, #6
 6735 0036 4821     		movs	r1, #72
 6736 0038 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 365:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 6737              		.loc 25 365 0
 6738 003c 0720     		movs	r0, #7
 6739 003e 5421     		movs	r1, #84
 6740 0040 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 366:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 367:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 6741              		.loc 25 367 0
 6742 0044 8A49     		ldr	r1, .L409
 368:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 369:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined AltitudeHoldBaro
 370:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 371:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard, ALTITUDE_WINDUP_ADR);
 372:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 373:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 374:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 375:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 376:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeFloat(baroSmoothFactor, ALTITUDE_SMOOTH_ADR);
 377:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #else
 378:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeFloat(0.0, ALTITUDE_SMOOTH_ADR);
 379:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 380:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 381:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 382:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 383:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 384:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 385:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #else
 386:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 387:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(90, ALTITUDE_BUMP_ADR);
 388:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(250, ALTITUDE_PANIC_ADR);
 389:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(-50, ALTITUDE_MIN_THROTTLE_ADR);
 390:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(50, ALTITUDE_MAX_THROTTLE_ADR);
 391:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 392:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 393:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 394:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef HeadingMagHold
 395:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(magBias[XAXIS], XAXIS_MAG_BIAS_ADR);
 396:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(magBias[YAXIS], YAXIS_MAG_BIAS_ADR);
 397:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 398:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 399:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(windupGuard, WINDUPGUARD_ADR);
 400:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(receiverXmitFactor, XMITFACTOR_ADR);
 6743              		.loc 25 400 0
 6744 0046 8B4F     		ldr	r7, .L409+4
 367:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 6745              		.loc 25 367 0
 6746 0048 0868     		ldr	r0, [r1, #0]	@ float
 6747              		.loc 25 400 0
 6748 004a 8B4E     		ldr	r6, .L409+8
 6749 004c 8B4D     		ldr	r5, .L409+12
 367:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 6750              		.loc 25 367 0
 6751 004e 4FF4A671 		mov	r1, #332
 6752 0052 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 386:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 6753              		.loc 25 386 0
 6754 0056 8A48     		ldr	r0, .L409+16
 6755 0058 4FF49E71 		mov	r1, #316
 6756 005c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 387:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(90, ALTITUDE_BUMP_ADR);
 6757              		.loc 25 387 0
 6758 0060 8848     		ldr	r0, .L409+20
 6759 0062 4FF4A271 		mov	r1, #324
 6760 0066 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 388:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(250, ALTITUDE_PANIC_ADR);
 6761              		.loc 25 388 0
 6762 006a 8748     		ldr	r0, .L409+24
 6763 006c 4FF4A471 		mov	r1, #328
 6764 0070 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 389:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(-50, ALTITUDE_MIN_THROTTLE_ADR);
 6765              		.loc 25 389 0
 6766 0074 8548     		ldr	r0, .L409+28
 6767 0076 4FF49C71 		mov	r1, #312
 6768 007a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 390:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(50, ALTITUDE_MAX_THROTTLE_ADR);
 6769              		.loc 25 390 0
 6770 007e 8448     		ldr	r0, .L409+32
 6771 0080 4FF49A71 		mov	r1, #308
 6772 0084 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 391:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 6773              		.loc 25 391 0
 6774 0088 7D48     		ldr	r0, .L409+16
 6775 008a 4FF49E71 		mov	r1, #316
 6776 008e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 399:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(windupGuard, WINDUPGUARD_ADR);
 6777              		.loc 25 399 0
 6778 0092 8048     		ldr	r0, .L409+36
 6779 0094 4FF48C71 		mov	r1, #280
 6780 0098 0068     		ldr	r0, [r0, #0]	@ float
 6781 009a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 6782              		.loc 25 400 0
 6783 009e 7E4B     		ldr	r3, .L409+40
 6784 00a0 4FF48E71 		mov	r1, #284
 6785 00a4 1868     		ldr	r0, [r3, #0]	@ float
 6786 00a6 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 6787              	.LVL318:
 6788 00aa 0024     		movs	r4, #0
 6789              	.LVL319:
 6790              	.L407:
 6791              	.LBB172:
 401:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 402:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 403:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(receiverSlope[channel],  RECEIVER_DATA[channel].slope);
 6792              		.loc 25 403 0 discriminator 2
 6793 00ac 04F19C01 		add	r1, r4, #156
 6794 00b0 57F8040F 		ldr	r0, [r7, #4]!	@ float
 6795 00b4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 404:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(receiverOffset[channel], RECEIVER_DATA[channel].offset);
 6796              		.loc 25 404 0 discriminator 2
 6797 00b8 04F1A001 		add	r1, r4, #160
 6798 00bc 56F8040F 		ldr	r0, [r6, #4]!	@ float
 6799 00c0 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 405:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(receiverSmoothFactor[channel], RECEIVER_DATA[channel].smooth_factor);
 6800              		.loc 25 405 0 discriminator 2
 6801 00c4 04F1A401 		add	r1, r4, #164
 6802 00c8 55F8040F 		ldr	r0, [r5, #4]!	@ float
 6803 00cc 0C34     		adds	r4, r4, #12
 6804 00ce FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 402:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 6805              		.loc 25 402 0 discriminator 2
 6806 00d2 602C     		cmp	r4, #96
 6807 00d4 EAD1     		bne	.L407
 6808              	.LBE172:
 406:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 407:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 408:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(minArmedThrottle, MINARMEDTHROTTLE_ADR);
 6809              		.loc 25 408 0
 6810 00d6 714B     		ldr	r3, .L409+44
 6811 00d8 1A68     		ldr	r2, [r3, #0]
 6812 00da 04EE102A 		fmsr	s8, r2	@ int
 6813 00de F8EEC43A 		fsitos	s7, s8
 6814 00e2 4FF49071 		mov	r1, #288
 6815 00e6 13EE900A 		fmrs	r0, s7
 6816 00ea FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 409:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(aref, AREF_ADR);
 6817              		.loc 25 409 0
 6818 00ee 6C49     		ldr	r1, .L409+48
 6819 00f0 0868     		ldr	r0, [r1, #0]	@ float
 6820 00f2 4FF49271 		mov	r1, #292
 6821 00f6 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 410:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(flightMode, FLIGHTMODE_ADR);
 6822              		.loc 25 410 0
 6823 00fa 6A48     		ldr	r0, .L409+52
 6824 00fc 90F800C0 		ldrb	ip, [r0, #0]	@ zero_extendqisi2
 6825 0100 03EE10CA 		fmsr	s6, ip	@ int
 6826 0104 F8EE432A 		fuitos	s5, s6
 6827 0108 4FF49471 		mov	r1, #296
 6828 010c 12EE900A 		fmrs	r0, s5
 6829 0110 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 411:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(headingHoldConfig, HEADINGHOLD_ADR);
 6830              		.loc 25 411 0
 6831 0114 644B     		ldr	r3, .L409+56
 6832 0116 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6833 0118 02EE102A 		fmsr	s4, r2	@ int
 6834 011c F8EE421A 		fuitos	s3, s4
 6835 0120 4FF49671 		mov	r1, #300
 6836 0124 11EE900A 		fmrs	r0, s3
 6837 0128 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 412:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 6838              		.loc 25 412 0
 6839 012c 5F49     		ldr	r1, .L409+60
 6840 012e 0868     		ldr	r0, [r1, #0]	@ float
 6841 0130 4FF49871 		mov	r1, #304
 6842 0134 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(SOFTWARE_VERSION, SOFTWARE_VERSION_ADR);
 6843              		.loc 25 413 0
 6844 0138 5D48     		ldr	r0, .L409+64
 6845 013a 4FF48A71 		mov	r1, #276
 6846 013e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 414:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 415:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Battery Monitor
 416:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef BattMonitor
 417:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(batteryMonitorAlarmVoltage, BATT_ALARM_VOLTAGE_ADR);
 418:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(batteryMonitorThrottleTarget, BATT_THROTTLE_TARGET_ADR);
 419:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(batteryMonitorGoingDownTime, BATT_DOWN_TIME_ADR);
 420:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 421:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 422:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Range Finder
 423:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 424:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(maxRangeFinderRange, RANGE_FINDER_MAX_ADR);
 425:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(minRangeFinderRange, RANGE_FINDER_MIN_ADR);
 426:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #else
 427:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0, RANGE_FINDER_MAX_ADR);
 6847              		.loc 25 427 0
 6848 0142 0020     		movs	r0, #0
 6849 0144 4FF4C071 		mov	r1, #384
 6850 0148 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 428:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0, RANGE_FINDER_MIN_ADR);
 6851              		.loc 25 428 0
 6852 014c 0020     		movs	r0, #0
 6853 014e 4FF4C271 		mov	r1, #388
 6854 0152 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 429:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 430:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 431:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (UseGPSNavigator)
 432:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(missionNbPoint, GPS_MISSION_NB_POINT_ADR);
 433:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 434:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 435:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 436:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
 437:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 438:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeLong(waypoint[location].longitude, WAYPOINT_ADR[location].longitude);
 439:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeLong(waypoint[location].latitude, WAYPOINT_ADR[location].latitude);
 440:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeLong(waypoint[location].altitude, WAYPOINT_ADR[location].altitude);
 441:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     }       
 442:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 443:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 444:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     // Camera Control
 445:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef CameraControl
 446:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(cameraMode, CAMERAMODE_ADR);
 6855              		.loc 25 446 0
 6856 0156 5748     		ldr	r0, .L409+68
 6857 0158 0368     		ldr	r3, [r0, #0]
 6858 015a 01EE103A 		fmsr	s2, r3	@ int
 6859 015e F8EEC10A 		fsitos	s1, s2
 6860 0162 4FF4C471 		mov	r1, #392
 6861 0166 10EE900A 		fmrs	r0, s1
 6862 016a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 447:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(mCameraPitch, MCAMERAPITCH_ADR);
 6863              		.loc 25 447 0
 6864 016e 524A     		ldr	r2, .L409+72
 6865 0170 4FF4C671 		mov	r1, #396
 6866 0174 1068     		ldr	r0, [r2, #0]	@ float
 6867 0176 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 448:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(mCameraRoll, MCAMERAROLL_ADR);    
 6868              		.loc 25 448 0
 6869 017a 5049     		ldr	r1, .L409+76
 6870 017c 0868     		ldr	r0, [r1, #0]	@ float
 6871 017e 4FF4C871 		mov	r1, #400
 6872 0182 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 449:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(mCameraYaw, MCAMERAYAW_ADR);
 6873              		.loc 25 449 0
 6874 0186 4E48     		ldr	r0, .L409+80
 6875 0188 4FF4CA71 		mov	r1, #404
 6876 018c 0068     		ldr	r0, [r0, #0]	@ float
 6877 018e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 450:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoCenterPitch, SERVOCENTERPITCH_ADR);
 6878              		.loc 25 450 0
 6879 0192 4C4B     		ldr	r3, .L409+84
 6880 0194 1A68     		ldr	r2, [r3, #0]
 6881 0196 00EE102A 		fmsr	s0, r2	@ int
 6882 019a F8EEC07A 		fsitos	s15, s0
 6883 019e 4FF4CC71 		mov	r1, #408
 6884 01a2 17EE900A 		fmrs	r0, s15
 6885 01a6 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 451:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoCenterRoll, SERVOCENTERROLL_ADR);
 6886              		.loc 25 451 0
 6887 01aa 4749     		ldr	r1, .L409+88
 6888 01ac 0868     		ldr	r0, [r1, #0]
 6889 01ae 07EE100A 		fmsr	s14, r0	@ int
 6890 01b2 F8EEC76A 		fsitos	s13, s14
 6891 01b6 4FF4CE71 		mov	r1, #412
 6892 01ba 16EE900A 		fmrs	r0, s13
 6893 01be FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 452:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoCenterYaw, SERVOCENTERYAW_ADR);
 6894              		.loc 25 452 0
 6895 01c2 424B     		ldr	r3, .L409+92
 6896 01c4 1A68     		ldr	r2, [r3, #0]
 6897 01c6 06EE102A 		fmsr	s12, r2	@ int
 6898 01ca F8EEC65A 		fsitos	s11, s12
 6899 01ce 4FF4D071 		mov	r1, #416
 6900 01d2 15EE900A 		fmrs	r0, s11
 6901 01d6 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 453:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMinPitch, SERVOMINPITCH_ADR);
 6902              		.loc 25 453 0
 6903 01da 3D49     		ldr	r1, .L409+96
 6904 01dc 0868     		ldr	r0, [r1, #0]
 6905 01de 05EE100A 		fmsr	s10, r0	@ int
 6906 01e2 F8EEC54A 		fsitos	s9, s10
 6907 01e6 4FF4D271 		mov	r1, #420
 6908 01ea 14EE900A 		fmrs	r0, s9
 6909 01ee FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 454:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMinRoll, SERVOMINROLL_ADR);
 6910              		.loc 25 454 0
 6911 01f2 384B     		ldr	r3, .L409+100
 6912 01f4 1A68     		ldr	r2, [r3, #0]
 6913 01f6 04EE102A 		fmsr	s8, r2	@ int
 6914 01fa F8EEC43A 		fsitos	s7, s8
 6915 01fe 4FF4D471 		mov	r1, #424
 6916 0202 13EE900A 		fmrs	r0, s7
 6917 0206 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 455:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMinYaw, SERVOMINYAW_ADR);
 6918              		.loc 25 455 0
 6919 020a 3349     		ldr	r1, .L409+104
 6920 020c 0868     		ldr	r0, [r1, #0]
 6921 020e 03EE100A 		fmsr	s6, r0	@ int
 6922 0212 F8EEC32A 		fsitos	s5, s6
 6923 0216 4FF4D671 		mov	r1, #428
 6924 021a 12EE900A 		fmrs	r0, s5
 6925 021e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 456:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMaxPitch, SERVOMAXPITCH_ADR);
 6926              		.loc 25 456 0
 6927 0222 2E4B     		ldr	r3, .L409+108
 6928 0224 1A68     		ldr	r2, [r3, #0]
 6929 0226 02EE102A 		fmsr	s4, r2	@ int
 6930 022a F8EEC21A 		fsitos	s3, s4
 6931 022e 4FF4D871 		mov	r1, #432
 6932 0232 11EE900A 		fmrs	r0, s3
 6933 0236 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 457:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMaxRoll, SERVOMAXROLL_ADR);
 6934              		.loc 25 457 0
 6935 023a 2949     		ldr	r1, .L409+112
 6936 023c 0868     		ldr	r0, [r1, #0]
 6937 023e 01EE100A 		fmsr	s2, r0	@ int
 6938 0242 F8EEC10A 		fsitos	s1, s2
 6939 0246 4FF4DA71 		mov	r1, #436
 6940 024a 10EE900A 		fmrs	r0, s1
 6941 024e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 458:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMaxYaw, SERVOMAXYAW_ADR);
 6942              		.loc 25 458 0
 6943 0252 244B     		ldr	r3, .L409+116
 6944 0254 1A68     		ldr	r2, [r3, #0]
 6945 0256 00EE102A 		fmsr	s0, r2	@ int
 6946 025a F8EEC07A 		fsitos	s15, s0
 6947 025e 4FF4DC71 		mov	r1, #440
 6948 0262 17EE900A 		fmrs	r0, s15
 6949 0266 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 6950              	.LBB173:
 6951              	.LBB174:
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 6952              		.loc 26 185 0
 6953              	@ 185 "../Libmaple/libmaple/libmaple/nvic.h" 1
 6954 026a 62B6     		cpsie i
 6955              	@ 0 "" 2
 6956              		.thumb
 6957              	.LBE174:
 6958              	.LBE173:
 6959              	.LBE169:
 459:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #ifdef CameraTXControl
 460:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeFloat(servoTXChannels, SERVOTXCHANNELS_ADR);
 461:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 462:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif 
 463:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   sei(); // Restart interrupts
 464:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 6960              		.loc 25 464 0
 6961 026c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 6962              	.L410:
 6963 026e 00BF     		.align	2
 6964              	.L409:
 6965 0270 00000000 		.word	.LANCHOR78
 6966 0274 FCFFFFFF 		.word	.LANCHOR4-4
 6967 0278 FCFFFFFF 		.word	.LANCHOR5-4
 6968 027c FCFFFFFF 		.word	.LANCHOR6-4
 6969 0280 CDCCCC3D 		.word	1036831949
 6970 0284 0000B442 		.word	1119092736
 6971 0288 00007A43 		.word	1132068864
 6972 028c 000048C2 		.word	-1035468800
 6973 0290 00004842 		.word	1112014848
 6974 0294 00000000 		.word	.LANCHOR95
 6975 0298 00000000 		.word	.LANCHOR55
 6976 029c 00000000 		.word	.LANCHOR83
 6977 02a0 00000000 		.word	.LANCHOR96
 6978 02a4 00000000 		.word	.LANCHOR77
 6979 02a8 00000000 		.word	.LANCHOR86
 6980 02ac 00000000 		.word	.LANCHOR31
 6981 02b0 CDCC4C40 		.word	1078774989
 6982 02b4 00000000 		.word	.LANCHOR60
 6983 02b8 00000000 		.word	.LANCHOR61
 6984 02bc 00000000 		.word	.LANCHOR65
 6985 02c0 00000000 		.word	.LANCHOR69
 6986 02c4 00000000 		.word	.LANCHOR62
 6987 02c8 00000000 		.word	.LANCHOR66
 6988 02cc 00000000 		.word	.LANCHOR70
 6989 02d0 00000000 		.word	.LANCHOR63
 6990 02d4 00000000 		.word	.LANCHOR67
 6991 02d8 00000000 		.word	.LANCHOR71
 6992 02dc 00000000 		.word	.LANCHOR64
 6993 02e0 00000000 		.word	.LANCHOR68
 6994 02e4 00000000 		.word	.LANCHOR72
 6995              		.cfi_endproc
 6996              	.LFE213:
 6998              		.section	.text._Z25initSensorsZeroFromEEPROMv,"ax",%progbits
 6999              		.align	1
 7000              		.global	_Z25initSensorsZeroFromEEPROMv
 7001              		.thumb
 7002              		.thumb_func
 7004              	_Z25initSensorsZeroFromEEPROMv:
 7005              	.LFB214:
 465:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 466:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void initSensorsZeroFromEEPROM() {
 7006              		.loc 25 466 0
 7007              		.cfi_startproc
 7008              		@ args = 0, pretend = 0, frame = 0
 7009              		@ frame_needed = 0, uses_anonymous_args = 0
 7010 0000 38B5     		push	{r3, r4, r5, lr}
 7011              	.LCFI62:
 7012              		.cfi_def_cfa_offset 16
 7013              		.cfi_offset 14, -4
 7014              		.cfi_offset 5, -8
 7015              		.cfi_offset 4, -12
 7016              		.cfi_offset 3, -16
 467:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 468:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Accel initialization from EEPROM
 469:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 7017              		.loc 25 469 0
 7018 0002 4FF49870 		mov	r0, #304
 7019 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 7020 000a 114B     		ldr	r3, .L412
 470:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Accel calibration
 471:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelScaleFactor[XAXIS] = readFloat(XAXIS_ACCEL_SCALE_FACTOR_ADR);
 7021              		.loc 25 471 0
 7022 000c 114D     		ldr	r5, .L412+4
 469:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 7023              		.loc 25 469 0
 7024 000e 1860     		str	r0, [r3, #0]	@ float
 7025              		.loc 25 471 0
 7026 0010 4FF4AA70 		mov	r0, #340
 7027 0014 FFF7FEFF 		bl	_Z12nvrReadFloati
 7028 0018 2860     		str	r0, [r5, #0]	@ float
 472:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   runTimeAccelBias[XAXIS] = readFloat(XAXIS_ACCEL_BIAS_ADR);
 7029              		.loc 25 472 0
 7030 001a 4FF4A870 		mov	r0, #336
 7031 001e FFF7FEFF 		bl	_Z12nvrReadFloati
 7032 0022 0D4C     		ldr	r4, .L412+8
 7033 0024 2060     		str	r0, [r4, #0]	@ float
 473:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelScaleFactor[YAXIS] = readFloat(YAXIS_ACCEL_SCALE_FACTOR_ADR);
 7034              		.loc 25 473 0
 7035 0026 4FF4AE70 		mov	r0, #348
 7036 002a FFF7FEFF 		bl	_Z12nvrReadFloati
 7037 002e 6860     		str	r0, [r5, #4]	@ float
 474:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   runTimeAccelBias[YAXIS] = readFloat(YAXIS_ACCEL_BIAS_ADR);
 7038              		.loc 25 474 0
 7039 0030 4FF4AC70 		mov	r0, #344
 7040 0034 FFF7FEFF 		bl	_Z12nvrReadFloati
 7041 0038 6060     		str	r0, [r4, #4]	@ float
 475:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelScaleFactor[ZAXIS] = readFloat(ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 7042              		.loc 25 475 0
 7043 003a 4FF4B270 		mov	r0, #356
 7044 003e FFF7FEFF 		bl	_Z12nvrReadFloati
 7045 0042 A860     		str	r0, [r5, #8]	@ float
 476:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   runTimeAccelBias[ZAXIS] = readFloat(ZAXIS_ACCEL_BIAS_ADR);
 7046              		.loc 25 476 0
 7047 0044 4FF4B070 		mov	r0, #352
 7048 0048 FFF7FEFF 		bl	_Z12nvrReadFloati
 7049 004c A060     		str	r0, [r4, #8]	@ float
 477:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 7050              		.loc 25 477 0
 7051 004e 38BD     		pop	{r3, r4, r5, pc}
 7052              	.L413:
 7053              		.align	2
 7054              	.L412:
 7055 0050 00000000 		.word	.LANCHOR31
 7056 0054 00000000 		.word	.LANCHOR27
 7057 0058 00000000 		.word	.LANCHOR28
 7058              		.cfi_endproc
 7059              	.LFE214:
 7061              		.section	.text._Z24storeSensorsZeroToEEPROMv,"ax",%progbits
 7062              		.align	1
 7063              		.global	_Z24storeSensorsZeroToEEPROMv
 7064              		.thumb
 7065              		.thumb_func
 7067              	_Z24storeSensorsZeroToEEPROMv:
 7068              	.LFB215:
 478:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 479:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void storeSensorsZeroToEEPROM() {
 7069              		.loc 25 479 0
 7070              		.cfi_startproc
 7071              		@ args = 0, pretend = 0, frame = 0
 7072              		@ frame_needed = 0, uses_anonymous_args = 0
 7073 0000 38B5     		push	{r3, r4, r5, lr}
 7074              	.LCFI63:
 7075              		.cfi_def_cfa_offset 16
 7076              		.cfi_offset 14, -4
 7077              		.cfi_offset 5, -8
 7078              		.cfi_offset 4, -12
 7079              		.cfi_offset 3, -16
 480:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 481:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Store accel data to EEPROM
 482:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 7080              		.loc 25 482 0
 7081 0002 144B     		ldr	r3, .L415
 483:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Accel Cal
 484:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 7082              		.loc 25 484 0
 7083 0004 144D     		ldr	r5, .L415+4
 482:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 7084              		.loc 25 482 0
 7085 0006 1868     		ldr	r0, [r3, #0]	@ float
 485:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(runTimeAccelBias[XAXIS], XAXIS_ACCEL_BIAS_ADR);
 7086              		.loc 25 485 0
 7087 0008 144C     		ldr	r4, .L415+8
 482:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 7088              		.loc 25 482 0
 7089 000a 4FF49871 		mov	r1, #304
 7090 000e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 484:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 7091              		.loc 25 484 0
 7092 0012 2868     		ldr	r0, [r5, #0]	@ float
 7093 0014 4FF4AA71 		mov	r1, #340
 7094 0018 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 7095              		.loc 25 485 0
 7096 001c 2068     		ldr	r0, [r4, #0]	@ float
 7097 001e 4FF4A871 		mov	r1, #336
 7098 0022 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 486:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelScaleFactor[YAXIS], YAXIS_ACCEL_SCALE_FACTOR_ADR);
 7099              		.loc 25 486 0
 7100 0026 6868     		ldr	r0, [r5, #4]	@ float
 7101 0028 4FF4AE71 		mov	r1, #348
 7102 002c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 487:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(runTimeAccelBias[YAXIS], YAXIS_ACCEL_BIAS_ADR);
 7103              		.loc 25 487 0
 7104 0030 6068     		ldr	r0, [r4, #4]	@ float
 7105 0032 4FF4AC71 		mov	r1, #344
 7106 0036 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 488:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelScaleFactor[ZAXIS], ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 7107              		.loc 25 488 0
 7108 003a A868     		ldr	r0, [r5, #8]	@ float
 7109 003c 4FF4B271 		mov	r1, #356
 7110 0040 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 489:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 7111              		.loc 25 489 0
 7112 0044 A068     		ldr	r0, [r4, #8]	@ float
 7113 0046 4FF4B071 		mov	r1, #352
 490:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 7114              		.loc 25 490 0
 7115 004a BDE83840 		pop	{r3, r4, r5, lr}
 489:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 7116              		.loc 25 489 0
 7117 004e FFF7FEBF 		b	_Z13nvrWriteFloatfi
 7118              	.L416:
 7119 0052 00BF     		.align	2
 7120              	.L415:
 7121 0054 00000000 		.word	.LANCHOR31
 7122 0058 00000000 		.word	.LANCHOR27
 7123 005c 00000000 		.word	.LANCHOR28
 7124              		.cfi_endproc
 7125              	.LFE215:
 7127              		.section	.text._Z46processZeroThrottleFunctionFromReceiverCommandv,"ax",%progbits
 7128              		.align	1
 7129              		.global	_Z46processZeroThrottleFunctionFromReceiverCommandv
 7130              		.thumb
 7131              		.thumb_func
 7133              	_Z46processZeroThrottleFunctionFromReceiverCommandv:
 7134              	.LFB202:
 7135              		.file 27 "/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h"
   1:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** /*
   2:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  www.AeroQuad.com
   4:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  An Open Source Arduino based multicopter.
   6:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  
   7:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  This program is free software: you can redistribute it and/or modify 
   8:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  it under the terms of the GNU General Public License as published by 
   9:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  the Free Software Foundation, either version 3 of the License, or 
  10:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  (at your option) any later version. 
  11:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  
  12:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  This program is distributed in the hope that it will be useful, 
  13:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  GNU General Public License for more details. 
  16:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  
  17:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  You should have received a copy of the GNU General Public License 
  18:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  */
  20:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  21:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** // FlightCommandProcessor is responsible for decoding transmitter stick combinations
  22:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** // for setting up AeroQuad modes such as motor arming and disarming
  23:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  24:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #ifndef _AQ_FLIGHT_COMMAND_READER_
  25:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #define _AQ_FLIGHT_COMMAND_READER_
  26:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  27:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  28:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  29:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  30:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined (AltitudeHoldBaro) || defined (AltitudeHoldRangeFinder)
  31:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   boolean isPositionHoldEnabledByUser() {
  32:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #if defined (UseGPSNavigator)
  33:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if ((receiverCommand[AUX1] < 1750) || (receiverCommand[AUX2] < 1750)) {
  34:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         return true;
  35:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
  36:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       return false;
  37:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #else
  38:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (receiverCommand[AUX1] < 1750) {
  39:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         return true;
  40:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
  41:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       return false;
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif
  43:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
  45:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  46:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  47:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   void processAltitudeHoldStateFromReceiverCommand() {
  48:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (isPositionHoldEnabledByUser()) {
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if (!isAltitudeHoldInitialized) {
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #if defined AltitudeHoldBaro
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
  53:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
  54:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #endif
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #if defined AltitudeHoldRangeFinder
  57:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].lastError = sonarAltitudeToHoldTarget;
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #endif
  61:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
  62:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           isAltitudeHoldInitialized = true;
  63:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         altitudeHoldState = ON;
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
  66:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     } 
  67:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else {
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isAltitudeHoldInitialized = false;
  69:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       altitudeHoldState = OFF;
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
  72:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  75:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined (AutoLanding)
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   void processAutoLandingStateFromReceiverCommand() {
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (receiverCommand[AUX3] < 1750) {
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
  79:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if (isAutoLandingInitialized) {
  80:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           autoLandingState = BARO_AUTO_DESCENT_STATE;
  81:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #if defined AltitudeHoldBaro
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
  85:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #endif
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #if defined AltitudeHoldRangeFinder
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
  88:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
  89:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].lastError = sonarAltitudeToHoldTarget;
  90:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #endif
  91:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           isAutoLandingInitialized = true;
  93:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
  94:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         altitudeHoldState = ON;
  95:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
  96:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
  97:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else {
  98:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       autoLandingState = OFF;
  99:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       autoLandingThrottleCorrection = 0;
 100:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isAutoLandingInitialized = false;
 101:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       #if defined (UseGPSNavigator)
 102:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if ((receiverCommand[AUX1] > 1750) && (receiverCommand[AUX2] > 1750)) {
 103:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldState = OFF;
 104:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           isAltitudeHoldInitialized = false;
 105:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
 106:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       #else
 107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if (receiverCommand[AUX1] > 1750) {
 108:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldState = OFF;
 109:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           isAltitudeHoldInitialized = false;
 110:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
 111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       #endif
 112:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 113:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 114:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
 115:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 116:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 117:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined (UseGPSNavigator)
 118:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   void processGpsNavigationStateFromReceiverCommand() {
 119:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     // Init home command
 120:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (motorArmed == OFF && 
 121:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         receiverCommand[THROTTLE] < MINCHECK && receiverCommand[ZAXIS] < MINCHECK &&
 122:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         receiverCommand[YAXIS] > MAXCHECK && receiverCommand[XAXIS] > MAXCHECK &&
 123:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         haveAGpsLock()) {
 124:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       homePosition.latitude = currentPosition.latitude;
 126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       homePosition.longitude = currentPosition.longitude;
 127:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       homePosition.altitude = DEFAULT_HOME_ALTITUDE;
 128:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 129:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 130:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 131:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (receiverCommand[AUX2] < 1750) {  // Enter in execute mission state, if none, go back home, 
 132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (!isGpsNavigationInitialized) {
 133:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsRollAxisCorrection = 0;
 134:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsPitchAxisCorrection = 0;
 135:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsYawAxisCorrection = 0;
 136:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         isGpsNavigationInitialized = true;
 137:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
 138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 139:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       positionHoldState = OFF;         // disable the position hold while navigating
 140:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isPositionHoldInitialized = false;
 141:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 142:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       navigationState = ON;
 143:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 144:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else if (receiverCommand[AUX1] < 1250) {  // Enter in position hold state
 145:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (!isPositionHoldInitialized) {
 146:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsRollAxisCorrection = 0;
 147:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsPitchAxisCorrection = 0;
 148:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsYawAxisCorrection = 0;
 149:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 150:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         positionHoldPointToReach.latitude = currentPosition.latitude;
 151:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         positionHoldPointToReach.longitude = currentPosition.longitude;
 152:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         positionHoldPointToReach.altitude = getBaroAltitude();
 153:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         isPositionHoldInitialized = true;
 154:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
 155:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 156:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isGpsNavigationInitialized = false;  // disable navigation
 157:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       navigationState = OFF;
 158:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 159:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       positionHoldState = ON;
 160:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 161:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else {
 162:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       // Navigation and position hold are disabled
 163:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       positionHoldState = OFF;
 164:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isPositionHoldInitialized = false;
 165:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 166:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       navigationState = OFF;
 167:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isGpsNavigationInitialized = false;
 168:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 169:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       gpsRollAxisCorrection = 0;
 170:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       gpsPitchAxisCorrection = 0;
 171:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       gpsYawAxisCorrection = 0;
 172:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 173:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 174:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
 175:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 176:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 177:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 178:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 179:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** void processZeroThrottleFunctionFromReceiverCommand() {
 7136              		.loc 27 179 0
 7137              		.cfi_startproc
 7138              		@ args = 0, pretend = 0, frame = 0
 7139              		@ frame_needed = 0, uses_anonymous_args = 0
 7140 0000 38B5     		push	{r3, r4, r5, lr}
 7141              	.LCFI64:
 7142              		.cfi_def_cfa_offset 16
 7143              		.cfi_offset 14, -4
 7144              		.cfi_offset 5, -8
 7145              		.cfi_offset 4, -12
 7146              		.cfi_offset 3, -16
 7147              	.LBB175:
 180:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   // Disarm motors (left stick lower left corner)
 181:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] < MINCHECK && motorArmed == ON) {
 7148              		.loc 27 181 0
 7149 0002 254C     		ldr	r4, .L422
 7150 0004 A268     		ldr	r2, [r4, #8]
 7151 0006 40F24B43 		movw	r3, #1099
 7152 000a 9A42     		cmp	r2, r3
 7153 000c 0BDC     		bgt	.L418
 7154              		.loc 27 181 0 is_stmt 0 discriminator 1
 7155 000e 234D     		ldr	r5, .L422+4
 7156 0010 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 7157 0012 0128     		cmp	r0, #1
 7158 0014 07D1     		bne	.L418
 182:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     commandAllMotors(MINCOMMAND);
 7159              		.loc 27 182 0 is_stmt 1
 7160 0016 4FF47A70 		mov	r0, #1000
 7161 001a FFF7FEFF 		bl	_Z16commandAllMotorsi
 183:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     motorArmed = OFF;
 184:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     inFlight = false;
 7162              		.loc 27 184 0
 7163 001e 2049     		ldr	r1, .L422+8
 183:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     motorArmed = OFF;
 7164              		.loc 27 183 0
 7165 0020 0022     		movs	r2, #0
 7166 0022 2A70     		strb	r2, [r5, #0]
 7167              		.loc 27 184 0
 7168 0024 0A70     		strb	r2, [r1, #0]
 7169              	.L418:
 185:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 186:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #ifdef OSD
 187:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       notifyOSD(OSD_CENTER|OSD_WARN, "MOTORS UNARMED");
 188:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif
 189:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 190:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #if defined BattMonitorAutoDescent
 191:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       batteryMonitorAlarmCounter = 0;
 192:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       batteryMonitorStartThrottle = 0;
 193:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       batteyMonitorThrottleCorrection = 0.0;
 194:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif
 195:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }    
 196:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 197:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   // Zero Gyro and Accel sensors (left stick lower left, right stick lower right corner)
 198:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if ((receiverCommand[ZAXIS] < MINCHECK) && (receiverCommand[XAXIS] > MAXCHECK) && (receiverComman
 7170              		.loc 27 198 0
 7171 0026 A068     		ldr	r0, [r4, #8]
 7172 0028 1B4A     		ldr	r2, .L422
 7173 002a 40F24B43 		movw	r3, #1099
 7174 002e 9842     		cmp	r0, r3
 7175 0030 12DC     		bgt	.L419
 7176              		.loc 27 198 0 is_stmt 0 discriminator 1
 7177 0032 1068     		ldr	r0, [r2, #0]
 7178 0034 40F26C7C 		movw	ip, #1900
 7179 0038 6045     		cmp	r0, ip
 7180 003a 0DDD     		ble	.L419
 7181              		.loc 27 198 0 discriminator 2
 7182 003c 5168     		ldr	r1, [r2, #4]
 7183 003e 9942     		cmp	r1, r3
 7184 0040 0ADC     		bgt	.L419
 199:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     calibrateGyro();
 7185              		.loc 27 199 0 is_stmt 1
 7186 0042 FFF7FEFF 		bl	_Z13calibrateGyrov
 200:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     computeAccelBias();
 7187              		.loc 27 200 0
 7188 0046 FFF7FEFF 		bl	_Z16computeAccelBiasv
 201:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     storeSensorsZeroToEEPROM();
 7189              		.loc 27 201 0
 7190 004a FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 202:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     calibrateKinematics();
 203:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     zeroIntegralError();
 7191              		.loc 27 203 0
 7192 004e FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 204:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     pulseMotors(3);
 7193              		.loc 27 204 0
 7194 0052 0320     		movs	r0, #3
 7195 0054 FFF7FEFF 		bl	_Z11pulseMotorsh
 7196              	.L419:
 7197              	.LBB176:
 205:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }   
 206:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 207:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   // Arm motors (left stick lower right corner)
 208:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] > MAXCHECK && motorArmed == OFF && safetyCheck == ON) {
 7198              		.loc 27 208 0
 7199 0058 A268     		ldr	r2, [r4, #8]
 7200 005a 40F26C73 		movw	r3, #1900
 7201 005e 9A42     		cmp	r2, r3
 7202 0060 10DD     		ble	.L420
 7203              		.loc 27 208 0 is_stmt 0 discriminator 1
 7204 0062 0E4B     		ldr	r3, .L422+4
 7205 0064 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 7206 0066 68B9     		cbnz	r0, .L420
 7207              		.loc 27 208 0 discriminator 2
 7208 0068 0E49     		ldr	r1, .L422+12
 7209 006a 0A78     		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 7210 006c 012A     		cmp	r2, #1
 7211 006e 09D1     		bne	.L420
 7212              	.LVL320:
 7213              	.LBB177:
 7214              	.LBB178:
 209:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 210:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #ifdef OSD_SYSTEM_MENU
 211:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (menuOwnsSticks) {
 212:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         return;
 213:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
 214:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif
 215:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 216:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 217:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       motorCommand[motor] = MINTHROTTLE;
 7215              		.loc 27 217 0 is_stmt 1 discriminator 1
 7216 0070 0D49     		ldr	r1, .L422+16
 7217              	.LBE178:
 218:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 219:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     motorArmed = ON;
 7218              		.loc 27 219 0 discriminator 1
 7219 0072 1A70     		strb	r2, [r3, #0]
 7220              	.LBB179:
 217:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       motorCommand[motor] = MINTHROTTLE;
 7221              		.loc 27 217 0 discriminator 1
 7222 0074 40F24C40 		movw	r0, #1100
 7223 0078 0860     		str	r0, [r1, #0]
 7224              	.LVL321:
 7225 007a 4860     		str	r0, [r1, #4]
 7226              	.LVL322:
 7227 007c 8860     		str	r0, [r1, #8]
 7228              	.LVL323:
 7229 007e C860     		str	r0, [r1, #12]
 7230              	.LVL324:
 7231              	.LBE179:
 220:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 221:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #ifdef OSD
 222:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       notifyOSD(OSD_CENTER|OSD_WARN, "!MOTORS ARMED!");
 223:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif  
 224:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 225:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     zeroIntegralError();
 7232              		.loc 27 225 0 discriminator 1
 7233 0080 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 7234              	.LVL325:
 7235              	.L420:
 7236              	.LBE177:
 7237              	.LBE176:
 226:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 227:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 228:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   // Prevents accidental arming of motor output if no transmitter command received
 229:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] > MINCHECK) {
 7238              		.loc 27 229 0
 7239 0084 A268     		ldr	r2, [r4, #8]
 7240 0086 40F24C4C 		movw	ip, #1100
 7241 008a 6245     		cmp	r2, ip
 7242 008c 02DD     		ble	.L417
 230:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     safetyCheck = ON; 
 7243              		.loc 27 230 0
 7244 008e 054B     		ldr	r3, .L422+12
 7245 0090 0120     		movs	r0, #1
 7246 0092 1870     		strb	r0, [r3, #0]
 7247              	.L417:
 7248 0094 38BD     		pop	{r3, r4, r5, pc}
 7249              	.L423:
 7250 0096 00BF     		.align	2
 7251              	.L422:
 7252 0098 00000000 		.word	.LANCHOR1
 7253 009c 00000000 		.word	.LANCHOR94
 7254 00a0 00000000 		.word	.LANCHOR8
 7255 00a4 00000000 		.word	.LANCHOR82
 7256 00a8 00000000 		.word	.LANCHOR56
 7257              	.LBE175:
 7258              		.cfi_endproc
 7259              	.LFE202:
 7261              		.section	.text._Z17readPilotCommandsv,"ax",%progbits
 7262              		.align	1
 7263              		.global	_Z17readPilotCommandsv
 7264              		.thumb
 7265              		.thumb_func
 7267              	_Z17readPilotCommandsv:
 7268              	.LFB203:
 231:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 232:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** }
 233:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 234:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 235:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 236:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 237:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** /**
 238:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  * readPilotCommands
 239:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  * 
 240:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  * This function is responsible to read receiver
 241:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  * and process command from the users
 242:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  */
 243:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** void readPilotCommands() {
 7269              		.loc 27 243 0
 7270              		.cfi_startproc
 7271              		@ args = 0, pretend = 0, frame = 0
 7272              		@ frame_needed = 0, uses_anonymous_args = 0
 7273 0000 38B5     		push	{r3, r4, r5, lr}
 7274              	.LCFI65:
 7275              		.cfi_def_cfa_offset 16
 7276              		.cfi_offset 14, -4
 7277              		.cfi_offset 5, -8
 7278              		.cfi_offset 4, -12
 7279              		.cfi_offset 3, -16
 244:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 245:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   readReceiver(); 
 246:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 247:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 7280              		.loc 27 247 0
 7281 0002 164C     		ldr	r4, .L428
 245:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   readReceiver(); 
 7282              		.loc 27 245 0
 7283 0004 FFF7FEFF 		bl	_Z12readReceiverv
 7284              		.loc 27 247 0
 7285 0008 E268     		ldr	r2, [r4, #12]
 7286 000a 40F24B43 		movw	r3, #1099
 7287 000e 9A42     		cmp	r2, r3
 7288 0010 01DC     		bgt	.L425
 248:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     processZeroThrottleFunctionFromReceiverCommand();
 7289              		.loc 27 248 0
 7290 0012 FFF7FEFF 		bl	_Z46processZeroThrottleFunctionFromReceiverCommandv
 7291              	.L425:
 249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 250:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 251:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (!inFlight) {
 7292              		.loc 27 251 0
 7293 0016 124B     		ldr	r3, .L428+4
 7294 0018 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 7295 001a 48B9     		cbnz	r0, .L426
 252:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (motorArmed == ON && receiverCommand[THROTTLE] > minArmedThrottle) {
 7296              		.loc 27 252 0
 7297 001c 1149     		ldr	r1, .L428+8
 7298 001e 0A78     		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 7299 0020 012A     		cmp	r2, #1
 7300 0022 05D1     		bne	.L426
 7301              		.loc 27 252 0 is_stmt 0 discriminator 1
 7302 0024 1049     		ldr	r1, .L428+12
 7303 0026 E568     		ldr	r5, [r4, #12]
 7304 0028 0868     		ldr	r0, [r1, #0]
 7305 002a 8542     		cmp	r5, r0
 253:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       inFlight = true;
 7306              		.loc 27 253 0 is_stmt 1 discriminator 1
 7307 002c C8BF     		it	gt
 7308 002e 1A70     		strbgt	r2, [r3, #0]
 7309              	.L426:
 254:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 255:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 256:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 257:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     // Check Mode switch for Acro or Stable
 258:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (receiverCommand[MODE] > 1500) {
 259:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         flightMode = ATTITUDE_FLIGHT_MODE;
 7310              		.loc 27 259 0
 7311 0030 2469     		ldr	r4, [r4, #16]
 7312 0032 0E4D     		ldr	r5, .L428+16
 7313 0034 40F2DC5E 		movw	lr, #1500
 7314 0038 7445     		cmp	r4, lr
 260:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 261:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else {
 262:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         flightMode = RATE_FLIGHT_MODE;
 263:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 264:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     
 265:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (previousFlightMode != flightMode) {
 7315              		.loc 27 265 0
 7316 003a 0D4C     		ldr	r4, .L428+20
 7317 003c 94F800C0 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
 259:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         flightMode = ATTITUDE_FLIGHT_MODE;
 7318              		.loc 27 259 0
 7319 0040 D4BF     		ite	le
 7320 0042 4FF0000E 		movle	lr, #0
 7321 0046 4FF0010E 		movgt	lr, #1
 7322              		.loc 27 265 0
 7323 004a F445     		cmp	ip, lr
 259:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         flightMode = ATTITUDE_FLIGHT_MODE;
 7324              		.loc 27 259 0
 7325 004c 85F800E0 		strb	lr, [r5, #0]
 7326              		.loc 27 265 0
 7327 0050 03D0     		beq	.L424
 266:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       zeroIntegralError();
 7328              		.loc 27 266 0
 7329 0052 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 267:/home/james/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       previousFlightMode = flightMode;
 7330              		.loc 27 267 0
 7331 0056 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 7332 0058 2270     		strb	r2, [r4, #0]
 7333              	.L424:
 7334 005a 38BD     		pop	{r3, r4, r5, pc}
 7335              	.L429:
 7336              		.align	2
 7337              	.L428:
 7338 005c 00000000 		.word	.LANCHOR1
 7339 0060 00000000 		.word	.LANCHOR8
 7340 0064 00000000 		.word	.LANCHOR94
 7341 0068 00000000 		.word	.LANCHOR83
 7342 006c 00000000 		.word	.LANCHOR77
 7343 0070 00000000 		.word	.LANCHOR97
 7344              		.cfi_endproc
 7345              	.LFE203:
 7347              		.section	.text._Z22initReceiverFromEEPROMv,"ax",%progbits
 7348              		.align	1
 7349              		.global	_Z22initReceiverFromEEPROMv
 7350              		.thumb
 7351              		.thumb_func
 7353              	_Z22initReceiverFromEEPROMv:
 7354              	.LFB216:
 491:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 492:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void initReceiverFromEEPROM() {
 7355              		.loc 25 492 0
 7356              		.cfi_startproc
 7357              		@ args = 0, pretend = 0, frame = 0
 7358              		@ frame_needed = 0, uses_anonymous_args = 0
 7359 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 7360              	.LCFI66:
 7361              		.cfi_def_cfa_offset 24
 7362              		.cfi_offset 14, -4
 7363              		.cfi_offset 7, -8
 7364              		.cfi_offset 6, -12
 7365              		.cfi_offset 5, -16
 7366              		.cfi_offset 4, -20
 7367              		.cfi_offset 3, -24
 7368              	.LBB180:
 493:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverXmitFactor = readFloat(XMITFACTOR_ADR);
 7369              		.loc 25 493 0
 7370 0002 4FF48E70 		mov	r0, #284
 7371 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 7372 000a 0E4B     		ldr	r3, .L433
 7373 000c 0E4F     		ldr	r7, .L433+4
 7374 000e 0F4E     		ldr	r6, .L433+8
 7375 0010 0F4D     		ldr	r5, .L433+12
 7376 0012 1860     		str	r0, [r3, #0]	@ float
 7377              	.LVL326:
 7378 0014 0024     		movs	r4, #0
 7379              	.LVL327:
 7380              	.L431:
 7381              	.LBB181:
 494:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 495:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 496:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSlope[channel] = readFloat(RECEIVER_DATA[channel].slope);
 7382              		.loc 25 496 0 discriminator 2
 7383 0016 04F19C00 		add	r0, r4, #156
 7384 001a FFF7FEFF 		bl	_Z12nvrReadFloati
 7385 001e 47F8040F 		str	r0, [r7, #4]!	@ float
 497:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverOffset[channel] = readFloat(RECEIVER_DATA[channel].offset);
 7386              		.loc 25 497 0 discriminator 2
 7387 0022 04F1A000 		add	r0, r4, #160
 7388 0026 FFF7FEFF 		bl	_Z12nvrReadFloati
 7389 002a 46F8040F 		str	r0, [r6, #4]!	@ float
 498:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSmoothFactor[channel] = readFloat(RECEIVER_DATA[channel].smooth_factor);
 7390              		.loc 25 498 0 discriminator 2
 7391 002e 04F1A400 		add	r0, r4, #164
 7392 0032 FFF7FEFF 		bl	_Z12nvrReadFloati
 7393 0036 0C34     		adds	r4, r4, #12
 495:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 7394              		.loc 25 495 0 discriminator 2
 7395 0038 602C     		cmp	r4, #96
 7396              		.loc 25 498 0 discriminator 2
 7397 003a 45F8040F 		str	r0, [r5, #4]!	@ float
 495:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 7398              		.loc 25 495 0 discriminator 2
 7399 003e EAD1     		bne	.L431
 7400              	.LBE181:
 7401              	.LBE180:
 499:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 500:/home/james/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 7402              		.loc 25 500 0
 7403 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7404              	.L434:
 7405 0042 00BF     		.align	2
 7406              	.L433:
 7407 0044 00000000 		.word	.LANCHOR55
 7408 0048 FCFFFFFF 		.word	.LANCHOR4-4
 7409 004c FCFFFFFF 		.word	.LANCHOR5-4
 7410 0050 FCFFFFFF 		.word	.LANCHOR6-4
 7411              		.cfi_endproc
 7412              	.LFE216:
 7414              		.section	.text._Z17initCommunicationv,"ax",%progbits
 7415              		.align	1
 7416              		.global	_Z17initCommunicationv
 7417              		.thumb
 7418              		.thumb_func
 7420              	_Z17initCommunicationv:
 7421              	.LFB217:
 7422              		.file 28 "/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h"
   1:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** /*
   2:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   www.AeroQuad.com
   4:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   An Open Source Arduino based multicopter.
   6:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
   7:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   This program is free software: you can redistribute it and/or modify
   8:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   it under the terms of the GNU General Public License as published by
   9:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   the Free Software Foundation, either version 3 of the License, or
  10:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   (at your option) any later version.
  11:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  12:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   This program is distributed in the hope that it will be useful,
  13:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   GNU General Public License for more details.
  16:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  17:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   You should have received a copy of the GNU General Public License
  18:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** */
  20:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  21:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // SerialCom.pde is responsible for the serial communication for commands and telemetry from the Ae
  22:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // This comtains readSerialCommand() which listens for a serial command and it's arguments
  23:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // This also contains readSerialTelemetry() which listens for a telemetry request and responds with
  24:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // For more information on each command/telemetry look at: http://aeroquad.com/content.php?117
  25:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  26:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // Includes re-write / fixes from Aadamson and ala42, special thanks to those guys!
  27:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // http://aeroquad.com/showthread.php?1461-We-have-some-hidden-warnings&p=14618&viewfull=1#post1461
  28:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  29:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #ifndef _AQ_SERIAL_COMM_
  30:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #define _AQ_SERIAL_COMM_
  31:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  32:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** char queryType = 'X';
  33:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  34:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void initCommunication() {
 7423              		.loc 28 34 0
 7424              		.cfi_startproc
 7425              		@ args = 0, pretend = 0, frame = 0
 7426              		@ frame_needed = 0, uses_anonymous_args = 0
 7427              		@ link register save eliminated.
  35:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // do nothing here for now
  36:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7428              		.loc 28 36 0
 7429 0000 7047     		bx	lr
 7430              		.cfi_endproc
 7431              	.LFE217:
 7433              		.section	.text._Z10getHeadingv,"ax",%progbits
 7434              		.align	1
 7435              		.global	_Z10getHeadingv
 7436              		.thumb
 7437              		.thumb_func
 7439              	_Z10getHeadingv:
 7440              	.LFB231:
  37:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  38:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //*************************************************************************************************
  39:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //********************************** Serial Commands **********************************************
  40:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //*************************************************************************************************
  41:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** bool validateCalibrateCommand(byte command)
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
  43:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     motorArmed = OFF;
  45:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     calibrateESC = command;
  46:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return true;
  47:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
  48:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   else {
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     calibrateESC = 0;
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     testCommand = 1000;
  51:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return false;
  52:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
  53:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
  54:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialPID(unsigned char PIDid) {
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
  57:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->P = readFloatSerial();
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->I = readFloatSerial();
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->D = readFloatSerial();
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->lastError = 0;
  61:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->integratedError = 0;
  62:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
  63:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void skipSerialValues(byte number) {
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
  66:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     readFloatSerial();
  67:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
  69:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialCommand() {
  71:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Check for serial message
  72:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (SERIAL_AVAILABLE()) {
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = SERIAL_READ();
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     switch (queryType) {
  75:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'A': // Receive roll and pitch rate mode PID
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
  79:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
  80:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  81:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'B': // Receive roll/pitch attitude mode PID
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
  85:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       windupGuard = readFloatSerial(); // defaults found in setup() of AeroQuad.pde
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
  88:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  89:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'C': // Receive yaw PID
  90:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
  91:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       headingHoldConfig = readFloatSerial();
  93:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
  94:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  95:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'D': // Altitude hold PID
  96:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  97:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(BARO_ALTITUDE_HOLD_PID_IDX);
  98:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloatSerial();
  99:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         altitudeHoldBump = readFloatSerial();
 100:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         altitudeHoldPanicStickMovement = readFloatSerial();
 101:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         minThrottleAdjust = readFloatSerial();
 102:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         maxThrottleAdjust = readFloatSerial();
 103:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #if defined AltitudeHoldBaro
 104:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           baroSmoothFactor = readFloatSerial();
 105:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #else
 106:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           readFloatSerial();
 107:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #endif
 108:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 109:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 110:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 111:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 112:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'E': // Receive sensor filtering values
 113:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       aref = readFloatSerial();
 114:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       minArmedThrottle = readFloatSerial();
 115:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 116:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 117:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'F': // Receive transmitter smoothing values
 118:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 119:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 120:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 121:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 122:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 123:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 124:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'G': // Receive transmitter calibration values
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       channelCal = (int)readFloatSerial();
 126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 127:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 128:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 129:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'H': // Receive transmitter calibration values
 130:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       channelCal = (int)readFloatSerial();
 131:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 133:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 134:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'I': // Initialize EEPROM with default values
 135:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 136:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       writeEEPROM();
 137:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       calibrateGyro();
 139:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       zeroIntegralError();
 140:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef HeadingMagHold
 141:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         initializeMagnetometer();
 142:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 143:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef AltitudeHoldBaro
 144:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         initializeBaro();
 145:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 146:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 147:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 148:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'J': // calibrate gyros
 149:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       calibrateGyro();
 150:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 151:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 152:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'K': // Write accel calibration values
 153:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 154:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 155:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 156:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 157:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 158:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 159:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       computeAccelBias();    
 160:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 161:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 162:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 163:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'L': // generate accel bias
 164:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       computeAccelBias();
 165:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 166:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateKinematics();
 167:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         accelOneG = meterPerSecSec[ZAXIS];
 168:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 169:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 170:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 171:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 172:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'M': // calibrate magnetometer
 173:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef HeadingMagHold
 174:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         magBias[XAXIS]  = readFloatSerial();
 175:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         magBias[YAXIS]  = readFloatSerial();
 176:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         magBias[ZAXIS]  = readFloatSerial();
 177:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         writeEEPROM();
 178:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 179:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(3);
 180:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 181:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 182:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 183:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'N': // battery monitor
 184:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef BattMonitor
 185:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         batteryMonitorAlarmVoltage = readFloatSerial();
 186:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         batteryMonitorThrottleTarget = readFloatSerial();
 187:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         batteryMonitorGoingDownTime = readFloatSerial();
 188:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 189:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 190:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(3);
 191:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 192:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 193:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 194:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'O': // define waypoints
 195:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef UseGPSNavigator
 196:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         missionNbPoint = readIntegerSerial();
 197:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         waypoint[missionNbPoint].latitude = readIntegerSerial();
 198:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         waypoint[missionNbPoint].longitude = readIntegerSerial();
 199:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         waypoint[missionNbPoint].altitude = readIntegerSerial();
 200:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 201:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         for(byte i = 0; i < 4; i++) {
 202:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           readFloatSerial();
 203:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         }
 204:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 205:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 206:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'P': //  read Camera values
 207:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef CameraControl
 208:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         cameraMode = readFloatSerial();
 209:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterPitch = readFloatSerial();
 210:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterRoll = readFloatSerial();
 211:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterYaw = readFloatSerial();
 212:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraPitch = readFloatSerial();
 213:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraRoll = readFloatSerial();
 214:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraYaw = readFloatSerial();
 215:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinPitch = readFloatSerial();
 216:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinRoll = readFloatSerial();
 217:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinYaw = readFloatSerial();
 218:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxPitch = readFloatSerial();
 219:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxRoll = readFloatSerial();
 220:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxYaw = readFloatSerial();
 221:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #ifdef CameraTXControl
 222:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           servoTXChannels = readFloatSerial();
 223:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #endif
 224:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 225:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #ifdef CameraTXControl
 226:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           skipSerialValues(14)
 227:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #else
 228:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           skipSerialValues(13);
 229:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #endif
 230:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 231:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 232:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 233:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'U': // Range Finder
 234:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined (AltitudeHoldRangeFinder)
 235:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         maxRangeFinderRange = readFloatSerial();
 236:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         minRangeFinderRange = readFloatSerial();
 237:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 238:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(2);
 239:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 240:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 241:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 242:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'V': // GPS
 243:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined (UseGPSNavigator)
 244:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSROLL_PID_IDX);
 245:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSPITCH_PID_IDX);
 246:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSYAW_PID_IDX);
 247:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         writeEEPROM();
 248:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(9);
 250:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 251:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 252:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 253:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'W': // Write all user configurable values to EEPROM
 254:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 255:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       zeroIntegralError();
 256:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 257:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 258:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'X': // Stop sending messages
 259:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 260:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 261:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '1': // Calibrate ESCS's by setting Throttle high on all channels
 262:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(1);
 263:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 264:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 265:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '2': // Calibrate ESC's by setting Throttle low on all channels
 266:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(2);
 267:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 268:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 269:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '3': // Test ESC calibration
 270:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(3)) {
 271:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = readFloatSerial();
 272:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 273:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 274:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 275:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '4': // Turn off ESC calibration
 276:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(4)) {
 277:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateESC = 0;
 278:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = 1000;
 279:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 280:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 281:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 282:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '5': // Send individual motor commands (motor, command)
 283:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(5)) {
 284:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++) {
 285:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 286:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         }
 287:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 288:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 289:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 290:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'Z': // fast telemetry transfer <--- get rid if this?
 291:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (readFloatSerial() == 1.0)
 292:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         fastTransfer = ON;
 293:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       else
 294:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         fastTransfer = OFF;
 295:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 296:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 297:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 299:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 300:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //*************************************************************************************************
 301:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //********************************* Serial Telemetry **********************************************
 302:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //*************************************************************************************************
 303:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 304:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(float val) {
 305:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 306:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 307:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 308:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 309:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(double val) {
 310:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 311:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 312:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 313:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 314:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(char val) {
 315:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 316:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 317:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 318:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(int val) {
 320:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 321:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 323:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 324:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(unsigned long val)
 325:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 326:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 327:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 328:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 329:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 330:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(byte val)
 331:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 332:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 333:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 334:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 335:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 336:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(long int val)
 337:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 338:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 339:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 340:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 341:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 342:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintPID(unsigned char IDPid)
 343:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 345:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 346:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 347:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 348:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 349:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintDummyValues(byte number) {
 350:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 351:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(0);
 352:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 353:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 354:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 355:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 356:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** float getHeading()
 357:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 7441              		.loc 28 357 0
 7442              		.cfi_startproc
 7443              		@ args = 0, pretend = 0, frame = 0
 7444              		@ frame_needed = 0, uses_anonymous_args = 0
 7445              		@ link register save eliminated.
 358:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #if defined(HeadingMagHold) || defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 359:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     float heading = trueNorthHeading;
 360:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     if (heading < 0) { 
 361:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       heading += (2.0 * M_PI);
 362:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 363:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return heading;
 364:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #else
 365:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return(gyroHeading);
 366:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #endif
 367:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7446              		.loc 28 367 0
 7447 0000 014B     		ldr	r3, .L437
 7448 0002 1868     		ldr	r0, [r3, #0]	@ float
 7449 0004 7047     		bx	lr
 7450              	.L438:
 7451 0006 00BF     		.align	2
 7452              	.L437:
 7453 0008 00000000 		.word	.LANCHOR20
 7454              		.cfi_endproc
 7455              	.LFE231:
 7457              		.section	.text._Z15readValueSerialPch,"ax",%progbits
 7458              		.align	1
 7459              		.global	_Z15readValueSerialPch
 7460              		.thumb
 7461              		.thumb_func
 7463              	_Z15readValueSerialPch:
 7464              	.LFB233:
 368:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 369:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 370:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 371:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '=': // Reserved debug command to view any variable from Serial Monitor
 372:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 373:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 374:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'a': // Send roll and pitch rate mode PID values
 375:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 376:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 377:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 378:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 379:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 380:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 381:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 382:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'b': // Send roll and pitch attitude mode PID values
 383:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 384:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 385:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 386:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 387:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(windupGuard);
 388:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 389:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 390:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 391:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'c': // Send yaw PID values
 392:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 393:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 394:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 395:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 396:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 397:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 398:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'd': // Altitude Hold
 399:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 400:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(BARO_ALTITUDE_HOLD_PID_IDX);
 401:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard);
 402:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldBump);
 403:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldPanicStickMovement);
 404:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(minThrottleAdjust);
 405:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(maxThrottleAdjust);
 406:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined AltitudeHoldBaro
 407:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(baroSmoothFactor);
 408:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 409:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(0);
 410:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 411:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(ZDAMPENING_PID_IDX);
 412:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(10);
 414:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 415:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 416:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 417:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 418:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 419:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'e': // miscellaneous config values
 420:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(aref);
 421:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 422:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 423:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 424:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 425:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'f': // Send transmitter smoothing values
 426:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 427:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 428:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 429:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 430:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintDummyValues(10 - LASTCHANNEL);
 431:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 432:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 433:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 434:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 435:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'g': // Send transmitter calibration data
 436:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 437:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 438:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(',');
 439:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 440:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 441:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 442:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 443:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 444:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'h': // Send transmitter calibration data
 445:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 446:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 447:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(',');
 448:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 449:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 450:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 451:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 452:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 453:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'i': // Send sensor data
 454:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 455:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 456:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 457:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 458:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 459:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 460:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 461:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined(HeadingMagHold)
 462:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 463:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 464:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(0);
 465:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 466:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 467:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 468:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 469:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 470:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'j': // Send raw mag values
 471:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef HeadingMagHold
 472:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(getMagnetometerRawData(XAXIS));
 473:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(getMagnetometerRawData(YAXIS));
 474:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 475:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 476:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 477:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 478:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'k': // Send accelerometer cal values
 479:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 480:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 481:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 482:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 483:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 484:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 485:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 486:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 487:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 488:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 489:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 490:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 491:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 492:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 493:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'l': // Send raw accel values
 494:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     measureAccelSum();
 495:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 496:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[XAXIS] = 0;
 497:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 498:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[YAXIS] = 0;
 499:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 500:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[ZAXIS] = 0;
 501:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSampleCount = 0;
 502:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 503:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 504:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'm': // Send magnetometer cal values
 505:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef HeadingMagHold
 506:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINT(magBias[XAXIS], 6);
 507:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       comma();
 508:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINT(magBias[YAXIS], 6);
 509:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       comma();
 510:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(magBias[ZAXIS], 6);
 511:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 512:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 513:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 514:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 515:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'n': // battery monitor
 516:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef BattMonitor
 517:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(batteryMonitorAlarmVoltage);
 518:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(batteryMonitorThrottleTarget);
 519:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(batteryMonitorGoingDownTime);
 520:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 521:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(3);
 522:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 523:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 524:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 525:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 526:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 527:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'o': // send waypoints
 528:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef UseGPSNavigator
 529:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       for (byte index = 0; index < MAX_WAYPOINTS; index++) {
 530:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(index);
 531:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(waypoint[index].latitude);
 532:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(waypoint[index].longitude);
 533:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(waypoint[index].altitude);
 534:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 535:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 536:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(4);
 537:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 538:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 539:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 540:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 541:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 542:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'p': // Send Camera values
 543:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef CameraControl
 544:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(cameraMode);
 545:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterPitch);
 546:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterRoll);
 547:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterYaw);
 548:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraPitch);
 549:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraRoll);
 550:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraYaw);
 551:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinPitch);
 552:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinRoll);
 553:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinYaw);
 554:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxPitch);
 555:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxRoll);
 556:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxYaw);
 557:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef CameraTXControl
 558:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(servoTXChannels);
 559:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 560:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 561:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef CameraTXControl
 562:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintDummyValues(14);
 563:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 564:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintDummyValues(13);
 565:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 566:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 567:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 568:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 569:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 570:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 571:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'q': // Send Vehicle State Value
 572:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 573:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 574:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 575:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 576:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'r': // Vehicle attitude
 577:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 578:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 579:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(getHeading());
 580:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 581:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 582:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 's': // Send all flight data
 583:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(motorArmed);
 584:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 585:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 586:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(getHeading());
 587:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 588:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined AltitudeHoldBaro
 589:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(getBaroAltitude());
 590:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #elif defined AltitudeHoldRangeFinder
 591:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] != INVALID_RANGE ? rangeFinde
 592:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 593:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 594:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 595:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 596:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 597:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 598:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 599:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 600:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((channel < LASTCHANNEL) ? receiverCommand[channel] : 0);
 601:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 602:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 603:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 604:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 605:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 606:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintDummyValues(8 - LASTMOTOR); // max of 8 motor outputs supported
 607:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 608:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef BattMonitor
 609:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 610:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 611:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 612:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 613:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(flightMode);
 614:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 615:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 616:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 617:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 't': // Send processed transmitter values
 618:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 619:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 620:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 621:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 622:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 623:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 624:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'u': // Send range finder values
 625:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (AltitudeHoldRangeFinder)
 626:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(maxRangeFinderRange);
 627:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(minRangeFinderRange);
 628:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 629:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 630:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0);
 631:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 632:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 633:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 634:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 635:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'v': // Send GPS PIDs
 636:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (UseGPSNavigator)
 637:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSROLL_PID_IDX);
 638:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSPITCH_PID_IDX);
 639:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSYAW_PID_IDX);
 640:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       queryType = 'X';
 641:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 642:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(9);
 643:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 644:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 645:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 646:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 647:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'y': // send GPS info
 648:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (UseGPS)
 649:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.state);
 650:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.lat);
 651:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.lon);
 652:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.height);
 653:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.course);
 654:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.speed);
 655:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.accuracy);
 656:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.sats);
 657:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.fixtime);
 658:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.sentences);
 659:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.idlecount);
 660:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 661:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(11);
 662:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif    
 663:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 664:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 665:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****  
 666:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'z': // Send all Altitude data 
 667:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (AltitudeHoldBaro) 
 668:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(getBaroAltitude()); 
 669:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 670:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 671:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif 
 672:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (AltitudeHoldRangeFinder) 
 673:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX]);
 674:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 675:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0); 
 676:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif 
 677:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 678:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     
 679:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '$': // send BatteryMonitor voltage/current readings
 680:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (BattMonitor)
 681:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 682:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined (BM_EXTENDED)
 683:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma((float)batteryData[0].current/100.0);
 684:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma((float)batteryData[0].usedCapacity/1000.0);
 685:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 686:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintDummyValues(2);
 687:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 688:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 689:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(3);
 690:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 691:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 692:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 693:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     
 694:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '%': // send RSSI
 695:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (UseAnalogRSSIReader) || defined (UseEzUHFRSSIReader) || defined (UseSBUSRSSIReader
 696:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(rssiRawValue);
 697:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 698:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0);
 699:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 700:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 701:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 702:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'x': // Stop sending messages
 703:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 704:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 705:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '!': // Send flight software version
 706:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 707:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 708:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 709:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 710:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '#': // Send configuration
 711:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     reportVehicleState();
 712:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 713:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 714:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 715:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '6': // Report remote commands
 716:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 717:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 718:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 719:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 720:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 721:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 722:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 723:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #if defined(OSD) && defined(OSD_LOADFONT)
 724:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '&': // fontload
 725:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     if (OFF == motorArmed) {
 726:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       max7456LoadFont();
 727:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 728:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 729:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 730:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #endif
 731:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 732:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 733:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 734:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 735:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readValueSerial(char *data, byte size) {
 7465              		.loc 28 735 0
 7466              		.cfi_startproc
 7467              		@ args = 0, pretend = 0, frame = 0
 7468              		@ frame_needed = 0, uses_anonymous_args = 0
 7469              	.LVL328:
 7470 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 7471              	.LCFI67:
 7472              		.cfi_def_cfa_offset 24
 7473              		.cfi_offset 14, -4
 7474              		.cfi_offset 7, -8
 7475              		.cfi_offset 6, -12
 7476              		.cfi_offset 5, -16
 7477              		.cfi_offset 4, -20
 7478              		.cfi_offset 3, -24
 7479              	.LBB182:
 736:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   byte index = 0;
 737:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   byte timeout = 0;
 738:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   data[0] = '\0';
 7480              		.loc 28 738 0
 7481 0002 0026     		movs	r6, #0
 7482              	.LBE182:
 735:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readValueSerial(char *data, byte size) {
 7483              		.loc 28 735 0
 7484 0004 0446     		mov	r4, r0
 7485 0006 0F46     		mov	r7, r1
 7486              	.LBB183:
 7487              		.loc 28 738 0
 7488 0008 0670     		strb	r6, [r0, #0]
 736:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   byte index = 0;
 7489              		.loc 28 736 0
 7490 000a 3546     		mov	r5, r6
 7491              	.LVL329:
 7492              	.L444:
 739:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 740:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 741:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     if (SERIAL_AVAILABLE() == 0) {
 7493              		.loc 28 741 0
 7494 000c 0F48     		ldr	r0, .L446
 7495 000e FFF7FEFF 		bl	_ZN9USBSerial9availableEv
 7496 0012 28B9     		cbnz	r0, .L440
 742:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       delay(1);
 7497              		.loc 28 742 0
 7498 0014 0120     		movs	r0, #1
 743:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       timeout++;
 7499              		.loc 28 743 0
 7500 0016 0136     		adds	r6, r6, #1
 7501              	.LVL330:
 742:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       delay(1);
 7502              		.loc 28 742 0
 7503 0018 FFF7FEFF 		bl	_Z5delaym
 7504              		.loc 28 743 0
 7505 001c F6B2     		uxtb	r6, r6
 7506              	.LVL331:
 7507 001e 06E0     		b	.L441
 7508              	.L440:
 744:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     } else {
 745:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       data[index] = SERIAL_READ();
 7509              		.loc 28 745 0
 7510 0020 0A48     		ldr	r0, .L446
 7511 0022 FFF7FEFF 		bl	_ZN9USBSerial4readEv
 7512 0026 6055     		strb	r0, [r4, r5]
 7513              	.LVL332:
 746:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       timeout = 0;
 747:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       index++;
 7514              		.loc 28 747 0
 7515 0028 0135     		adds	r5, r5, #1
 7516              	.LVL333:
 7517 002a EDB2     		uxtb	r5, r5
 7518              	.LVL334:
 746:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       timeout = 0;
 7519              		.loc 28 746 0
 7520 002c 0026     		movs	r6, #0
 7521              	.LVL335:
 7522              	.L441:
 740:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 7523              		.loc 28 740 0
 7524 002e 25B1     		cbz	r5, .L442
 740:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 7525              		.loc 28 740 0 is_stmt 0 discriminator 2
 7526 0030 6019     		adds	r0, r4, r5
 7527 0032 10F8013C 		ldrb	r3, [r0, #-1]	@ zero_extendqisi2
 7528 0036 3B2B     		cmp	r3, #59
 7529 0038 04D0     		beq	.L443
 7530              	.L442:
 740:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 7531              		.loc 28 740 0 discriminator 1
 7532 003a 092E     		cmp	r6, #9
 7533 003c 02D8     		bhi	.L443
 740:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 7534              		.loc 28 740 0 discriminator 4
 7535 003e 791E     		subs	r1, r7, #1
 7536 0040 8D42     		cmp	r5, r1
 7537 0042 E3DB     		blt	.L444
 7538              	.L443:
 748:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 749:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   } while ((index == 0 || data[index-1] != ';') && (timeout < 10) && (index < size-1));
 750:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 751:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   data[index] = '\0';
 7539              		.loc 28 751 0 is_stmt 1
 7540 0044 0022     		movs	r2, #0
 7541 0046 6255     		strb	r2, [r4, r5]
 7542              	.LBE183:
 752:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7543              		.loc 28 752 0
 7544 0048 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7545              	.L447:
 7546 004a 00BF     		.align	2
 7547              	.L446:
 7548 004c 00000000 		.word	SerialUSB
 7549              		.cfi_endproc
 7550              	.LFE233:
 7552              		.section	.text._Z15readFloatSerialv,"ax",%progbits
 7553              		.align	1
 7554              		.global	_Z15readFloatSerialv
 7555              		.thumb
 7556              		.thumb_func
 7558              	_Z15readFloatSerialv:
 7559              	.LFB234:
 753:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 754:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 755:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // Used to read floating point values from the serial port
 756:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** float readFloatSerial() {
 7560              		.loc 28 756 0
 7561              		.cfi_startproc
 7562              		@ args = 0, pretend = 0, frame = 16
 7563              		@ frame_needed = 0, uses_anonymous_args = 0
 7564 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 7565              	.LCFI68:
 7566              		.cfi_def_cfa_offset 24
 7567              		.cfi_offset 14, -4
 7568              		.cfi_offset 4, -8
 7569              		.cfi_offset 3, -12
 7570              		.cfi_offset 2, -16
 7571              		.cfi_offset 1, -20
 7572              		.cfi_offset 0, -24
 7573              	.LBB184:
 757:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   char data[15] = "";
 7574              		.loc 28 757 0
 7575 0002 0021     		movs	r1, #0
 7576 0004 0B22     		movs	r2, #11
 7577 0006 01A8     		add	r0, sp, #4
 7578 0008 0091     		str	r1, [sp, #0]
 7579 000a FFF7FEFF 		bl	memset
 758:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 759:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   readValueSerial(data, sizeof(data));
 7580              		.loc 28 759 0
 7581 000e 6846     		mov	r0, sp
 7582 0010 0F21     		movs	r1, #15
 7583 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 760:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   return atof(data);
 7584              		.loc 28 760 0
 7585 0016 6846     		mov	r0, sp
 7586 0018 FFF7FEFF 		bl	atof
 7587 001c FFF7FEFF 		bl	__aeabi_d2f
 7588              	.LBE184:
 761:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7589              		.loc 28 761 0
 7590 0020 05B0     		add	sp, sp, #20
 7591 0022 00BD     		pop	{pc}
 7592              		.cfi_endproc
 7593              	.LFE234:
 7595              		.section	.text._Z16skipSerialValuesh,"ax",%progbits
 7596              		.align	1
 7597              		.global	_Z16skipSerialValuesh
 7598              		.thumb
 7599              		.thumb_func
 7601              	_Z16skipSerialValuesh:
 7602              	.LFB220:
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void skipSerialValues(byte number) {
 7603              		.loc 28 64 0
 7604              		.cfi_startproc
 7605              		@ args = 0, pretend = 0, frame = 0
 7606              		@ frame_needed = 0, uses_anonymous_args = 0
 7607              	.LVL336:
 7608 0000 38B5     		push	{r3, r4, r5, lr}
 7609              	.LCFI69:
 7610              		.cfi_def_cfa_offset 16
 7611              		.cfi_offset 14, -4
 7612              		.cfi_offset 5, -8
 7613              		.cfi_offset 4, -12
 7614              		.cfi_offset 3, -16
  64:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void skipSerialValues(byte number) {
 7615              		.loc 28 64 0
 7616 0002 0546     		mov	r5, r0
 7617              	.LBB185:
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 7618              		.loc 28 65 0
 7619 0004 0024     		movs	r4, #0
 7620 0006 03E0     		b	.L450
 7621              	.LVL337:
 7622              	.L451:
  66:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     readFloatSerial();
 7623              		.loc 28 66 0 discriminator 2
 7624 0008 FFF7FEFF 		bl	_Z15readFloatSerialv
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 7625              		.loc 28 65 0 discriminator 2
 7626 000c 0134     		adds	r4, r4, #1
 7627              	.LVL338:
 7628 000e E4B2     		uxtb	r4, r4
 7629              	.LVL339:
 7630              	.L450:
  65:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 7631              		.loc 28 65 0 is_stmt 0 discriminator 1
 7632 0010 AC42     		cmp	r4, r5
 7633 0012 F9D1     		bne	.L451
 7634              	.LBE185:
  68:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7635              		.loc 28 68 0 is_stmt 1
 7636 0014 38BD     		pop	{r3, r4, r5, pc}
 7637              		.cfi_endproc
 7638              	.LFE220:
 7640              		.section	.text._Z13readSerialPIDh,"ax",%progbits
 7641              		.align	1
 7642              		.global	_Z13readSerialPIDh
 7643              		.thumb
 7644              		.thumb_func
 7646              	_Z13readSerialPIDh:
 7647              	.LFB219:
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 7648              		.loc 28 55 0
 7649              		.cfi_startproc
 7650              		@ args = 0, pretend = 0, frame = 0
 7651              		@ frame_needed = 0, uses_anonymous_args = 0
 7652              	.LVL340:
 7653              	.LBB186:
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 7654              		.loc 28 56 0
 7655 0000 0849     		ldr	r1, .L453
 7656              	.LBE186:
  55:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 7657              		.loc 28 55 0
 7658 0002 10B5     		push	{r4, lr}
 7659              	.LCFI70:
 7660              		.cfi_def_cfa_offset 8
 7661              		.cfi_offset 14, -4
 7662              		.cfi_offset 4, -8
 7663              	.LBB187:
  56:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 7664              		.loc 28 56 0
 7665 0004 1C24     		movs	r4, #28
 7666 0006 04FB0014 		mla	r4, r4, r0, r1
 7667              	.LVL341:
  57:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->P = readFloatSerial();
 7668              		.loc 28 57 0
 7669 000a FFF7FEFF 		bl	_Z15readFloatSerialv
 7670              	.LVL342:
 7671 000e 2060     		str	r0, [r4, #0]	@ float
  58:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->I = readFloatSerial();
 7672              		.loc 28 58 0
 7673 0010 FFF7FEFF 		bl	_Z15readFloatSerialv
 7674 0014 6060     		str	r0, [r4, #4]	@ float
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->D = readFloatSerial();
 7675              		.loc 28 59 0
 7676 0016 FFF7FEFF 		bl	_Z15readFloatSerialv
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->lastError = 0;
 7677              		.loc 28 60 0
 7678 001a 0023     		movs	r3, #0
  59:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->D = readFloatSerial();
 7679              		.loc 28 59 0
 7680 001c A060     		str	r0, [r4, #8]	@ float
  60:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->lastError = 0;
 7681              		.loc 28 60 0
 7682 001e E360     		str	r3, [r4, #12]	@ float
  61:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->integratedError = 0;
 7683              		.loc 28 61 0
 7684 0020 6361     		str	r3, [r4, #20]	@ float
 7685              	.LBE187:
  62:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7686              		.loc 28 62 0
 7687 0022 10BD     		pop	{r4, pc}
 7688              	.L454:
 7689              		.align	2
 7690              	.L453:
 7691 0024 00000000 		.word	.LANCHOR9
 7692              		.cfi_endproc
 7693              	.LFE219:
 7695              		.section	.text._Z24validateCalibrateCommandh,"ax",%progbits
 7696              		.align	1
 7697              		.global	_Z24validateCalibrateCommandh
 7698              		.thumb
 7699              		.thumb_func
 7701              	_Z24validateCalibrateCommandh:
 7702              	.LFB218:
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 7703              		.loc 28 42 0
 7704              		.cfi_startproc
 7705              		@ args = 0, pretend = 0, frame = 0
 7706              		@ frame_needed = 0, uses_anonymous_args = 0
 7707              	.LVL343:
 7708 0000 10B5     		push	{r4, lr}
 7709              	.LCFI71:
 7710              		.cfi_def_cfa_offset 8
 7711              		.cfi_offset 14, -4
 7712              		.cfi_offset 4, -8
  42:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 7713              		.loc 28 42 0
 7714 0002 0446     		mov	r4, r0
  43:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
 7715              		.loc 28 43 0
 7716 0004 FFF7FEFF 		bl	_Z15readFloatSerialv
 7717              	.LVL344:
 7718 0008 DFED0B7A 		flds	s15, .L458
 7719 000c 07EE100A 		fmsr	s14, r0
 7720 0010 B4EE677A 		fcmps	s14, s15
 7721 0014 F1EE10FA 		fmstat
 7722 0018 4FF00000 		mov	r0, #0
 7723 001c 074B     		ldr	r3, .L458+4
 7724 001e 04D1     		bne	.L456
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     motorArmed = OFF;
 7725              		.loc 28 44 0
 7726 0020 074A     		ldr	r2, .L458+8
  45:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     calibrateESC = command;
 7727              		.loc 28 45 0
 7728 0022 1C70     		strb	r4, [r3, #0]
  44:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     motorArmed = OFF;
 7729              		.loc 28 44 0
 7730 0024 1070     		strb	r0, [r2, #0]
  46:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return true;
 7731              		.loc 28 46 0
 7732 0026 0120     		movs	r0, #1
 7733 0028 10BD     		pop	{r4, pc}
 7734              	.L456:
  49:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     calibrateESC = 0;
 7735              		.loc 28 49 0
 7736 002a 1870     		strb	r0, [r3, #0]
  50:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     testCommand = 1000;
 7737              		.loc 28 50 0
 7738 002c 054B     		ldr	r3, .L458+12
 7739 002e 4FF47A71 		mov	r1, #1000
 7740 0032 1960     		str	r1, [r3, #0]
  53:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7741              		.loc 28 53 0
 7742 0034 10BD     		pop	{r4, pc}
 7743              	.L459:
 7744 0036 00BF     		.align	2
 7745              	.L458:
 7746 0038 66E6F642 		.word	1123477094
 7747 003c 00000000 		.word	.LANCHOR79
 7748 0040 00000000 		.word	.LANCHOR94
 7749 0044 00000000 		.word	.LANCHOR80
 7750              		.cfi_endproc
 7751              	.LFE218:
 7753              		.section	.text._Z17readSerialCommandv,"ax",%progbits
 7754              		.align	1
 7755              		.global	_Z17readSerialCommandv
 7756              		.thumb
 7757              		.thumb_func
 7759              	_Z17readSerialCommandv:
 7760              	.LFB221:
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialCommand() {
 7761              		.loc 28 70 0
 7762              		.cfi_startproc
 7763              		@ args = 0, pretend = 0, frame = 0
 7764              		@ frame_needed = 0, uses_anonymous_args = 0
 7765 0000 38B5     		push	{r3, r4, r5, lr}
 7766              	.LCFI72:
 7767              		.cfi_def_cfa_offset 16
 7768              		.cfi_offset 14, -4
 7769              		.cfi_offset 5, -8
 7770              		.cfi_offset 4, -12
 7771              		.cfi_offset 3, -16
 7772              	.LBB188:
  72:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (SERIAL_AVAILABLE()) {
 7773              		.loc 28 72 0
 7774 0002 9C48     		ldr	r0, .L498
 7775 0004 FFF7FEFF 		bl	_ZN9USBSerial9availableEv
 7776 0008 0028     		cmp	r0, #0
 7777 000a 00F0BB81 		beq	.L460
 7778              	.LBB189:
  73:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = SERIAL_READ();
 7779              		.loc 28 73 0
 7780 000e 9948     		ldr	r0, .L498
 7781 0010 FFF7FEFF 		bl	_ZN9USBSerial4readEv
 7782 0014 984B     		ldr	r3, .L498+4
 7783 0016 1870     		strb	r0, [r3, #0]
 7784              	.LBB190:
  74:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     switch (queryType) {
 7785              		.loc 28 74 0
 7786 0018 3138     		subs	r0, r0, #49
 7787 001a 2928     		cmp	r0, #41
 7788 001c 00F2B281 		bhi	.L460
 7789 0020 DFE810F0 		tbh	[pc, r0, lsl #1]
 7790              	.L486:
 7791 0024 6901     		.2byte	(.L462-.L486)/2
 7792 0026 6B01     		.2byte	(.L463-.L486)/2
 7793 0028 7001     		.2byte	(.L464-.L486)/2
 7794 002a 7F01     		.2byte	(.L465-.L486)/2
 7795 002c 8C01     		.2byte	(.L466-.L486)/2
 7796 002e B001     		.2byte	(.L460-.L486)/2
 7797 0030 B001     		.2byte	(.L460-.L486)/2
 7798 0032 B001     		.2byte	(.L460-.L486)/2
 7799 0034 B001     		.2byte	(.L460-.L486)/2
 7800 0036 B001     		.2byte	(.L460-.L486)/2
 7801 0038 B001     		.2byte	(.L460-.L486)/2
 7802 003a B001     		.2byte	(.L460-.L486)/2
 7803 003c B001     		.2byte	(.L460-.L486)/2
 7804 003e B001     		.2byte	(.L460-.L486)/2
 7805 0040 B001     		.2byte	(.L460-.L486)/2
 7806 0042 B001     		.2byte	(.L460-.L486)/2
 7807 0044 3400     		.2byte	(.L467-.L486)/2
 7808 0046 3E00     		.2byte	(.L468-.L486)/2
 7809 0048 4F00     		.2byte	(.L469-.L486)/2
 7810 004a B001     		.2byte	(.L460-.L486)/2
 7811 004c 6000     		.2byte	(.L470-.L486)/2
 7812 004e 6C00     		.2byte	(.L471-.L486)/2
 7813 0050 7A00     		.2byte	(.L472-.L486)/2
 7814 0052 8900     		.2byte	(.L473-.L486)/2
 7815 0054 9B00     		.2byte	(.L474-.L486)/2
 7816 0056 A400     		.2byte	(.L475-.L486)/2
 7817 0058 A800     		.2byte	(.L476-.L486)/2
 7818 005a B800     		.2byte	(.L477-.L486)/2
 7819 005c BE00     		.2byte	(.L479-.L486)/2
 7820 005e BE00     		.2byte	(.L479-.L486)/2
 7821 0060 2A00     		.2byte	(.L480-.L486)/2
 7822 0062 C000     		.2byte	(.L481-.L486)/2
 7823 0064 B001     		.2byte	(.L460-.L486)/2
 7824 0066 B001     		.2byte	(.L460-.L486)/2
 7825 0068 B001     		.2byte	(.L460-.L486)/2
 7826 006a B001     		.2byte	(.L460-.L486)/2
 7827 006c 5C01     		.2byte	(.L482-.L486)/2
 7828 006e 6101     		.2byte	(.L483-.L486)/2
 7829 0070 6301     		.2byte	(.L484-.L486)/2
 7830 0072 B001     		.2byte	(.L460-.L486)/2
 7831 0074 B001     		.2byte	(.L460-.L486)/2
 7832 0076 9F01     		.2byte	(.L485-.L486)/2
 7833              	.L480:
 7834              	.LVL345:
 7835              	.LBB191:
 7836              	.LBB192:
 202:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           readFloatSerial();
 7837              		.loc 28 202 0 discriminator 1
 7838 0078 FFF7FEFF 		bl	_Z15readFloatSerialv
 7839              	.LVL346:
 7840 007c FFF7FEFF 		bl	_Z15readFloatSerialv
 7841              	.LVL347:
 7842 0080 FFF7FEFF 		bl	_Z15readFloatSerialv
 7843              	.LVL348:
 7844              	.LBE192:
 7845              	.LBE191:
 7846              	.LBE190:
 7847              	.LBE189:
 7848              	.LBE188:
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7849              		.loc 28 298 0 discriminator 1
 7850 0084 BDE83840 		pop	{r3, r4, r5, lr}
 7851              	.LBB215:
 7852              	.LBB209:
 7853              	.LBB203:
 7854              	.LBB197:
 7855              	.LBB193:
 202:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           readFloatSerial();
 7856              		.loc 28 202 0 discriminator 1
 7857 0088 FFF7FEBF 		b	_Z15readFloatSerialv
 7858              	.LVL349:
 7859              	.L467:
 7860              	.LBE193:
  76:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
 7861              		.loc 28 76 0
 7862 008c 0020     		movs	r0, #0
 7863 008e FFF7FEFF 		bl	_Z13readSerialPIDh
  77:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
 7864              		.loc 28 77 0
 7865 0092 0120     		movs	r0, #1
 7866 0094 FFF7FEFF 		bl	_Z13readSerialPIDh
  78:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
 7867              		.loc 28 78 0
 7868 0098 FFF7FEFF 		bl	_Z15readFloatSerialv
 7869 009c 774B     		ldr	r3, .L498+8
 7870 009e 0EE0     		b	.L496
 7871              	.L468:
  82:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
 7872              		.loc 28 82 0
 7873 00a0 0320     		movs	r0, #3
 7874 00a2 FFF7FEFF 		bl	_Z13readSerialPIDh
  83:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
 7875              		.loc 28 83 0
 7876 00a6 0420     		movs	r0, #4
 7877 00a8 FFF7FEFF 		bl	_Z13readSerialPIDh
  84:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 7878              		.loc 28 84 0
 7879 00ac 0620     		movs	r0, #6
 7880 00ae FFF7FEFF 		bl	_Z13readSerialPIDh
  85:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 7881              		.loc 28 85 0
 7882 00b2 0720     		movs	r0, #7
 7883 00b4 FFF7FEFF 		bl	_Z13readSerialPIDh
  86:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       windupGuard = readFloatSerial(); // defaults found in setup() of AeroQuad.pde
 7884              		.loc 28 86 0
 7885 00b8 FFF7FEFF 		bl	_Z15readFloatSerialv
 7886 00bc 704B     		ldr	r3, .L498+12
 7887              	.L496:
 7888 00be 1860     		str	r0, [r3, #0]	@ float
  87:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 7889              		.loc 28 87 0
 7890 00c0 38BD     		pop	{r3, r4, r5, pc}
 7891              	.L469:
  90:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
 7892              		.loc 28 90 0
 7893 00c2 0220     		movs	r0, #2
 7894 00c4 FFF7FEFF 		bl	_Z13readSerialPIDh
  91:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
 7895              		.loc 28 91 0
 7896 00c8 0520     		movs	r0, #5
 7897 00ca FFF7FEFF 		bl	_Z13readSerialPIDh
  92:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       headingHoldConfig = readFloatSerial();
 7898              		.loc 28 92 0
 7899 00ce FFF7FEFF 		bl	_Z15readFloatSerialv
 7900 00d2 00EE100A 		fmsr	s0, r0
 7901 00d6 BCEEC07A 		ftouizs	s14, s0
 7902 00da 6A49     		ldr	r1, .L498+16
 7903 00dc 17EE100A 		fmrs	r0, s14	@ int
 7904 00e0 0870     		strb	r0, [r1, #0]
  93:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 7905              		.loc 28 93 0
 7906 00e2 38BD     		pop	{r3, r4, r5, pc}
 7907              	.L470:
 113:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       aref = readFloatSerial();
 7908              		.loc 28 113 0
 7909 00e4 FFF7FEFF 		bl	_Z15readFloatSerialv
 7910 00e8 674A     		ldr	r2, .L498+20
 7911 00ea 1060     		str	r0, [r2, #0]	@ float
 114:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       minArmedThrottle = readFloatSerial();
 7912              		.loc 28 114 0
 7913 00ec FFF7FEFF 		bl	_Z15readFloatSerialv
 7914 00f0 07EE900A 		fmsr	s15, r0
 7915 00f4 654B     		ldr	r3, .L498+24
 7916 00f6 FDEEE77A 		ftosizs	s15, s15
 7917 00fa B7E0     		b	.L497
 7918              	.L471:
 118:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 7919              		.loc 28 118 0
 7920 00fc FFF7FEFF 		bl	_Z15readFloatSerialv
 7921 0100 634C     		ldr	r4, .L498+28
 7922 0102 2060     		str	r0, [r4, #0]	@ float
 7923              	.LVL350:
 7924 0104 634C     		ldr	r4, .L498+32
  70:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialCommand() {
 7925              		.loc 28 70 0
 7926 0106 04F12005 		add	r5, r4, #32
 7927              	.LVL351:
 7928              	.L487:
 7929              	.LBB194:
 120:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 7930              		.loc 28 120 0 discriminator 2
 7931 010a FFF7FEFF 		bl	_Z15readFloatSerialv
 7932 010e 44F8040F 		str	r0, [r4, #4]!	@ float
 119:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 7933              		.loc 28 119 0 discriminator 2
 7934 0112 AC42     		cmp	r4, r5
 7935 0114 F9D1     		bne	.L487
 7936 0116 38BD     		pop	{r3, r4, r5, pc}
 7937              	.L472:
 7938              	.LBE194:
 125:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       channelCal = (int)readFloatSerial();
 7939              		.loc 28 125 0
 7940 0118 FFF7FEFF 		bl	_Z15readFloatSerialv
 7941 011c 01EE100A 		fmsr	s2, r0
 7942 0120 5D4B     		ldr	r3, .L498+36
 7943 0122 FDEEC10A 		ftosizs	s1, s2
 7944 0126 C3ED000A 		fsts	s1, [r3, #0]	@ int
 7945 012a 10EE904A 		fmrs	r4, s1	@ int
 126:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 7946              		.loc 28 126 0
 7947 012e FFF7FEFF 		bl	_Z15readFloatSerialv
 7948 0132 5A4B     		ldr	r3, .L498+40
 7949 0134 0DE0     		b	.L495
 7950              	.L473:
 130:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       channelCal = (int)readFloatSerial();
 7951              		.loc 28 130 0
 7952 0136 FFF7FEFF 		bl	_Z15readFloatSerialv
 7953 013a 02EE100A 		fmsr	s4, r0
 7954 013e 5648     		ldr	r0, .L498+36
 7955 0140 FDEEC21A 		ftosizs	s3, s4
 7956 0144 C0ED001A 		fsts	s3, [r0, #0]	@ int
 7957 0148 11EE904A 		fmrs	r4, s3	@ int
 131:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 7958              		.loc 28 131 0
 7959 014c FFF7FEFF 		bl	_Z15readFloatSerialv
 7960 0150 534B     		ldr	r3, .L498+44
 7961              	.L495:
 7962 0152 03EB8404 		add	r4, r3, r4, lsl #2
 7963 0156 2060     		str	r0, [r4, #0]	@ float
 132:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 7964              		.loc 28 132 0
 7965 0158 38BD     		pop	{r3, r4, r5, pc}
 7966              	.L474:
 135:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 7967              		.loc 28 135 0
 7968 015a FFF7FEFF 		bl	_Z16initializeEEPROMv
 136:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       writeEEPROM();
 7969              		.loc 28 136 0
 7970 015e FFF7FEFF 		bl	_Z11writeEEPROMv
 137:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 7971              		.loc 28 137 0
 7972 0162 FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 138:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       calibrateGyro();
 7973              		.loc 28 138 0
 7974 0166 FFF7FEFF 		bl	_Z13calibrateGyrov
 7975 016a C0E0     		b	.L492
 7976              	.L475:
 7977              	.LBE197:
 7978              	.LBE203:
 7979              	.LBE209:
 7980              	.LBE215:
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 7981              		.loc 28 298 0
 7982 016c BDE83840 		pop	{r3, r4, r5, lr}
 7983              	.LBB216:
 7984              	.LBB210:
 7985              	.LBB204:
 7986              	.LBB198:
 149:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       calibrateGyro();
 7987              		.loc 28 149 0
 7988 0170 FFF7FEBF 		b	_Z13calibrateGyrov
 7989              	.L476:
 153:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 7990              		.loc 28 153 0
 7991 0174 FFF7FEFF 		bl	_Z15readFloatSerialv
 7992 0178 4A4C     		ldr	r4, .L498+48
 7993 017a 2060     		str	r0, [r4, #0]	@ float
 154:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 7994              		.loc 28 154 0
 7995 017c FFF7FEFF 		bl	_Z15readFloatSerialv
 155:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 7996              		.loc 28 155 0
 7997 0180 FFF7FEFF 		bl	_Z15readFloatSerialv
 7998 0184 6060     		str	r0, [r4, #4]	@ float
 156:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 7999              		.loc 28 156 0
 8000 0186 FFF7FEFF 		bl	_Z15readFloatSerialv
 157:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 8001              		.loc 28 157 0
 8002 018a FFF7FEFF 		bl	_Z15readFloatSerialv
 8003 018e A060     		str	r0, [r4, #8]	@ float
 158:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 8004              		.loc 28 158 0
 8005 0190 FFF7FEFF 		bl	_Z15readFloatSerialv
 8006              	.L477:
 164:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       computeAccelBias();
 8007              		.loc 28 164 0
 8008 0194 FFF7FEFF 		bl	_Z16computeAccelBiasv
 8009              	.LBE198:
 8010              	.LBE204:
 8011              	.LBE210:
 8012              	.LBE216:
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8013              		.loc 28 298 0
 8014 0198 BDE83840 		pop	{r3, r4, r5, lr}
 8015              	.LBB217:
 8016              	.LBB211:
 8017              	.LBB205:
 8018              	.LBB199:
 169:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 8019              		.loc 28 169 0
 8020 019c FFF7FEBF 		b	_Z24storeSensorsZeroToEEPROMv
 8021              	.L479:
 190:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(3);
 8022              		.loc 28 190 0
 8023 01a0 0320     		movs	r0, #3
 8024 01a2 9CE0     		b	.L493
 8025              	.L481:
 208:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         cameraMode = readFloatSerial();
 8026              		.loc 28 208 0
 8027 01a4 FFF7FEFF 		bl	_Z15readFloatSerialv
 8028 01a8 03EE900A 		fmsr	s7, r0
 8029 01ac 3E49     		ldr	r1, .L498+52
 8030 01ae BDEEE33A 		ftosizs	s6, s7
 8031 01b2 81ED003A 		fsts	s6, [r1, #0]	@ int
 209:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterPitch = readFloatSerial();
 8032              		.loc 28 209 0
 8033 01b6 FFF7FEFF 		bl	_Z15readFloatSerialv
 8034 01ba 02EE900A 		fmsr	s5, r0
 8035 01be 3B4B     		ldr	r3, .L498+56
 8036 01c0 BDEEE22A 		ftosizs	s4, s5
 8037 01c4 83ED002A 		fsts	s4, [r3, #0]	@ int
 210:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterRoll = readFloatSerial();
 8038              		.loc 28 210 0
 8039 01c8 FFF7FEFF 		bl	_Z15readFloatSerialv
 8040 01cc 01EE900A 		fmsr	s3, r0
 8041 01d0 374A     		ldr	r2, .L498+60
 8042 01d2 BDEEE11A 		ftosizs	s2, s3
 8043 01d6 82ED001A 		fsts	s2, [r2, #0]	@ int
 211:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterYaw = readFloatSerial();
 8044              		.loc 28 211 0
 8045 01da FFF7FEFF 		bl	_Z15readFloatSerialv
 8046 01de 00EE900A 		fmsr	s1, r0
 8047 01e2 3448     		ldr	r0, .L498+64
 8048 01e4 FDEEE07A 		ftosizs	s15, s1
 8049 01e8 C0ED007A 		fsts	s15, [r0, #0]	@ int
 212:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraPitch = readFloatSerial();
 8050              		.loc 28 212 0
 8051 01ec FFF7FEFF 		bl	_Z15readFloatSerialv
 8052 01f0 3149     		ldr	r1, .L498+68
 8053 01f2 0860     		str	r0, [r1, #0]	@ float
 213:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraRoll = readFloatSerial();
 8054              		.loc 28 213 0
 8055 01f4 FFF7FEFF 		bl	_Z15readFloatSerialv
 8056 01f8 304B     		ldr	r3, .L498+72
 8057 01fa 1860     		str	r0, [r3, #0]	@ float
 214:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraYaw = readFloatSerial();
 8058              		.loc 28 214 0
 8059 01fc FFF7FEFF 		bl	_Z15readFloatSerialv
 8060 0200 2F4A     		ldr	r2, .L498+76
 8061 0202 1060     		str	r0, [r2, #0]	@ float
 215:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinPitch = readFloatSerial();
 8062              		.loc 28 215 0
 8063 0204 FFF7FEFF 		bl	_Z15readFloatSerialv
 8064 0208 00EE100A 		fmsr	s0, r0
 8065 020c 2D49     		ldr	r1, .L498+80
 8066 020e BDEEC07A 		ftosizs	s14, s0
 8067 0212 81ED007A 		fsts	s14, [r1, #0]	@ int
 216:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinRoll = readFloatSerial();
 8068              		.loc 28 216 0
 8069 0216 FFF7FEFF 		bl	_Z15readFloatSerialv
 8070 021a 06EE900A 		fmsr	s13, r0
 8071 021e 2A48     		ldr	r0, .L498+84
 8072 0220 BDEEE66A 		ftosizs	s12, s13
 8073 0224 80ED006A 		fsts	s12, [r0, #0]	@ int
 217:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinYaw = readFloatSerial();
 8074              		.loc 28 217 0
 8075 0228 FFF7FEFF 		bl	_Z15readFloatSerialv
 8076 022c 05EE900A 		fmsr	s11, r0
 8077 0230 264B     		ldr	r3, .L498+88
 8078 0232 BDEEE55A 		ftosizs	s10, s11
 8079 0236 83ED005A 		fsts	s10, [r3, #0]	@ int
 218:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxPitch = readFloatSerial();
 8080              		.loc 28 218 0
 8081 023a FFF7FEFF 		bl	_Z15readFloatSerialv
 8082 023e 04EE900A 		fmsr	s9, r0
 8083 0242 234A     		ldr	r2, .L498+92
 8084 0244 BDEEE44A 		ftosizs	s8, s9
 8085 0248 82ED004A 		fsts	s8, [r2, #0]	@ int
 219:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxRoll = readFloatSerial();
 8086              		.loc 28 219 0
 8087 024c FFF7FEFF 		bl	_Z15readFloatSerialv
 8088 0250 03EE900A 		fmsr	s7, r0
 8089 0254 1F49     		ldr	r1, .L498+96
 8090 0256 BDEEE33A 		ftosizs	s6, s7
 8091 025a 81ED003A 		fsts	s6, [r1, #0]	@ int
 220:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxYaw = readFloatSerial();
 8092              		.loc 28 220 0
 8093 025e FFF7FEFF 		bl	_Z15readFloatSerialv
 8094 0262 02EE900A 		fmsr	s5, r0
 8095 0266 1C4B     		ldr	r3, .L498+100
 8096 0268 FDEEE27A 		ftosizs	s15, s5
 8097              	.L497:
 8098 026c C3ED007A 		fsts	s15, [r3, #0]	@ int
 231:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 8099              		.loc 28 231 0
 8100 0270 38BD     		pop	{r3, r4, r5, pc}
 8101              	.L499:
 8102 0272 00BF     		.align	2
 8103              	.L498:
 8104 0274 00000000 		.word	SerialUSB
 8105 0278 00000000 		.word	.LANCHOR98
 8106 027c 00000000 		.word	.LANCHOR78
 8107 0280 00000000 		.word	.LANCHOR95
 8108 0284 00000000 		.word	.LANCHOR86
 8109 0288 00000000 		.word	.LANCHOR96
 8110 028c 00000000 		.word	.LANCHOR83
 8111 0290 00000000 		.word	.LANCHOR55
 8112 0294 FCFFFFFF 		.word	.LANCHOR6-4
 8113 0298 00000000 		.word	.LANCHOR99
 8114 029c 00000000 		.word	.LANCHOR4
 8115 02a0 00000000 		.word	.LANCHOR5
 8116 02a4 00000000 		.word	.LANCHOR27
 8117 02a8 00000000 		.word	.LANCHOR60
 8118 02ac 00000000 		.word	.LANCHOR62
 8119 02b0 00000000 		.word	.LANCHOR66
 8120 02b4 00000000 		.word	.LANCHOR70
 8121 02b8 00000000 		.word	.LANCHOR61
 8122 02bc 00000000 		.word	.LANCHOR65
 8123 02c0 00000000 		.word	.LANCHOR69
 8124 02c4 00000000 		.word	.LANCHOR63
 8125 02c8 00000000 		.word	.LANCHOR67
 8126 02cc 00000000 		.word	.LANCHOR71
 8127 02d0 00000000 		.word	.LANCHOR64
 8128 02d4 00000000 		.word	.LANCHOR68
 8129 02d8 00000000 		.word	.LANCHOR72
 8130              	.L482:
 238:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(2);
 8131              		.loc 28 238 0
 8132 02dc 0220     		movs	r0, #2
 8133              	.L493:
 8134              	.LBE199:
 8135              	.LBE205:
 8136              	.LBE211:
 8137              	.LBE217:
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8138              		.loc 28 298 0
 8139 02de BDE83840 		pop	{r3, r4, r5, lr}
 8140              	.LBB218:
 8141              	.LBB212:
 8142              	.LBB206:
 8143              	.LBB200:
 238:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(2);
 8144              		.loc 28 238 0
 8145 02e2 FFF7FEBF 		b	_Z16skipSerialValuesh
 8146              	.L483:
 249:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(9);
 8147              		.loc 28 249 0
 8148 02e6 0920     		movs	r0, #9
 8149 02e8 F9E7     		b	.L493
 8150              	.L484:
 254:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 8151              		.loc 28 254 0
 8152 02ea FFF7FEFF 		bl	_Z11writeEEPROMv
 8153              	.L492:
 8154              	.LBE200:
 8155              	.LBE206:
 8156              	.LBE212:
 8157              	.LBE218:
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8158              		.loc 28 298 0
 8159 02ee BDE83840 		pop	{r3, r4, r5, lr}
 8160              	.LBB219:
 8161              	.LBB213:
 8162              	.LBB207:
 8163              	.LBB201:
 255:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       zeroIntegralError();
 8164              		.loc 28 255 0
 8165 02f2 FFF7FEBF 		b	_Z17zeroIntegralErrorv
 8166              	.L462:
 262:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(1);
 8167              		.loc 28 262 0
 8168 02f6 0120     		movs	r0, #1
 8169 02f8 00E0     		b	.L494
 8170              	.L463:
 266:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(2);
 8171              		.loc 28 266 0
 8172 02fa 0220     		movs	r0, #2
 8173              	.L494:
 8174              	.LBE201:
 8175              	.LBE207:
 8176              	.LBE213:
 8177              	.LBE219:
 298:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8178              		.loc 28 298 0
 8179 02fc BDE83840 		pop	{r3, r4, r5, lr}
 8180              	.LBB220:
 8181              	.LBB214:
 8182              	.LBB208:
 8183              	.LBB202:
 266:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(2);
 8184              		.loc 28 266 0
 8185 0300 FFF7FEBF 		b	_Z24validateCalibrateCommandh
 8186              	.L464:
 270:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(3)) {
 8187              		.loc 28 270 0
 8188 0304 0320     		movs	r0, #3
 8189 0306 FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 8190 030a 0028     		cmp	r0, #0
 8191 030c 3AD0     		beq	.L460
 271:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = readFloatSerial();
 8192              		.loc 28 271 0
 8193 030e FFF7FEFF 		bl	_Z15readFloatSerialv
 8194 0312 04EE900A 		fmsr	s9, r0
 8195 0316 1C48     		ldr	r0, .L500
 8196 0318 BDEEE44A 		ftosizs	s8, s9
 8197 031c 80ED004A 		fsts	s8, [r0, #0]	@ int
 8198 0320 38BD     		pop	{r3, r4, r5, pc}
 8199              	.L465:
 276:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(4)) {
 8200              		.loc 28 276 0
 8201 0322 0420     		movs	r0, #4
 8202 0324 FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 8203 0328 0028     		cmp	r0, #0
 8204 032a 2BD0     		beq	.L460
 277:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateESC = 0;
 8205              		.loc 28 277 0
 8206 032c 1748     		ldr	r0, .L500+4
 278:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = 1000;
 8207              		.loc 28 278 0
 8208 032e 164B     		ldr	r3, .L500
 277:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateESC = 0;
 8209              		.loc 28 277 0
 8210 0330 0021     		movs	r1, #0
 278:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = 1000;
 8211              		.loc 28 278 0
 8212 0332 4FF47A72 		mov	r2, #1000
 277:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateESC = 0;
 8213              		.loc 28 277 0
 8214 0336 0170     		strb	r1, [r0, #0]
 278:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = 1000;
 8215              		.loc 28 278 0
 8216 0338 1A60     		str	r2, [r3, #0]
 8217 033a 38BD     		pop	{r3, r4, r5, pc}
 8218              	.L466:
 8219              	.LBB195:
 283:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(5)) {
 8220              		.loc 28 283 0
 8221 033c 0520     		movs	r0, #5
 8222 033e FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 8223 0342 F8B1     		cbz	r0, .L460
 8224 0344 0024     		movs	r4, #0
 8225              	.L488:
 8226              	.LBB196:
 285:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 8227              		.loc 28 285 0 discriminator 2
 8228 0346 FFF7FEFF 		bl	_Z15readFloatSerialv
 8229 034a 05EE900A 		fmsr	s11, r0
 8230 034e BDEEE55A 		ftosizs	s10, s11
 8231 0352 0F4B     		ldr	r3, .L500+8
 8232 0354 15EE102A 		fmrs	r2, s10	@ int
 8233 0358 E250     		str	r2, [r4, r3]
 8234 035a 0434     		adds	r4, r4, #4
 284:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++) {
 8235              		.loc 28 284 0 discriminator 2
 8236 035c 102C     		cmp	r4, #16
 8237 035e F2D1     		bne	.L488
 8238 0360 38BD     		pop	{r3, r4, r5, pc}
 8239              	.LVL352:
 8240              	.L485:
 8241              	.LBE196:
 8242              	.LBE195:
 291:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (readFloatSerial() == 1.0)
 8243              		.loc 28 291 0
 8244 0362 FFF7FEFF 		bl	_Z15readFloatSerialv
 8245 0366 06EE100A 		fmsr	s12, r0
 8246 036a F7EE006A 		fconsts	s13, #112
 8247 036e B4EE666A 		fcmps	s12, s13
 8248 0372 F1EE10FA 		fmstat
 8249 0376 074B     		ldr	r3, .L500+12
 8250 0378 02D1     		bne	.L489
 292:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         fastTransfer = ON;
 8251              		.loc 28 292 0
 8252 037a 0121     		movs	r1, #1
 8253 037c 1970     		strb	r1, [r3, #0]
 8254 037e 38BD     		pop	{r3, r4, r5, pc}
 8255              	.L489:
 294:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         fastTransfer = OFF;
 8256              		.loc 28 294 0
 8257 0380 0020     		movs	r0, #0
 8258 0382 1870     		strb	r0, [r3, #0]
 8259              	.L460:
 8260 0384 38BD     		pop	{r3, r4, r5, pc}
 8261              	.L501:
 8262 0386 00BF     		.align	2
 8263              	.L500:
 8264 0388 00000000 		.word	.LANCHOR80
 8265 038c 00000000 		.word	.LANCHOR79
 8266 0390 00000000 		.word	.LANCHOR81
 8267 0394 00000000 		.word	.LANCHOR100
 8268              	.LBE202:
 8269              	.LBE208:
 8270              	.LBE214:
 8271              	.LBE220:
 8272              		.cfi_endproc
 8273              	.LFE221:
 8275              		.section	.text._Z17readIntegerSerialv,"ax",%progbits
 8276              		.align	1
 8277              		.global	_Z17readIntegerSerialv
 8278              		.thumb
 8279              		.thumb_func
 8281              	_Z17readIntegerSerialv:
 8282              	.LFB235:
 762:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 763:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // Used to read integer values from the serial port
 764:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** long readIntegerSerial() {
 8283              		.loc 28 764 0
 8284              		.cfi_startproc
 8285              		@ args = 0, pretend = 0, frame = 16
 8286              		@ frame_needed = 0, uses_anonymous_args = 0
 8287 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 8288              	.LCFI73:
 8289              		.cfi_def_cfa_offset 24
 8290              		.cfi_offset 14, -4
 8291              		.cfi_offset 4, -8
 8292              		.cfi_offset 3, -12
 8293              		.cfi_offset 2, -16
 8294              		.cfi_offset 1, -20
 8295              		.cfi_offset 0, -24
 8296              	.LBB221:
 765:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   char data[16] = "";
 8297              		.loc 28 765 0
 8298 0002 0021     		movs	r1, #0
 8299 0004 0C22     		movs	r2, #12
 8300 0006 01A8     		add	r0, sp, #4
 8301 0008 0091     		str	r1, [sp, #0]
 8302 000a FFF7FEFF 		bl	memset
 766:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 767:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   readValueSerial(data, sizeof(data));
 8303              		.loc 28 767 0
 8304 000e 6846     		mov	r0, sp
 8305 0010 1021     		movs	r1, #16
 8306 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 768:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   return atol(data);
 8307              		.loc 28 768 0
 8308 0016 6846     		mov	r0, sp
 8309 0018 FFF7FEFF 		bl	atol
 8310              	.LBE221:
 769:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8311              		.loc 28 769 0
 8312 001c 05B0     		add	sp, sp, #20
 8313 001e 00BD     		pop	{pc}
 8314              		.cfi_endproc
 8315              	.LFE235:
 8317              		.section	.text._Z5commav,"ax",%progbits
 8318              		.align	1
 8319              		.global	_Z5commav
 8320              		.thumb
 8321              		.thumb_func
 8323              	_Z5commav:
 8324              	.LFB236:
 770:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 771:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void comma() {
 8325              		.loc 28 771 0
 8326              		.cfi_startproc
 8327              		@ args = 0, pretend = 0, frame = 0
 8328              		@ frame_needed = 0, uses_anonymous_args = 0
 8329              		@ link register save eliminated.
 772:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(',');
 8330              		.loc 28 772 0
 8331 0000 0148     		ldr	r0, .L504
 8332 0002 2C21     		movs	r1, #44
 773:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8333              		.loc 28 773 0
 772:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(',');
 8334              		.loc 28 772 0
 8335 0004 FFF7FEBF 		b	_ZN5Print5printEc
 8336              	.L505:
 8337              		.align	2
 8338              	.L504:
 8339 0008 00000000 		.word	SerialUSB
 8340              		.cfi_endproc
 8341              	.LFE236:
 8343              		.section	.text._Z15PrintValueCommal,"ax",%progbits
 8344              		.align	1
 8345              		.global	_Z15PrintValueCommal
 8346              		.thumb
 8347              		.thumb_func
 8349              	_Z15PrintValueCommal:
 8350              	.LFB228:
 337:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 8351              		.loc 28 337 0
 8352              		.cfi_startproc
 8353              		@ args = 0, pretend = 0, frame = 0
 8354              		@ frame_needed = 0, uses_anonymous_args = 0
 8355              	.LVL353:
 8356 0000 08B5     		push	{r3, lr}
 8357              	.LCFI74:
 8358              		.cfi_def_cfa_offset 8
 8359              		.cfi_offset 14, -4
 8360              		.cfi_offset 3, -8
 337:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 8361              		.loc 28 337 0
 8362 0002 0146     		mov	r1, r0
 338:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 8363              		.loc 28 338 0
 8364 0004 0A22     		movs	r2, #10
 8365 0006 0348     		ldr	r0, .L507
 8366              	.LVL354:
 8367 0008 FFF7FEFF 		bl	_ZN5Print5printEli
 8368              	.LVL355:
 340:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8369              		.loc 28 340 0
 8370 000c BDE80840 		pop	{r3, lr}
 339:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 8371              		.loc 28 339 0
 8372 0010 FFF7FEBF 		b	_Z5commav
 8373              	.L508:
 8374              		.align	2
 8375              	.L507:
 8376 0014 00000000 		.word	SerialUSB
 8377              		.cfi_endproc
 8378              	.LFE228:
 8380              		.section	.text._Z15PrintValueCommah,"ax",%progbits
 8381              		.align	1
 8382              		.global	_Z15PrintValueCommah
 8383              		.thumb
 8384              		.thumb_func
 8386              	_Z15PrintValueCommah:
 8387              	.LFB227:
 331:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 8388              		.loc 28 331 0
 8389              		.cfi_startproc
 8390              		@ args = 0, pretend = 0, frame = 0
 8391              		@ frame_needed = 0, uses_anonymous_args = 0
 8392              	.LVL356:
 8393 0000 08B5     		push	{r3, lr}
 8394              	.LCFI75:
 8395              		.cfi_def_cfa_offset 8
 8396              		.cfi_offset 14, -4
 8397              		.cfi_offset 3, -8
 331:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 8398              		.loc 28 331 0
 8399 0002 0146     		mov	r1, r0
 332:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 8400              		.loc 28 332 0
 8401 0004 0A22     		movs	r2, #10
 8402 0006 0348     		ldr	r0, .L510
 8403              	.LVL357:
 8404 0008 FFF7FEFF 		bl	_ZN5Print5printEhi
 334:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8405              		.loc 28 334 0
 8406 000c BDE80840 		pop	{r3, lr}
 333:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 8407              		.loc 28 333 0
 8408 0010 FFF7FEBF 		b	_Z5commav
 8409              	.L511:
 8410              		.align	2
 8411              	.L510:
 8412 0014 00000000 		.word	SerialUSB
 8413              		.cfi_endproc
 8414              	.LFE227:
 8416              		.section	.text._Z15PrintValueCommam,"ax",%progbits
 8417              		.align	1
 8418              		.global	_Z15PrintValueCommam
 8419              		.thumb
 8420              		.thumb_func
 8422              	_Z15PrintValueCommam:
 8423              	.LFB226:
 325:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 8424              		.loc 28 325 0
 8425              		.cfi_startproc
 8426              		@ args = 0, pretend = 0, frame = 0
 8427              		@ frame_needed = 0, uses_anonymous_args = 0
 8428              	.LVL358:
 8429 0000 08B5     		push	{r3, lr}
 8430              	.LCFI76:
 8431              		.cfi_def_cfa_offset 8
 8432              		.cfi_offset 14, -4
 8433              		.cfi_offset 3, -8
 325:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 8434              		.loc 28 325 0
 8435 0002 0146     		mov	r1, r0
 326:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 8436              		.loc 28 326 0
 8437 0004 0A22     		movs	r2, #10
 8438 0006 0348     		ldr	r0, .L513
 8439              	.LVL359:
 8440 0008 FFF7FEFF 		bl	_ZN5Print5printEmi
 8441              	.LVL360:
 328:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8442              		.loc 28 328 0
 8443 000c BDE80840 		pop	{r3, lr}
 327:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 8444              		.loc 28 327 0
 8445 0010 FFF7FEBF 		b	_Z5commav
 8446              	.L514:
 8447              		.align	2
 8448              	.L513:
 8449 0014 00000000 		.word	SerialUSB
 8450              		.cfi_endproc
 8451              	.LFE226:
 8453              		.section	.text._Z15PrintValueCommai,"ax",%progbits
 8454              		.align	1
 8455              		.global	_Z15PrintValueCommai
 8456              		.thumb
 8457              		.thumb_func
 8459              	_Z15PrintValueCommai:
 8460              	.LFB225:
 319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(int val) {
 8461              		.loc 28 319 0
 8462              		.cfi_startproc
 8463              		@ args = 0, pretend = 0, frame = 0
 8464              		@ frame_needed = 0, uses_anonymous_args = 0
 8465              	.LVL361:
 8466 0000 08B5     		push	{r3, lr}
 8467              	.LCFI77:
 8468              		.cfi_def_cfa_offset 8
 8469              		.cfi_offset 14, -4
 8470              		.cfi_offset 3, -8
 319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(int val) {
 8471              		.loc 28 319 0
 8472 0002 0146     		mov	r1, r0
 320:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 8473              		.loc 28 320 0
 8474 0004 0A22     		movs	r2, #10
 8475 0006 0348     		ldr	r0, .L516
 8476              	.LVL362:
 8477 0008 FFF7FEFF 		bl	_ZN5Print5printEii
 8478              	.LVL363:
 322:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8479              		.loc 28 322 0
 8480 000c BDE80840 		pop	{r3, lr}
 321:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 8481              		.loc 28 321 0
 8482 0010 FFF7FEBF 		b	_Z5commav
 8483              	.L517:
 8484              		.align	2
 8485              	.L516:
 8486 0014 00000000 		.word	SerialUSB
 8487              		.cfi_endproc
 8488              	.LFE225:
 8490              		.section	.text._Z16PrintDummyValuesh,"ax",%progbits
 8491              		.align	1
 8492              		.global	_Z16PrintDummyValuesh
 8493              		.thumb
 8494              		.thumb_func
 8496              	_Z16PrintDummyValuesh:
 8497              	.LFB230:
 349:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintDummyValues(byte number) {
 8498              		.loc 28 349 0
 8499              		.cfi_startproc
 8500              		@ args = 0, pretend = 0, frame = 0
 8501              		@ frame_needed = 0, uses_anonymous_args = 0
 8502              	.LVL364:
 8503 0000 38B5     		push	{r3, r4, r5, lr}
 8504              	.LCFI78:
 8505              		.cfi_def_cfa_offset 16
 8506              		.cfi_offset 14, -4
 8507              		.cfi_offset 5, -8
 8508              		.cfi_offset 4, -12
 8509              		.cfi_offset 3, -16
 349:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintDummyValues(byte number) {
 8510              		.loc 28 349 0
 8511 0002 0546     		mov	r5, r0
 8512              	.LBB222:
 350:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 8513              		.loc 28 350 0
 8514 0004 0024     		movs	r4, #0
 8515 0006 04E0     		b	.L519
 8516              	.LVL365:
 8517              	.L520:
 351:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(0);
 8518              		.loc 28 351 0 discriminator 2
 8519 0008 0020     		movs	r0, #0
 8520 000a FFF7FEFF 		bl	_Z15PrintValueCommai
 350:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 8521              		.loc 28 350 0 discriminator 2
 8522 000e 0134     		adds	r4, r4, #1
 8523              	.LVL366:
 8524 0010 E4B2     		uxtb	r4, r4
 8525              	.LVL367:
 8526              	.L519:
 350:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 8527              		.loc 28 350 0 is_stmt 0 discriminator 1
 8528 0012 AC42     		cmp	r4, r5
 8529 0014 F8D1     		bne	.L520
 8530              	.LBE222:
 353:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8531              		.loc 28 353 0 is_stmt 1
 8532 0016 38BD     		pop	{r3, r4, r5, pc}
 8533              		.cfi_endproc
 8534              	.LFE230:
 8536              		.section	.text._Z15PrintValueCommac,"ax",%progbits
 8537              		.align	1
 8538              		.global	_Z15PrintValueCommac
 8539              		.thumb
 8540              		.thumb_func
 8542              	_Z15PrintValueCommac:
 8543              	.LFB224:
 314:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(char val) {
 8544              		.loc 28 314 0
 8545              		.cfi_startproc
 8546              		@ args = 0, pretend = 0, frame = 0
 8547              		@ frame_needed = 0, uses_anonymous_args = 0
 8548              	.LVL368:
 8549 0000 08B5     		push	{r3, lr}
 8550              	.LCFI79:
 8551              		.cfi_def_cfa_offset 8
 8552              		.cfi_offset 14, -4
 8553              		.cfi_offset 3, -8
 314:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(char val) {
 8554              		.loc 28 314 0
 8555 0002 0146     		mov	r1, r0
 315:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 8556              		.loc 28 315 0
 8557 0004 0348     		ldr	r0, .L522
 8558              	.LVL369:
 8559 0006 FFF7FEFF 		bl	_ZN5Print5printEc
 317:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8560              		.loc 28 317 0
 8561 000a BDE80840 		pop	{r3, lr}
 316:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 8562              		.loc 28 316 0
 8563 000e FFF7FEBF 		b	_Z5commav
 8564              	.L523:
 8565 0012 00BF     		.align	2
 8566              	.L522:
 8567 0014 00000000 		.word	SerialUSB
 8568              		.cfi_endproc
 8569              	.LFE224:
 8571              		.section	.text._Z15PrintValueCommad,"ax",%progbits
 8572              		.align	1
 8573              		.global	_Z15PrintValueCommad
 8574              		.thumb
 8575              		.thumb_func
 8577              	_Z15PrintValueCommad:
 8578              	.LFB223:
 309:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(double val) {
 8579              		.loc 28 309 0
 8580              		.cfi_startproc
 8581              		@ args = 0, pretend = 0, frame = 0
 8582              		@ frame_needed = 0, uses_anonymous_args = 0
 8583              	.LVL370:
 8584 0000 07B5     		push	{r0, r1, r2, lr}
 8585              	.LCFI80:
 8586              		.cfi_def_cfa_offset 16
 8587              		.cfi_offset 14, -4
 8588              		.cfi_offset 2, -8
 8589              		.cfi_offset 1, -12
 8590              		.cfi_offset 0, -16
 309:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(double val) {
 8591              		.loc 28 309 0
 8592 0002 0B46     		mov	r3, r1
 8593 0004 0246     		mov	r2, r0
 310:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 8594              		.loc 28 310 0
 8595 0006 0221     		movs	r1, #2
 8596 0008 0448     		ldr	r0, .L525
 8597              	.LVL371:
 8598 000a 0091     		str	r1, [sp, #0]
 8599 000c FFF7FEFF 		bl	_ZN5Print5printEdi
 312:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8600              		.loc 28 312 0
 8601 0010 03B0     		add	sp, sp, #12
 8602 0012 5DF804EB 		pop	{lr}
 311:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 8603              		.loc 28 311 0
 8604 0016 FFF7FEBF 		b	_Z5commav
 8605              	.L526:
 8606 001a 00BF     		.align	2
 8607              	.L525:
 8608 001c 00000000 		.word	SerialUSB
 8609              		.cfi_endproc
 8610              	.LFE223:
 8612              		.section	.text._Z15PrintValueCommaf,"ax",%progbits
 8613              		.align	1
 8614              		.global	_Z15PrintValueCommaf
 8615              		.thumb
 8616              		.thumb_func
 8618              	_Z15PrintValueCommaf:
 8619              	.LFB222:
 304:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(float val) {
 8620              		.loc 28 304 0
 8621              		.cfi_startproc
 8622              		@ args = 0, pretend = 0, frame = 0
 8623              		@ frame_needed = 0, uses_anonymous_args = 0
 8624              	.LVL372:
 8625 0000 07B5     		push	{r0, r1, r2, lr}
 8626              	.LCFI81:
 8627              		.cfi_def_cfa_offset 16
 8628              		.cfi_offset 14, -4
 8629              		.cfi_offset 2, -8
 8630              		.cfi_offset 1, -12
 8631              		.cfi_offset 0, -16
 305:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 8632              		.loc 28 305 0
 8633 0002 FFF7FEFF 		bl	__aeabi_f2d
 8634              	.LVL373:
 8635 0006 0246     		mov	r2, r0
 8636 0008 0B46     		mov	r3, r1
 8637 000a 0548     		ldr	r0, .L528
 8638 000c 0221     		movs	r1, #2
 8639 000e 0091     		str	r1, [sp, #0]
 8640 0010 FFF7FEFF 		bl	_ZN5Print5printEdi
 307:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8641              		.loc 28 307 0
 8642 0014 03B0     		add	sp, sp, #12
 8643 0016 5DF804EB 		pop	{lr}
 306:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 8644              		.loc 28 306 0
 8645 001a FFF7FEBF 		b	_Z5commav
 8646              	.L529:
 8647 001e 00BF     		.align	2
 8648              	.L528:
 8649 0020 00000000 		.word	SerialUSB
 8650              		.cfi_endproc
 8651              	.LFE222:
 8653              		.section	.text._Z8PrintPIDh,"ax",%progbits
 8654              		.align	1
 8655              		.global	_Z8PrintPIDh
 8656              		.thumb
 8657              		.thumb_func
 8659              	_Z8PrintPIDh:
 8660              	.LFB229:
 343:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 8661              		.loc 28 343 0
 8662              		.cfi_startproc
 8663              		@ args = 0, pretend = 0, frame = 0
 8664              		@ frame_needed = 0, uses_anonymous_args = 0
 8665              	.LVL374:
 344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 8666              		.loc 28 344 0
 8667 0000 074B     		ldr	r3, .L531
 343:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 8668              		.loc 28 343 0
 8669 0002 10B5     		push	{r4, lr}
 8670              	.LCFI82:
 8671              		.cfi_def_cfa_offset 8
 8672              		.cfi_offset 14, -4
 8673              		.cfi_offset 4, -8
 344:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 8674              		.loc 28 344 0
 8675 0004 1C24     		movs	r4, #28
 8676 0006 04FB0034 		mla	r4, r4, r0, r3
 8677 000a 2068     		ldr	r0, [r4, #0]	@ float
 8678              	.LVL375:
 8679 000c FFF7FEFF 		bl	_Z15PrintValueCommaf
 345:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 8680              		.loc 28 345 0
 8681 0010 6068     		ldr	r0, [r4, #4]	@ float
 8682 0012 FFF7FEFF 		bl	_Z15PrintValueCommaf
 346:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 8683              		.loc 28 346 0
 8684 0016 A068     		ldr	r0, [r4, #8]	@ float
 347:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8685              		.loc 28 347 0
 8686 0018 BDE81040 		pop	{r4, lr}
 346:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 8687              		.loc 28 346 0
 8688 001c FFF7FEBF 		b	_Z15PrintValueCommaf
 8689              	.L532:
 8690              		.align	2
 8691              	.L531:
 8692 0020 00000000 		.word	.LANCHOR9
 8693              		.cfi_endproc
 8694              	.LFE229:
 8696              		.section	.text._Z17printVehicleStatePKcmS0_,"ax",%progbits
 8697              		.align	1
 8698              		.global	_Z17printVehicleStatePKcmS0_
 8699              		.thumb
 8700              		.thumb_func
 8702              	_Z17printVehicleStatePKcmS0_:
 8703              	.LFB237:
 774:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 775:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 776:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #ifdef BinaryWrite
 777:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void printInt(int data) {
 778:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   byte msb, lsb;
 779:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 780:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   msb = data >> 8;
 781:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   lsb = data & 0xff;
 782:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 783:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(msb);
 784:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(lsb);
 785:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 786:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 787:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendBinaryFloat(float data) {
 788:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   union binaryFloatType {
 789:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     byte floatByte[4];
 790:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     float floatVal;
 791:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   } binaryFloat;
 792:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 793:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryFloat.floatVal = data;
 794:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[3]);
 795:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[2]);
 796:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[1]);
 797:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[0]);
 798:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 799:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 800:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendBinaryuslong(unsigned long data) {
 801:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   union binaryuslongType {
 802:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     byte uslongByte[4];
 803:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     unsigned long uslongVal;
 804:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   } binaryuslong;
 805:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 806:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryuslong.uslongVal = data;
 807:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[3]);
 808:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[2]);
 809:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[1]);
 810:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[0]);
 811:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 812:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 813:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 814:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void fastTelemetry()
 815:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 816:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // **************************************************************
 817:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // ***************** Fast Transfer Of Sensor Data ***************
 818:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // **************************************************************
 819:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // AeroQuad.h defines the output rate to be 10ms
 820:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Since writing to UART is done by hardware, unable to measure data rate directly
 821:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Through analysis:  115200 baud = 115200 bits/second = 14400 bytes/second
 822:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // If float = 4 bytes, then 3600 floats/second
 823:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // If 10 ms output rate, then 36 floats/10ms
 824:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Number of floats written using sendBinaryFloat is 15
 825:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 826:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (motorArmed == ON) {
 827:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef OpenlogBinaryWrite
 828:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        printInt(21845); // Start word of 0x5555
 829:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        sendBinaryuslong(currentTime);
 830:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         printInt((int)flightMode);
 831:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 832:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 833:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 834:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 835:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 836:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 837:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        sendBinaryFloat(accelOneG);
 838:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #ifdef HeadingMagHold
 839:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           sendBinaryFloat(hdgX);
 840:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           sendBinaryFloat(hdgY);
 841:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 		  for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 842:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 		       #if defined(HeadingMagHold)
 843:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 			      sendBinaryFloat(getMagnetometerData(axis));
 844:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 		       #endif
 845:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           }
 846:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #else
 847:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(0.0);
 848:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(0.0);
 849:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(0.0);
 850:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #endif
 851:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 852:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           sendBinaryFloat(kinematicsAngle[axis]);
 853:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         }
 854:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         printInt(32767); // Stop word of 0x7FFF
 855:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 856:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        printInt(21845); // Start word of 0x5555
 857:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 858:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 859:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 860:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 861:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 862:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 863:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++)
 864:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #if defined(HeadingMagHold)
 865:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(getMagnetometerData(axis));
 866:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #else
 867:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(0);
 868:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #endif
 869:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 870:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(getGyroUnbias(axis));
 871:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 872:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 873:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(kinematicsAngle[axis]);
 874:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 875:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        printInt(32767); // Stop word of 0x7FFF
 876:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 877:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 878:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 879:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #endif // BinaryWrite
 880:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 881:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 8704              		.loc 28 881 0
 8705              		.cfi_startproc
 8706              		@ args = 0, pretend = 0, frame = 0
 8707              		@ frame_needed = 0, uses_anonymous_args = 0
 8708              	.LVL376:
 8709 0000 8446     		mov	ip, r0
 8710 0002 38B5     		push	{r3, r4, r5, lr}
 8711              	.LCFI83:
 8712              		.cfi_def_cfa_offset 16
 8713              		.cfi_offset 14, -4
 8714              		.cfi_offset 5, -8
 8715              		.cfi_offset 4, -12
 8716              		.cfi_offset 3, -16
 882:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   
 883:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(sensorName);
 8717              		.loc 28 883 0
 8718 0004 0B48     		ldr	r0, .L535
 8719              	.LVL377:
 881:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 8720              		.loc 28 881 0
 8721 0006 0C46     		mov	r4, r1
 8722              		.loc 28 883 0
 8723 0008 6146     		mov	r1, ip
 8724              	.LVL378:
 881:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 8725              		.loc 28 881 0
 8726 000a 1546     		mov	r5, r2
 8727              		.loc 28 883 0
 8728 000c FFF7FEFF 		bl	_ZN5Print5printEPKc
 8729              	.LVL379:
 884:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(": ");
 8730              		.loc 28 884 0
 8731 0010 0848     		ldr	r0, .L535
 8732 0012 0949     		ldr	r1, .L535+4
 8733 0014 FFF7FEFF 		bl	_ZN5Print5printEPKc
 885:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (!(vehicleState & state)) {
 8734              		.loc 28 885 0
 8735 0018 0848     		ldr	r0, .L535+8
 8736 001a 0368     		ldr	r3, [r0, #0]
 8737 001c 1C42     		tst	r4, r3
 8738 001e 03D1     		bne	.L534
 886:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT("Not ");
 8739              		.loc 28 886 0
 8740 0020 0448     		ldr	r0, .L535
 8741 0022 0749     		ldr	r1, .L535+12
 8742 0024 FFF7FEFF 		bl	_ZN5Print5printEPKc
 8743              	.L534:
 887:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 888:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(message);
 8744              		.loc 28 888 0
 8745 0028 0248     		ldr	r0, .L535
 8746 002a 2946     		mov	r1, r5
 889:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8747              		.loc 28 889 0
 8748 002c BDE83840 		pop	{r3, r4, r5, lr}
 888:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(message);
 8749              		.loc 28 888 0
 8750 0030 FFF7FEBF 		b	_ZN5Print7printlnEPKc
 8751              	.L536:
 8752              		.align	2
 8753              	.L535:
 8754 0034 00000000 		.word	SerialUSB
 8755 0038 00000000 		.word	.LC0
 8756 003c 00000000 		.word	.LANCHOR13
 8757 0040 03000000 		.word	.LC1
 8758              		.cfi_endproc
 8759              	.LFE237:
 8761              		.section	.text._Z18reportVehicleStatev,"ax",%progbits
 8762              		.align	1
 8763              		.global	_Z18reportVehicleStatev
 8764              		.thumb
 8765              		.thumb_func
 8767              	_Z18reportVehicleStatev:
 8768              	.LFB238:
 890:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 891:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void reportVehicleState() {
 8769              		.loc 28 891 0
 8770              		.cfi_startproc
 8771              		@ args = 0, pretend = 0, frame = 0
 8772              		@ frame_needed = 0, uses_anonymous_args = 0
 8773 0000 13B5     		push	{r0, r1, r4, lr}
 8774              	.LCFI84:
 8775              		.cfi_def_cfa_offset 16
 8776              		.cfi_offset 14, -4
 8777              		.cfi_offset 4, -8
 8778              		.cfi_offset 1, -12
 8779              		.cfi_offset 0, -16
 892:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Tell Configurator how many vehicle state values to expect
 893:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(15);
 8780              		.loc 28 893 0
 8781 0002 0A22     		movs	r2, #10
 8782 0004 0F21     		movs	r1, #15
 8783 0006 3648     		ldr	r0, .L538+8
 8784 0008 FFF7FEFF 		bl	_ZN5Print7printlnEii
 894:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Software Version: ");
 8785              		.loc 28 894 0
 8786 000c 3549     		ldr	r1, .L538+12
 8787 000e 3448     		ldr	r0, .L538+8
 8788 0010 FFF7FEFF 		bl	_ZN5Print5printEPKc
 895:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 8789              		.loc 28 895 0
 8790 0014 0124     		movs	r4, #1
 8791 0016 30A3     		adr	r3, .L538
 8792 0018 D3E90023 		ldrd	r2, [r3]
 8793 001c 3048     		ldr	r0, .L538+8
 8794 001e 0094     		str	r4, [sp, #0]
 8795 0020 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 896:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Board Type: ");
 8796              		.loc 28 896 0
 8797 0024 2E48     		ldr	r0, .L538+8
 8798 0026 3049     		ldr	r1, .L538+16
 8799 0028 FFF7FEFF 		bl	_ZN5Print5printEPKc
 897:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #if defined(AeroQuad_v1)
 898:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("v1.x");
 899:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuad_v1_IDG)
 900:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("v1.x IDG");
 901:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_v1)
 902:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mega v1.x");
 903:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuad_v18)
 904:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("v1.8 and greater");
 905:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_v2)
 906:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mega v2");
 907:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 908:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mega v21");
 909:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 910:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("AutoNav");
 911:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AutonavShield)
 912:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("AutonavShield");
 913:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuad_Wii)
 914:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Wii");
 915:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_Wii)
 916:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mega Wii");
 917:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(ArduCopter)
 918:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("ArduCopter");
 919:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_CHR6DM)
 920:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("CHR6DM");
 921:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(APM_OP_CHR6DM)
 922:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("APM w/ CHR6DM");
 923:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuad_Mini)
 924:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mini");
 925:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadSTM32)
 926:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(STM32_BOARD_TYPE);
 8800              		.loc 28 926 0
 8801 002c 2C48     		ldr	r0, .L538+8
 8802 002e 2F49     		ldr	r1, .L538+20
 8803 0030 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 927:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #endif
 928:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 929:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Flight Config: ");
 8804              		.loc 28 929 0
 8805 0034 2A48     		ldr	r0, .L538+8
 8806 0036 2E49     		ldr	r1, .L538+24
 8807 0038 FFF7FEFF 		bl	_ZN5Print5printEPKc
 930:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #if defined(quadPlusConfig)
 931:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Quad +");
 932:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(quadXConfig)
 933:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Quad X");
 8808              		.loc 28 933 0
 8809 003c 2848     		ldr	r0, .L538+8
 8810 003e 2D49     		ldr	r1, .L538+28
 8811 0040 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 934:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined (quadY4Config)
 935:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Quad Y4");
 936:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined (triConfig)
 937:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Tri");
 938:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(hexPlusConfig)
 939:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Hex +");
 940:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(hexXConfig)
 941:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Hex X");
 942:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(hexY6Config)
 943:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Hex Y6");
 944:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(octoX8Config)
 945:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Octo X8");
 946:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(octoXConfig)
 947:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Octo X");
 948:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(octoPlusConfig)
 949:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Octo +");
 950:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #endif
 951:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 952:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Receiver Channels: ");
 8812              		.loc 28 952 0
 8813 0044 2648     		ldr	r0, .L538+8
 8814 0046 2C49     		ldr	r1, .L538+32
 8815 0048 FFF7FEFF 		bl	_ZN5Print5printEPKc
 953:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(LASTCHANNEL);
 8816              		.loc 28 953 0
 8817 004c 0A22     		movs	r2, #10
 8818 004e 0821     		movs	r1, #8
 8819 0050 2348     		ldr	r0, .L538+8
 8820 0052 FFF7FEFF 		bl	_ZN5Print7printlnEii
 954:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 955:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Motors: ");
 8821              		.loc 28 955 0
 8822 0056 2248     		ldr	r0, .L538+8
 8823 0058 2849     		ldr	r1, .L538+36
 8824 005a FFF7FEFF 		bl	_ZN5Print5printEPKc
 956:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(LASTMOTOR);
 8825              		.loc 28 956 0
 8826 005e 0421     		movs	r1, #4
 8827 0060 0A22     		movs	r2, #10
 8828 0062 1F48     		ldr	r0, .L538+8
 8829 0064 FFF7FEFF 		bl	_ZN5Print7printlnEii
 957:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 958:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Gyroscope", GYRO_DETECTED, "Detected");
 8830              		.loc 28 958 0
 8831 0068 2146     		mov	r1, r4
 8832 006a 2548     		ldr	r0, .L538+40
 8833 006c 254A     		ldr	r2, .L538+44
 8834 006e FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 959:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Accelerometer", ACCEL_DETECTED, "Detected");
 8835              		.loc 28 959 0
 8836 0072 0221     		movs	r1, #2
 8837 0074 2448     		ldr	r0, .L538+48
 8838 0076 234A     		ldr	r2, .L538+44
 8839 0078 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 960:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Barometer", BARO_DETECTED, "Detected");
 8840              		.loc 28 960 0
 8841 007c 0821     		movs	r1, #8
 8842 007e 2348     		ldr	r0, .L538+52
 8843 0080 204A     		ldr	r2, .L538+44
 8844 0082 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 961:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Magnetometer", MAG_DETECTED, "Detected");
 8845              		.loc 28 961 0
 8846 0086 0421     		movs	r1, #4
 8847 0088 2148     		ldr	r0, .L538+56
 8848 008a 1E4A     		ldr	r2, .L538+44
 8849 008c FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 962:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Heading Hold", HEADINGHOLD_ENABLED, "Enabled");
 8850              		.loc 28 962 0
 8851 0090 1021     		movs	r1, #16
 8852 0092 2048     		ldr	r0, .L538+60
 8853 0094 204A     		ldr	r2, .L538+64
 8854 0096 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 963:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Altitude Hold", ALTITUDEHOLD_ENABLED, "Enabled");
 8855              		.loc 28 963 0
 8856 009a 2021     		movs	r1, #32
 8857 009c 1F48     		ldr	r0, .L538+68
 8858 009e 1E4A     		ldr	r2, .L538+64
 8859 00a0 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 964:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Battery Monitor", BATTMONITOR_ENABLED, "Enabled");
 8860              		.loc 28 964 0
 8861 00a4 4021     		movs	r1, #64
 8862 00a6 1E48     		ldr	r0, .L538+72
 8863 00a8 1B4A     		ldr	r2, .L538+64
 8864 00aa FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 965:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Camera Stability", CAMERASTABLE_ENABLED, "Enabled");
 8865              		.loc 28 965 0
 8866 00ae 8021     		movs	r1, #128
 8867 00b0 1C48     		ldr	r0, .L538+76
 8868 00b2 194A     		ldr	r2, .L538+64
 8869 00b4 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 966:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Range Detection", RANGE_ENABLED, "Enabled");
 8870              		.loc 28 966 0
 8871 00b8 1B48     		ldr	r0, .L538+80
 8872 00ba 174A     		ldr	r2, .L538+64
 8873 00bc 4FF48071 		mov	r1, #256
 8874 00c0 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 967:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #ifdef UseGPS
 968:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("GPS: ");
 969:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT((gpsData.state==GPS_DETECTING)?"Scanning ":"Detected ");
 970:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (gpsData.state != GPS_DETECTING) {
 971:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(gpsTypes[gpsData.type].name);
 972:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 973:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("@");
 974:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(gpsBaudRates[gpsData.baudrate]);
 975:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #else
 976:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN("GPS: Not Enabled");
 8875              		.loc 28 976 0
 8876 00c4 0648     		ldr	r0, .L538+8
 8877 00c6 1949     		ldr	r1, .L538+84
 977:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #endif
 978:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 8878              		.loc 28 978 0
 8879 00c8 02B0     		add	sp, sp, #8
 8880 00ca BDE81040 		pop	{r4, lr}
 976:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN("GPS: Not Enabled");
 8881              		.loc 28 976 0
 8882 00ce FFF7FEBF 		b	_ZN5Print7printlnEPKc
 8883              	.L539:
 8884 00d2 00BFAFF3 		.align	3
 8884      0080
 8885              	.L538:
 8886 00d8 000000A0 		.word	-1610612736
 8887 00dc 99990940 		.word	1074370969
 8888 00e0 00000000 		.word	SerialUSB
 8889 00e4 08000000 		.word	.LC2
 8890 00e8 1B000000 		.word	.LC3
 8891 00ec 28000000 		.word	.LC4
 8892 00f0 33000000 		.word	.LC5
 8893 00f4 43000000 		.word	.LC6
 8894 00f8 4A000000 		.word	.LC7
 8895 00fc 5E000000 		.word	.LC8
 8896 0100 67000000 		.word	.LC9
 8897 0104 71000000 		.word	.LC10
 8898 0108 7A000000 		.word	.LC11
 8899 010c 88000000 		.word	.LC12
 8900 0110 92000000 		.word	.LC13
 8901 0114 9F000000 		.word	.LC14
 8902 0118 AC000000 		.word	.LC15
 8903 011c B4000000 		.word	.LC16
 8904 0120 C2000000 		.word	.LC17
 8905 0124 D2000000 		.word	.LC18
 8906 0128 E3000000 		.word	.LC19
 8907 012c F3000000 		.word	.LC20
 8908              		.cfi_endproc
 8909              	.LFE238:
 8911              		.section	.text._Z19sendSerialTelemetryv,"ax",%progbits
 8912              		.align	1
 8913              		.global	_Z19sendSerialTelemetryv
 8914              		.thumb
 8915              		.thumb_func
 8917              	_Z19sendSerialTelemetryv:
 8918              	.LFB232:
 369:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 8919              		.loc 28 369 0
 8920              		.cfi_startproc
 8921              		@ args = 0, pretend = 0, frame = 0
 8922              		@ frame_needed = 0, uses_anonymous_args = 0
 8923 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8924              	.LCFI85:
 8925              		.cfi_def_cfa_offset 32
 8926              		.cfi_offset 14, -4
 8927              		.cfi_offset 7, -8
 8928              		.cfi_offset 6, -12
 8929              		.cfi_offset 5, -16
 8930              		.cfi_offset 4, -20
 8931              		.cfi_offset 2, -24
 8932              		.cfi_offset 1, -28
 8933              		.cfi_offset 0, -32
 8934              	.LBB223:
 370:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 8935              		.loc 28 370 0
 8936 0002 A94C     		ldr	r4, .L609
 8937 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 8938 0006 6B2B     		cmp	r3, #107
 8939 0008 2646     		mov	r6, r4
 8940 000a 00F0E880 		beq	.L556
 8941 000e 2FD8     		bhi	.L570
 8942 0010 632B     		cmp	r3, #99
 8943 0012 00F09580 		beq	.L549
 8944 0016 18D8     		bhi	.L571
 8945 0018 362B     		cmp	r3, #54
 8946 001a 00F02482 		beq	.L583
 8947 001e 0ED8     		bhi	.L572
 8948 0020 232B     		cmp	r3, #35
 8949 0022 00F01B82 		beq	.L543
 8950 0026 03D8     		bhi	.L573
 8951 0028 212B     		cmp	r3, #33
 8952 002a 40F02982 		bne	.L540
 8953 002e 0CE2     		b	.L602
 8954              	.L573:
 8955 0030 242B     		cmp	r3, #36
 8956 0032 00F0FE81 		beq	.L544
 8957 0036 252B     		cmp	r3, #37
 8958 0038 40F02282 		bne	.L540
 8959 003c FDE1     		b	.L545
 8960              	.L572:
 8961 003e 612B     		cmp	r3, #97
 8962 0040 5ED0     		beq	.L547
 8963 0042 622B     		cmp	r3, #98
 8964 0044 40F01C82 		bne	.L540
 8965 0048 65E0     		b	.L603
 8966              	.L571:
 8967 004a 662B     		cmp	r3, #102
 8968 004c 00F08C80 		beq	.L552
 8969 0050 05D8     		bhi	.L574
 8970 0052 642B     		cmp	r3, #100
 8971 0054 7ED0     		beq	.L550
 8972 0056 652B     		cmp	r3, #101
 8973 0058 40F01282 		bne	.L540
 8974 005c 7CE0     		b	.L604
 8975              	.L574:
 8976 005e 682B     		cmp	r3, #104
 8977 0060 00F0A880 		beq	.L554
 8978 0064 C0F09180 		bcc	.L553
 8979 0068 692B     		cmp	r3, #105
 8980 006a 40F00982 		bne	.L540
 8981 006e 29E0     		b	.L605
 8982              	.L570:
 8983 0070 722B     		cmp	r3, #114
 8984 0072 00F07781 		beq	.L563
 8985 0076 10D8     		bhi	.L575
 8986 0078 6E2B     		cmp	r3, #110
 8987 007a 00F01181 		beq	.L559
 8988 007e 06D8     		bhi	.L576
 8989 0080 6C2B     		cmp	r3, #108
 8990 0082 00F0EE80 		beq	.L557
 8991 0086 6D2B     		cmp	r3, #109
 8992 0088 40F0FA81 		bne	.L540
 8993 008c E8E1     		b	.L593
 8994              	.L576:
 8995 008e 702B     		cmp	r3, #112
 8996 0090 00F02C81 		beq	.L561
 8997 0094 00F25F81 		bhi	.L562
 8998 0098 04E1     		b	.L606
 8999              	.L575:
 9000 009a 752B     		cmp	r3, #117
 9001 009c 00F0B381 		beq	.L566
 9002 00a0 06D8     		bhi	.L577
 9003 00a2 732B     		cmp	r3, #115
 9004 00a4 00F07181 		beq	.L564
 9005 00a8 742B     		cmp	r3, #116
 9006 00aa 40F0E981 		bne	.L540
 9007 00ae A1E1     		b	.L607
 9008              	.L577:
 9009 00b0 792B     		cmp	r3, #121
 9010 00b2 00F0B881 		beq	.L568
 9011 00b6 7A2B     		cmp	r3, #122
 9012 00b8 00F0B781 		beq	.L569
 9013 00bc 762B     		cmp	r3, #118
 9014 00be 40F0DF81 		bne	.L540
 9015 00c2 A9E1     		b	.L608
 9016              	.L605:
 9017              	.LVL380:
 9018              	.LBB224:
 9019              	.LBB225:
 455:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 9020              		.loc 28 455 0 discriminator 1
 9021 00c4 794C     		ldr	r4, .L609+4
 9022 00c6 2068     		ldr	r0, [r4, #0]	@ float
 9023 00c8 FFF7FEFF 		bl	_Z15PrintValueCommaf
 9024              	.LVL381:
 9025 00cc 6068     		ldr	r0, [r4, #4]	@ float
 9026 00ce FFF7FEFF 		bl	_Z15PrintValueCommaf
 9027              	.LVL382:
 9028 00d2 A068     		ldr	r0, [r4, #8]	@ float
 9029              	.LBE225:
 9030              	.LBB226:
 458:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 9031              		.loc 28 458 0 discriminator 1
 9032 00d4 764C     		ldr	r4, .L609+8
 9033              	.LBE226:
 9034              	.LBB227:
 455:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 9035              		.loc 28 455 0 discriminator 1
 9036 00d6 FFF7FEFF 		bl	_Z15PrintValueCommaf
 9037              	.LVL383:
 9038              	.LBE227:
 9039              	.LBB228:
 458:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 9040              		.loc 28 458 0 discriminator 1
 9041 00da 2068     		ldr	r0, [r4, #0]	@ float
 9042 00dc FFF7FEFF 		bl	_Z15PrintValueCommaf
 9043              	.LVL384:
 9044 00e0 6068     		ldr	r0, [r4, #4]	@ float
 9045 00e2 FFF7FEFF 		bl	_Z15PrintValueCommaf
 9046              	.LVL385:
 9047 00e6 A068     		ldr	r0, [r4, #8]	@ float
 9048 00e8 FFF7FEFF 		bl	_Z15PrintValueCommaf
 9049              	.LVL386:
 9050              	.LBE228:
 9051              	.LBB229:
 464:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(0);
 9052              		.loc 28 464 0 discriminator 1
 9053 00ec 0020     		movs	r0, #0
 9054 00ee FFF7FEFF 		bl	_Z15PrintValueCommai
 9055              	.LVL387:
 9056 00f2 0020     		movs	r0, #0
 9057 00f4 FFF7FEFF 		bl	_Z15PrintValueCommai
 9058              	.LVL388:
 9059 00f8 0020     		movs	r0, #0
 9060 00fa FFF7FEFF 		bl	_Z15PrintValueCommai
 9061              	.LVL389:
 9062 00fe 73E1     		b	.L595
 9063              	.LVL390:
 9064              	.L547:
 9065              	.LBE229:
 375:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 9066              		.loc 28 375 0
 9067 0100 0020     		movs	r0, #0
 9068 0102 FFF7FEFF 		bl	_Z8PrintPIDh
 376:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 9069              		.loc 28 376 0
 9070 0106 0120     		movs	r0, #1
 9071 0108 FFF7FEFF 		bl	_Z8PrintPIDh
 377:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 9072              		.loc 28 377 0
 9073 010c 694B     		ldr	r3, .L609+12
 9074 010e 1868     		ldr	r0, [r3, #0]	@ float
 9075 0110 FFF7FEFF 		bl	_Z15PrintValueCommaf
 9076 0114 83E1     		b	.L597
 9077              	.L603:
 383:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 9078              		.loc 28 383 0
 9079 0116 0320     		movs	r0, #3
 9080 0118 FFF7FEFF 		bl	_Z8PrintPIDh
 384:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 9081              		.loc 28 384 0
 9082 011c 0420     		movs	r0, #4
 9083 011e FFF7FEFF 		bl	_Z8PrintPIDh
 385:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 9084              		.loc 28 385 0
 9085 0122 0620     		movs	r0, #6
 9086 0124 FFF7FEFF 		bl	_Z8PrintPIDh
 386:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 9087              		.loc 28 386 0
 9088 0128 0720     		movs	r0, #7
 9089 012a FFF7FEFF 		bl	_Z8PrintPIDh
 387:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(windupGuard);
 9090              		.loc 28 387 0
 9091 012e 6248     		ldr	r0, .L609+16
 9092 0130 0068     		ldr	r0, [r0, #0]	@ float
 9093 0132 FFF7FEFF 		bl	__aeabi_f2d
 9094 0136 0B46     		mov	r3, r1
 9095 0138 0221     		movs	r1, #2
 9096 013a 0246     		mov	r2, r0
 9097 013c 0091     		str	r1, [sp, #0]
 9098 013e 8EE0     		b	.L601
 9099              	.L549:
 392:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 9100              		.loc 28 392 0
 9101 0140 0220     		movs	r0, #2
 9102 0142 FFF7FEFF 		bl	_Z8PrintPIDh
 393:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 9103              		.loc 28 393 0
 9104 0146 0520     		movs	r0, #5
 9105 0148 FFF7FEFF 		bl	_Z8PrintPIDh
 394:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 9106              		.loc 28 394 0
 9107 014c 5B4A     		ldr	r2, .L609+20
 9108 014e 5C48     		ldr	r0, .L609+24
 9109 0150 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 9110 0152 5DE1     		b	.L598
 9111              	.L550:
 413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(10);
 9112              		.loc 28 413 0
 9113 0154 0A20     		movs	r0, #10
 9114 0156 60E1     		b	.L600
 9115              	.L604:
 420:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(aref);
 9116              		.loc 28 420 0
 9117 0158 5A49     		ldr	r1, .L609+28
 9118 015a 0868     		ldr	r0, [r1, #0]	@ float
 9119 015c FFF7FEFF 		bl	_Z15PrintValueCommaf
 421:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 9120              		.loc 28 421 0
 9121 0160 594B     		ldr	r3, .L609+32
 9122 0162 5748     		ldr	r0, .L609+24
 9123 0164 1968     		ldr	r1, [r3, #0]
 9124 0166 53E1     		b	.L598
 9125              	.L552:
 426:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 9126              		.loc 28 426 0
 9127 0168 584D     		ldr	r5, .L609+36
 9128 016a 594C     		ldr	r4, .L609+40
 9129 016c 2868     		ldr	r0, [r5, #0]	@ float
 9130 016e FFF7FEFF 		bl	_Z15PrintValueCommaf
 9131              	.LVL391:
 369:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 9132              		.loc 28 369 0
 9133 0172 04F12005 		add	r5, r4, #32
 9134              	.LVL392:
 9135              	.L578:
 9136              	.LBB230:
 428:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 9137              		.loc 28 428 0 discriminator 2
 9138 0176 54F8040F 		ldr	r0, [r4, #4]!	@ float
 9139 017a FFF7FEFF 		bl	_Z15PrintValueCommaf
 427:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 9140              		.loc 28 427 0 discriminator 2
 9141 017e AC42     		cmp	r4, r5
 9142 0180 F9D1     		bne	.L578
 9143              	.LBE230:
 430:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintDummyValues(10 - LASTCHANNEL);
 9144              		.loc 28 430 0
 9145 0182 0220     		movs	r0, #2
 9146 0184 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 9147 0188 75E1     		b	.L594
 9148              	.L553:
 433:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 9149              		.loc 28 433 0
 9150 018a 524C     		ldr	r4, .L609+44
 369:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 9151              		.loc 28 369 0
 9152 018c 04F12005 		add	r5, r4, #32
 9153              	.L579:
 9154              	.LBB231:
 437:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 9155              		.loc 28 437 0 discriminator 2
 9156 0190 54F8040F 		ldr	r0, [r4, #4]!	@ float
 9157 0194 FFF7FEFF 		bl	__aeabi_f2d
 9158 0198 0246     		mov	r2, r0
 9159 019a 0620     		movs	r0, #6
 9160 019c 0B46     		mov	r3, r1
 9161 019e 0090     		str	r0, [sp, #0]
 9162 01a0 4748     		ldr	r0, .L609+24
 9163 01a2 FFF7FEFF 		bl	_ZN5Print5printEdi
 438:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(',');
 9164              		.loc 28 438 0 discriminator 2
 9165 01a6 2C21     		movs	r1, #44
 9166 01a8 4548     		ldr	r0, .L609+24
 9167 01aa FFF7FEFF 		bl	_ZN5Print5printEc
 436:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 9168              		.loc 28 436 0 discriminator 2
 9169 01ae AC42     		cmp	r4, r5
 9170 01b0 EED1     		bne	.L579
 9171 01b2 60E1     		b	.L594
 9172              	.LVL393:
 9173              	.L554:
 9174              	.LBE231:
 442:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 9175              		.loc 28 442 0
 9176 01b4 484C     		ldr	r4, .L609+48
 369:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 9177              		.loc 28 369 0
 9178 01b6 04F12005 		add	r5, r4, #32
 9179              	.L580:
 9180              	.LBB232:
 446:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 9181              		.loc 28 446 0 discriminator 2
 9182 01ba 54F8040F 		ldr	r0, [r4, #4]!	@ float
 9183 01be FFF7FEFF 		bl	__aeabi_f2d
 9184 01c2 0246     		mov	r2, r0
 9185 01c4 0B46     		mov	r3, r1
 9186 01c6 3E48     		ldr	r0, .L609+24
 9187 01c8 0621     		movs	r1, #6
 9188 01ca 0091     		str	r1, [sp, #0]
 9189 01cc FFF7FEFF 		bl	_ZN5Print5printEdi
 447:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(',');
 9190              		.loc 28 447 0 discriminator 2
 9191 01d0 2C21     		movs	r1, #44
 9192 01d2 3B48     		ldr	r0, .L609+24
 9193 01d4 FFF7FEFF 		bl	_ZN5Print5printEc
 445:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 9194              		.loc 28 445 0 discriminator 2
 9195 01d8 AC42     		cmp	r4, r5
 9196 01da EED1     		bne	.L580
 9197 01dc 4BE1     		b	.L594
 9198              	.LVL394:
 9199              	.L556:
 9200              	.LBE232:
 479:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 9201              		.loc 28 479 0
 9202 01de 3F4E     		ldr	r6, .L609+52
 481:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 9203              		.loc 28 481 0
 9204 01e0 3F4F     		ldr	r7, .L609+56
 479:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 9205              		.loc 28 479 0
 9206 01e2 3068     		ldr	r0, [r6, #0]	@ float
 9207 01e4 FFF7FEFF 		bl	__aeabi_f2d
 9208 01e8 0625     		movs	r5, #6
 9209 01ea 0246     		mov	r2, r0
 9210 01ec 0B46     		mov	r3, r1
 9211 01ee 3448     		ldr	r0, .L609+24
 9212 01f0 0095     		str	r5, [sp, #0]
 9213 01f2 FFF7FEFF 		bl	_ZN5Print5printEdi
 480:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 9214              		.loc 28 480 0
 9215 01f6 FFF7FEFF 		bl	_Z5commav
 481:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 9216              		.loc 28 481 0
 9217 01fa 3868     		ldr	r0, [r7, #0]	@ float
 9218 01fc FFF7FEFF 		bl	__aeabi_f2d
 9219 0200 0246     		mov	r2, r0
 9220 0202 0B46     		mov	r3, r1
 9221 0204 2E48     		ldr	r0, .L609+24
 9222 0206 0095     		str	r5, [sp, #0]
 9223 0208 FFF7FEFF 		bl	_ZN5Print5printEdi
 482:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 9224              		.loc 28 482 0
 9225 020c FFF7FEFF 		bl	_Z5commav
 483:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 9226              		.loc 28 483 0
 9227 0210 7068     		ldr	r0, [r6, #4]	@ float
 9228 0212 FFF7FEFF 		bl	__aeabi_f2d
 9229 0216 0246     		mov	r2, r0
 9230 0218 0B46     		mov	r3, r1
 9231 021a 2948     		ldr	r0, .L609+24
 9232 021c 0095     		str	r5, [sp, #0]
 9233 021e FFF7FEFF 		bl	_ZN5Print5printEdi
 484:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 9234              		.loc 28 484 0
 9235 0222 FFF7FEFF 		bl	_Z5commav
 485:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 9236              		.loc 28 485 0
 9237 0226 7868     		ldr	r0, [r7, #4]	@ float
 9238 0228 FFF7FEFF 		bl	__aeabi_f2d
 9239 022c 0246     		mov	r2, r0
 9240 022e 0B46     		mov	r3, r1
 9241 0230 2348     		ldr	r0, .L609+24
 9242 0232 0095     		str	r5, [sp, #0]
 9243 0234 FFF7FEFF 		bl	_ZN5Print5printEdi
 486:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 9244              		.loc 28 486 0
 9245 0238 FFF7FEFF 		bl	_Z5commav
 487:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 9246              		.loc 28 487 0
 9247 023c B068     		ldr	r0, [r6, #8]	@ float
 9248 023e FFF7FEFF 		bl	__aeabi_f2d
 9249 0242 0246     		mov	r2, r0
 9250 0244 0B46     		mov	r3, r1
 9251 0246 1E48     		ldr	r0, .L609+24
 9252 0248 0095     		str	r5, [sp, #0]
 9253 024a FFF7FEFF 		bl	_ZN5Print5printEdi
 488:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 9254              		.loc 28 488 0
 9255 024e FFF7FEFF 		bl	_Z5commav
 489:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 9256              		.loc 28 489 0
 9257 0252 B868     		ldr	r0, [r7, #8]	@ float
 9258 0254 FFF7FEFF 		bl	__aeabi_f2d
 9259 0258 0095     		str	r5, [sp, #0]
 9260 025a 0246     		mov	r2, r0
 9261 025c 0B46     		mov	r3, r1
 9262              	.L601:
 9263 025e 1848     		ldr	r0, .L609+24
 9264 0260 F9E0     		b	.L599
 9265              	.L557:
 495:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 9266              		.loc 28 495 0
 9267 0262 204C     		ldr	r4, .L609+60
 9268 0264 204D     		ldr	r5, .L609+64
 494:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     measureAccelSum();
 9269              		.loc 28 494 0
 9270 0266 FFF7FEFF 		bl	_Z15measureAccelSumv
 495:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 9271              		.loc 28 495 0
 9272 026a 2978     		ldrb	r1, [r5, #0]	@ zero_extendqisi2
 9273 026c 2668     		ldr	r6, [r4, #0]
 9274 026e 96FBF1F0 		sdiv	r0, r6, r1
 9275 0272 FFF7FEFF 		bl	_Z15PrintValueCommai
 497:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 9276              		.loc 28 497 0
 9277 0276 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 9278 0278 6068     		ldr	r0, [r4, #4]
 496:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[XAXIS] = 0;
 9279              		.loc 28 496 0
 9280 027a 0026     		movs	r6, #0
 497:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 9281              		.loc 28 497 0
 9282 027c 90FBF3F0 		sdiv	r0, r0, r3
 496:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[XAXIS] = 0;
 9283              		.loc 28 496 0
 9284 0280 2660     		str	r6, [r4, #0]
 497:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 9285              		.loc 28 497 0
 9286 0282 FFF7FEFF 		bl	_Z15PrintValueCommai
 499:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 9287              		.loc 28 499 0
 9288 0286 A268     		ldr	r2, [r4, #8]
 9289 0288 95F800C0 		ldrb	ip, [r5, #0]	@ zero_extendqisi2
 498:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[YAXIS] = 0;
 9290              		.loc 28 498 0
 9291 028c 6660     		str	r6, [r4, #4]
 499:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 9292              		.loc 28 499 0
 9293 028e 92FBFCF1 		sdiv	r1, r2, ip
 9294 0292 0B48     		ldr	r0, .L609+24
 9295 0294 0A22     		movs	r2, #10
 9296 0296 FFF7FEFF 		bl	_ZN5Print7printlnEii
 500:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[ZAXIS] = 0;
 9297              		.loc 28 500 0
 9298 029a A660     		str	r6, [r4, #8]
 501:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSampleCount = 0;
 9299              		.loc 28 501 0
 9300 029c 2E70     		strb	r6, [r5, #0]
 502:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 9301              		.loc 28 502 0
 9302 029e EFE0     		b	.L540
 9303              	.L559:
 521:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(3);
 9304              		.loc 28 521 0
 9305 02a0 0320     		movs	r0, #3
 9306 02a2 BAE0     		b	.L600
 9307              	.L606:
 536:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(4);
 9308              		.loc 28 536 0
 9309 02a4 0420     		movs	r0, #4
 9310 02a6 B8E0     		b	.L600
 9311              	.L610:
 9312              		.align	2
 9313              	.L609:
 9314 02a8 00000000 		.word	.LANCHOR98
 9315 02ac 00000000 		.word	.LANCHOR19
 9316 02b0 00000000 		.word	.LANCHOR101
 9317 02b4 00000000 		.word	.LANCHOR78
 9318 02b8 00000000 		.word	.LANCHOR95
 9319 02bc 00000000 		.word	.LANCHOR86
 9320 02c0 00000000 		.word	SerialUSB
 9321 02c4 00000000 		.word	.LANCHOR96
 9322 02c8 00000000 		.word	.LANCHOR83
 9323 02cc 00000000 		.word	.LANCHOR55
 9324 02d0 FCFFFFFF 		.word	.LANCHOR6-4
 9325 02d4 FCFFFFFF 		.word	.LANCHOR4-4
 9326 02d8 FCFFFFFF 		.word	.LANCHOR5-4
 9327 02dc 00000000 		.word	.LANCHOR27
 9328 02e0 00000000 		.word	.LANCHOR28
 9329 02e4 00000000 		.word	.LANCHOR29
 9330 02e8 00000000 		.word	.LANCHOR30
 9331              	.L561:
 544:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(cameraMode);
 9332              		.loc 28 544 0
 9333 02ec 684A     		ldr	r2, .L611+8
 9334 02ee 1068     		ldr	r0, [r2, #0]
 9335 02f0 FFF7FEFF 		bl	_Z15PrintValueCommai
 545:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterPitch);
 9336              		.loc 28 545 0
 9337 02f4 6749     		ldr	r1, .L611+12
 9338 02f6 0868     		ldr	r0, [r1, #0]
 9339 02f8 FFF7FEFF 		bl	_Z15PrintValueCommai
 546:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterRoll);
 9340              		.loc 28 546 0
 9341 02fc 664B     		ldr	r3, .L611+16
 9342 02fe 1868     		ldr	r0, [r3, #0]
 9343 0300 FFF7FEFF 		bl	_Z15PrintValueCommai
 547:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterYaw);
 9344              		.loc 28 547 0
 9345 0304 6548     		ldr	r0, .L611+20
 9346 0306 0068     		ldr	r0, [r0, #0]
 9347 0308 FFF7FEFF 		bl	_Z15PrintValueCommai
 548:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraPitch);
 9348              		.loc 28 548 0
 9349 030c 644A     		ldr	r2, .L611+24
 9350 030e 1068     		ldr	r0, [r2, #0]	@ float
 9351 0310 FFF7FEFF 		bl	_Z15PrintValueCommaf
 549:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraRoll);
 9352              		.loc 28 549 0
 9353 0314 6349     		ldr	r1, .L611+28
 9354 0316 0868     		ldr	r0, [r1, #0]	@ float
 9355 0318 FFF7FEFF 		bl	_Z15PrintValueCommaf
 550:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraYaw);
 9356              		.loc 28 550 0
 9357 031c 624B     		ldr	r3, .L611+32
 9358 031e 1868     		ldr	r0, [r3, #0]	@ float
 9359 0320 FFF7FEFF 		bl	_Z15PrintValueCommaf
 551:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinPitch);
 9360              		.loc 28 551 0
 9361 0324 6148     		ldr	r0, .L611+36
 9362 0326 0068     		ldr	r0, [r0, #0]
 9363 0328 FFF7FEFF 		bl	_Z15PrintValueCommai
 552:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinRoll);
 9364              		.loc 28 552 0
 9365 032c 604A     		ldr	r2, .L611+40
 9366 032e 1068     		ldr	r0, [r2, #0]
 9367 0330 FFF7FEFF 		bl	_Z15PrintValueCommai
 553:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinYaw);
 9368              		.loc 28 553 0
 9369 0334 5F49     		ldr	r1, .L611+44
 9370 0336 0868     		ldr	r0, [r1, #0]
 9371 0338 FFF7FEFF 		bl	_Z15PrintValueCommai
 554:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxPitch);
 9372              		.loc 28 554 0
 9373 033c 5E4B     		ldr	r3, .L611+48
 9374 033e 1868     		ldr	r0, [r3, #0]
 9375 0340 FFF7FEFF 		bl	_Z15PrintValueCommai
 555:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxRoll);
 9376              		.loc 28 555 0
 9377 0344 5D48     		ldr	r0, .L611+52
 9378 0346 0068     		ldr	r0, [r0, #0]
 9379 0348 FFF7FEFF 		bl	_Z15PrintValueCommai
 556:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxYaw);
 9380              		.loc 28 556 0
 9381 034c 5C4A     		ldr	r2, .L611+56
 9382 034e 1068     		ldr	r0, [r2, #0]
 9383 0350 FFF7FEFF 		bl	_Z15PrintValueCommai
 9384 0354 63E0     		b	.L597
 9385              	.L562:
 572:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 9386              		.loc 28 572 0
 9387 0356 5B4B     		ldr	r3, .L611+60
 9388 0358 5B48     		ldr	r0, .L611+64
 9389 035a 1968     		ldr	r1, [r3, #0]
 9390 035c 0A22     		movs	r2, #10
 9391 035e FFF7FEFF 		bl	_ZN5Print7printlnEmi
 9392 0362 7DE0     		b	.L593
 9393              	.L563:
 577:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 9394              		.loc 28 577 0
 9395 0364 594C     		ldr	r4, .L611+68
 9396 0366 2068     		ldr	r0, [r4, #0]	@ float
 9397 0368 FFF7FEFF 		bl	_Z15PrintValueCommaf
 578:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 9398              		.loc 28 578 0
 9399 036c 6068     		ldr	r0, [r4, #4]	@ float
 9400 036e FFF7FEFF 		bl	_Z15PrintValueCommaf
 579:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(getHeading());
 9401              		.loc 28 579 0
 9402 0372 FFF7FEFF 		bl	_Z10getHeadingv
 9403 0376 FFF7FEFF 		bl	__aeabi_f2d
 9404 037a 0246     		mov	r2, r0
 9405 037c 0220     		movs	r0, #2
 9406 037e 0090     		str	r0, [sp, #0]
 9407 0380 0B46     		mov	r3, r1
 9408 0382 5148     		ldr	r0, .L611+64
 9409 0384 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 580:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 9410              		.loc 28 580 0
 9411 0388 7AE0     		b	.L540
 9412              	.L564:
 583:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(motorArmed);
 9413              		.loc 28 583 0
 9414 038a 5149     		ldr	r1, .L611+72
 584:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 9415              		.loc 28 584 0
 9416 038c 4F4C     		ldr	r4, .L611+68
 583:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(motorArmed);
 9417              		.loc 28 583 0
 9418 038e 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 9419 0390 FFF7FEFF 		bl	_Z15PrintValueCommah
 584:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 9420              		.loc 28 584 0
 9421 0394 2068     		ldr	r0, [r4, #0]	@ float
 9422 0396 FFF7FEFF 		bl	_Z15PrintValueCommaf
 585:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 9423              		.loc 28 585 0
 9424 039a 6068     		ldr	r0, [r4, #4]	@ float
 9425 039c FFF7FEFF 		bl	_Z15PrintValueCommaf
 586:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(getHeading());
 9426              		.loc 28 586 0
 9427 03a0 FFF7FEFF 		bl	_Z10getHeadingv
 9428 03a4 FFF7FEFF 		bl	_Z15PrintValueCommaf
 595:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 9429              		.loc 28 595 0
 9430 03a8 0020     		movs	r0, #0
 9431 03aa FFF7FEFF 		bl	_Z15PrintValueCommai
 596:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 9432              		.loc 28 596 0
 9433 03ae 0020     		movs	r0, #0
 9434 03b0 FFF7FEFF 		bl	_Z15PrintValueCommai
 9435              	.LVL395:
 9436 03b4 0024     		movs	r4, #0
 9437              	.LVL396:
 9438              	.L581:
 9439              	.LBB233:
 600:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((channel < LASTCHANNEL) ? receiverCommand[channel] : 0);
 9440              		.loc 28 600 0 discriminator 1
 9441 03b6 474A     		ldr	r2, .L611+76
 9442 03b8 A058     		ldr	r0, [r4, r2]
 9443 03ba 0434     		adds	r4, r4, #4
 9444 03bc FFF7FEFF 		bl	_Z15PrintValueCommai
 599:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 9445              		.loc 28 599 0 discriminator 1
 9446 03c0 202C     		cmp	r4, #32
 9447 03c2 F8D1     		bne	.L581
 599:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 9448              		.loc 28 599 0 is_stmt 0
 9449 03c4 0024     		movs	r4, #0
 9450              	.L582:
 9451              	.LBE233:
 9452              	.LBB234:
 604:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 9453              		.loc 28 604 0 is_stmt 1 discriminator 2
 9454 03c6 444B     		ldr	r3, .L611+80
 9455 03c8 E058     		ldr	r0, [r4, r3]
 9456 03ca 0434     		adds	r4, r4, #4
 9457 03cc FFF7FEFF 		bl	_Z15PrintValueCommai
 603:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 9458              		.loc 28 603 0 discriminator 2
 9459 03d0 102C     		cmp	r4, #16
 9460 03d2 F8D1     		bne	.L582
 9461              	.LBE234:
 606:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintDummyValues(8 - LASTMOTOR); // max of 8 motor outputs supported
 9462              		.loc 28 606 0
 9463 03d4 0420     		movs	r0, #4
 9464 03d6 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 611:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 9465              		.loc 28 611 0
 9466 03da 0020     		movs	r0, #0
 9467 03dc FFF7FEFF 		bl	_Z15PrintValueCommai
 613:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(flightMode);
 9468              		.loc 28 613 0
 9469 03e0 3E48     		ldr	r0, .L611+84
 9470 03e2 0078     		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 9471 03e4 FFF7FEFF 		bl	_Z15PrintValueCommah
 9472              	.LVL397:
 9473              	.L595:
 614:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 9474              		.loc 28 614 0
 9475 03e8 3748     		ldr	r0, .L611+64
 9476              	.LBE224:
 9477              	.LBE223:
 733:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 9478              		.loc 28 733 0
 9479 03ea 03B0     		add	sp, sp, #12
 9480 03ec BDE8F040 		pop	{r4, r5, r6, r7, lr}
 9481              	.LBB241:
 9482              	.LBB237:
 614:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 9483              		.loc 28 614 0
 9484 03f0 FFF7FEBF 		b	_ZN5Print7printlnEv
 9485              	.L607:
 9486              	.LBE237:
 370:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 9487              		.loc 28 370 0
 9488 03f4 0024     		movs	r4, #0
 9489              	.L565:
 9490              	.LBB238:
 9491              	.LBB235:
 619:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 9492              		.loc 28 619 0 discriminator 2
 9493 03f6 3749     		ldr	r1, .L611+76
 9494 03f8 6058     		ldr	r0, [r4, r1]
 9495 03fa 0434     		adds	r4, r4, #4
 9496 03fc FFF7FEFF 		bl	_Z15PrintValueCommai
 618:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 9497              		.loc 28 618 0 discriminator 2
 9498 0400 202C     		cmp	r4, #32
 9499 0402 F8D1     		bne	.L565
 9500 0404 F0E7     		b	.L595
 9501              	.LVL398:
 9502              	.L566:
 9503              	.LBE235:
 629:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 9504              		.loc 28 629 0
 9505 0406 0020     		movs	r0, #0
 9506 0408 FFF7FEFF 		bl	_Z15PrintValueCommai
 630:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0);
 9507              		.loc 28 630 0
 9508 040c 2E48     		ldr	r0, .L611+64
 9509 040e 0021     		movs	r1, #0
 9510              	.L598:
 9511 0410 0A22     		movs	r2, #10
 9512 0412 FFF7FEFF 		bl	_ZN5Print7printlnEii
 9513 0416 23E0     		b	.L593
 9514              	.L608:
 642:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(9);
 9515              		.loc 28 642 0
 9516 0418 0920     		movs	r0, #9
 9517              	.L600:
 9518 041a FFF7FEFF 		bl	_Z16PrintDummyValuesh
 9519              	.L597:
 644:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 9520              		.loc 28 644 0
 9521 041e 2A48     		ldr	r0, .L611+64
 9522 0420 FFF7FEFF 		bl	_ZN5Print7printlnEv
 9523 0424 1CE0     		b	.L593
 9524              	.L568:
 661:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(11);
 9525              		.loc 28 661 0
 9526 0426 0B20     		movs	r0, #11
 9527 0428 04E0     		b	.L596
 9528              	.L569:
 670:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 9529              		.loc 28 670 0
 9530 042a 0020     		movs	r0, #0
 9531 042c FFF7FEFF 		bl	_Z15PrintValueCommai
 9532 0430 03E0     		b	.L545
 9533              	.L544:
 689:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(3);
 9534              		.loc 28 689 0
 9535 0432 0320     		movs	r0, #3
 9536              	.L596:
 9537 0434 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 9538 0438 D6E7     		b	.L595
 9539              	.L545:
 698:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0);
 9540              		.loc 28 698 0
 9541 043a 2348     		ldr	r0, .L611+64
 9542 043c 0021     		movs	r1, #0
 9543 043e 0A22     		movs	r2, #10
 9544              	.LBE238:
 9545              	.LBE241:
 733:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 9546              		.loc 28 733 0
 9547 0440 03B0     		add	sp, sp, #12
 9548 0442 BDE8F040 		pop	{r4, r5, r6, r7, lr}
 9549              	.LBB242:
 9550              	.LBB239:
 698:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0);
 9551              		.loc 28 698 0
 9552 0446 FFF7FEBF 		b	_ZN5Print7printlnEii
 9553              	.L602:
 706:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 9554              		.loc 28 706 0
 9555 044a 0122     		movs	r2, #1
 9556 044c 0092     		str	r2, [sp, #0]
 9557 044e 0EA3     		adr	r3, .L611
 9558 0450 D3E90023 		ldrd	r2, [r3]
 9559 0454 1C48     		ldr	r0, .L611+64
 9560              	.L599:
 9561 0456 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 9562 045a 01E0     		b	.L593
 9563              	.L543:
 711:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     reportVehicleState();
 9564              		.loc 28 711 0
 9565 045c FFF7FEFF 		bl	_Z18reportVehicleStatev
 9566              	.L593:
 712:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 9567              		.loc 28 712 0
 9568 0460 5823     		movs	r3, #88
 9569 0462 2370     		strb	r3, [r4, #0]
 713:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 9570              		.loc 28 713 0
 9571 0464 0CE0     		b	.L540
 9572              	.L583:
 9573              	.LBE239:
 370:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 9574              		.loc 28 370 0
 9575 0466 0024     		movs	r4, #0
 9576              	.L546:
 9577              	.LBB240:
 9578              	.LBB236:
 717:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 9579              		.loc 28 717 0 discriminator 2
 9580 0468 1B48     		ldr	r0, .L611+80
 9581 046a 2058     		ldr	r0, [r4, r0]
 9582 046c 0434     		adds	r4, r4, #4
 9583 046e FFF7FEFF 		bl	_Z15PrintValueCommai
 716:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 9584              		.loc 28 716 0 discriminator 2
 9585 0472 102C     		cmp	r4, #16
 9586 0474 F8D1     		bne	.L546
 9587              	.LVL399:
 9588              	.L594:
 9589              	.LBE236:
 719:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 9590              		.loc 28 719 0
 9591 0476 1448     		ldr	r0, .L611+64
 9592 0478 FFF7FEFF 		bl	_ZN5Print7printlnEv
 720:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 9593              		.loc 28 720 0
 9594 047c 5821     		movs	r1, #88
 9595 047e 3170     		strb	r1, [r6, #0]
 9596              	.L540:
 9597              	.LBE240:
 9598              	.LBE242:
 733:/home/james/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 9599              		.loc 28 733 0
 9600 0480 03B0     		add	sp, sp, #12
 9601 0482 F0BD     		pop	{r4, r5, r6, r7, pc}
 9602              	.L612:
 9603 0484 AFF30080 		.align	3
 9604              	.L611:
 9605 0488 000000A0 		.word	-1610612736
 9606 048c 99990940 		.word	1074370969
 9607 0490 00000000 		.word	.LANCHOR60
 9608 0494 00000000 		.word	.LANCHOR62
 9609 0498 00000000 		.word	.LANCHOR66
 9610 049c 00000000 		.word	.LANCHOR70
 9611 04a0 00000000 		.word	.LANCHOR61
 9612 04a4 00000000 		.word	.LANCHOR65
 9613 04a8 00000000 		.word	.LANCHOR69
 9614 04ac 00000000 		.word	.LANCHOR63
 9615 04b0 00000000 		.word	.LANCHOR67
 9616 04b4 00000000 		.word	.LANCHOR71
 9617 04b8 00000000 		.word	.LANCHOR64
 9618 04bc 00000000 		.word	.LANCHOR68
 9619 04c0 00000000 		.word	.LANCHOR72
 9620 04c4 00000000 		.word	.LANCHOR13
 9621 04c8 00000000 		.word	SerialUSB
 9622 04cc 00000000 		.word	.LANCHOR33
 9623 04d0 00000000 		.word	.LANCHOR94
 9624 04d4 00000000 		.word	.LANCHOR1
 9625 04d8 00000000 		.word	.LANCHOR56
 9626 04dc 00000000 		.word	.LANCHOR77
 9627              		.cfi_endproc
 9628              	.LFE232:
 9630              		.section	.text._Z5setupv,"ax",%progbits
 9631              		.align	1
 9632              		.global	_Z5setupv
 9633              		.thumb
 9634              		.thumb_func
 9636              	_Z5setupv:
 9637              	.LFB239:
1294:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void setup() {
 9638              		.loc 18 1294 0
 9639              		.cfi_startproc
 9640              		@ args = 0, pretend = 0, frame = 0
 9641              		@ frame_needed = 0, uses_anonymous_args = 0
 9642 0000 10B5     		push	{r4, lr}
 9643              	.LCFI86:
 9644              		.cfi_def_cfa_offset 8
 9645              		.cfi_offset 14, -4
 9646              		.cfi_offset 4, -8
 9647              	.LBB243:
1295:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   SERIAL_BEGIN(BAUD);
 9648              		.loc 18 1295 0
 9649 0002 2C48     		ldr	r0, .L619
 9650 0004 4FF4E131 		mov	r1, #115200
 9651 0008 FFF7FEFF 		bl	_ZN9USBSerial5beginEi
1296:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   pinMode(LED_Green, OUTPUT);
 9652              		.loc 18 1296 0
 9653 000c 4620     		movs	r0, #70
 9654 000e 0021     		movs	r1, #0
 9655 0010 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
1297:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   digitalWrite(LED_Green, LOW);
 9656              		.loc 18 1297 0
 9657 0014 4620     		movs	r0, #70
 9658 0016 0021     		movs	r1, #0
 9659 0018 FFF7FEFF 		bl	_Z12digitalWritehh
1301:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readEEPROM(); // defined in DataStorage.h
 9660              		.loc 18 1301 0
 9661 001c FFF7FEFF 		bl	_Z10readEEPROMv
 9662              	.LVL400:
1303:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (readFloat(SOFTWARE_VERSION_ADR) != SOFTWARE_VERSION) { // If we detect the wrong soft version
 9663              		.loc 18 1303 0
 9664 0020 4FF48A70 		mov	r0, #276
 9665 0024 FFF7FEFF 		bl	_Z12nvrReadFloati
 9666 0028 DFED237A 		flds	s15, .L619+4
 9667 002c 07EE100A 		fmsr	s14, r0
 9668 0030 B4EE677A 		fcmps	s14, s15
 9669 0034 F1EE10FA 		fmstat
 9670 0038 05D0     		beq	.L617
1304:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeEEPROM();
 9671              		.loc 18 1304 0
 9672 003a FFF7FEFF 		bl	_Z16initializeEEPROMv
1306:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     firstTimeBoot = true;
 9673              		.loc 18 1306 0
 9674 003e 0124     		movs	r4, #1
1305:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     writeEEPROM();
 9675              		.loc 18 1305 0
 9676 0040 FFF7FEFF 		bl	_Z11writeEEPROMv
 9677              	.LVL401:
 9678 0044 00E0     		b	.L614
 9679              	.LVL402:
 9680              	.L617:
1302:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   boolean firstTimeBoot = false;
 9681              		.loc 18 1302 0
 9682 0046 0024     		movs	r4, #0
 9683              	.LVL403:
 9684              	.L614:
1309:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initPlatform();
 9685              		.loc 18 1309 0
 9686 0048 FFF7FEFF 		bl	_Z12initPlatformv
1312:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      initializeMotors(FOUR_Motors);
 9687              		.loc 18 1312 0
 9688 004c 0420     		movs	r0, #4
 9689 004e FFF7FEFF 		bl	_Z16initializeMotors9NB_Motors
1319:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeReceiver(LASTCHANNEL);
 9690              		.loc 18 1319 0
 9691 0052 0820     		movs	r0, #8
 9692 0054 FFF7FEFF 		bl	_Z18initializeReceiveri
1320:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initReceiverFromEEPROM();
 9693              		.loc 18 1320 0
 9694 0058 FFF7FEFF 		bl	_Z22initReceiverFromEEPROMv
1325:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeGyro(); // defined in Gyro.h
 9695              		.loc 18 1325 0
 9696 005c FFF7FEFF 		bl	_Z14initializeGyrov
 9697              	.L615:
1326:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   while (!calibrateGyro()); // this make sure the craft is still befor to continue init process
 9698              		.loc 18 1326 0 discriminator 1
 9699 0060 FFF7FEFF 		bl	_Z13calibrateGyrov
 9700 0064 0028     		cmp	r0, #0
 9701 0066 FBD0     		beq	.L615
1327:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeAccel(); // defined in Accel.h
 9702              		.loc 18 1327 0
 9703 0068 FFF7FEFF 		bl	_Z15initializeAccelv
1328:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (firstTimeBoot) {
 9704              		.loc 18 1328 0
 9705 006c 1CB1     		cbz	r4, .L616
1329:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     computeAccelBias();
 9706              		.loc 18 1329 0
 9707 006e FFF7FEFF 		bl	_Z16computeAccelBiasv
1330:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     writeEEPROM();
 9708              		.loc 18 1330 0
 9709 0072 FFF7FEFF 		bl	_Z11writeEEPROMv
 9710              	.L616:
1332:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   setupFourthOrder();
 9711              		.loc 18 1332 0
 9712 0076 FFF7FEFF 		bl	_Z16setupFourthOrderv
1333:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initSensorsZeroFromEEPROM();
 9713              		.loc 18 1333 0
 9714 007a FFF7FEFF 		bl	_Z25initSensorsZeroFromEEPROMv
1339:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PID[ATTITUDE_XAXIS_PID_IDX].windupGuard = 0.375;
 9715              		.loc 18 1339 0
 9716 007e 0F48     		ldr	r0, .L619+8
 9717 0080 4FF07B51 		mov	r1, #1052770304
 9718 0084 C166     		str	r1, [r0, #108]	@ float
1340:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PID[ATTITUDE_YAXIS_PID_IDX].windupGuard = 0.375;
 9719              		.loc 18 1340 0
 9720 0086 C0F88810 		str	r1, [r0, #136]	@ float
1343:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeKinematics();
 9721              		.loc 18 1343 0
 9722 008a FFF7FEFF 		bl	_Z20initializeKinematicsv
1371:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeCameraStabilization();
 9723              		.loc 18 1371 0
 9724 008e FFF7FEFF 		bl	_Z29initializeCameraStabilizationv
1372:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= CAMERASTABLE_ENABLED;
 9725              		.loc 18 1372 0
 9726 0092 0B4B     		ldr	r3, .L619+12
 9727 0094 1A68     		ldr	r2, [r3, #0]
 9728 0096 42F08000 		orr	r0, r2, #128
 9729 009a 1860     		str	r0, [r3, #0]
1402:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   previousTime = micros();
 9730              		.loc 18 1402 0
 9731 009c FFF7FEFF 		bl	_ZL6microsv
 9732 00a0 0849     		ldr	r1, .L619+16
 9733 00a2 0860     		str	r0, [r1, #0]
1403:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   digitalWrite(LED_Green, HIGH);
 9734              		.loc 18 1403 0
 9735 00a4 4620     		movs	r0, #70
 9736 00a6 0121     		movs	r1, #1
 9737 00a8 FFF7FEFF 		bl	_Z12digitalWritehh
1404:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   safetyCheck = 0;
 9738              		.loc 18 1404 0
 9739 00ac 064B     		ldr	r3, .L619+20
 9740 00ae 0022     		movs	r2, #0
 9741 00b0 1A70     		strb	r2, [r3, #0]
 9742              	.LBE243:
1405:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 9743              		.loc 18 1405 0
 9744 00b2 10BD     		pop	{r4, pc}
 9745              	.L620:
 9746              		.align	2
 9747              	.L619:
 9748 00b4 00000000 		.word	SerialUSB
 9749 00b8 CDCC4C40 		.word	1078774989
 9750 00bc 00000000 		.word	.LANCHOR9
 9751 00c0 00000000 		.word	.LANCHOR13
 9752 00c4 00000000 		.word	.LANCHOR102
 9753 00c8 00000000 		.word	.LANCHOR82
 9754              		.cfi_endproc
 9755              	.LFE239:
 9757              		.section	.text._Z16process100HzTaskv,"ax",%progbits
 9758              		.align	1
 9759              		.global	_Z16process100HzTaskv
 9760              		.thumb
 9761              		.thumb_func
 9763              	_Z16process100HzTaskv:
 9764              	.LFB240:
1411:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process100HzTask() {
 9765              		.loc 18 1411 0
 9766              		.cfi_startproc
 9767              		@ args = 0, pretend = 0, frame = 0
 9768              		@ frame_needed = 0, uses_anonymous_args = 0
 9769 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 9770              	.LCFI87:
 9771              		.cfi_def_cfa_offset 20
 9772              		.cfi_offset 14, -4
 9773              		.cfi_offset 7, -8
 9774              		.cfi_offset 6, -12
 9775              		.cfi_offset 5, -16
 9776              		.cfi_offset 4, -20
 9777              	.LBB244:
1413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 9778              		.loc 18 1413 0
 9779 0002 214B     		ldr	r3, .L624
 9780 0004 214C     		ldr	r4, .L624+4
 9781 0006 1868     		ldr	r0, [r3, #0]
 9782 0008 2268     		ldr	r2, [r4, #0]
 9783 000a 214F     		ldr	r7, .L624+8
1414:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hundredHZpreviousTime = currentTime;
 9784              		.loc 18 1414 0
 9785 000c 1A60     		str	r2, [r3, #0]
1413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 9786              		.loc 18 1413 0
 9787 000e 111A     		subs	r1, r2, r0
 9788 0010 00EE101A 		fmsr	s0, r1	@ int
 9789 0014 DFED1F7A 		flds	s15, .L624+12
 9790 0018 B8EE407A 		fuitos	s14, s0
 9791              	.LBE244:
1411:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process100HzTask() {
 9792              		.loc 18 1411 0
 9793 001c 85B0     		sub	sp, sp, #20
 9794              	.LCFI88:
 9795              		.cfi_def_cfa_offset 40
 9796              	.LBB246:
1413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 9797              		.loc 18 1413 0
 9798 001e C7EE277A 		fdivs	s15, s14, s15
1417:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateMetersPerSec();
 9799              		.loc 18 1417 0
 9800 0022 1D4E     		ldr	r6, .L624+16
 9801 0024 1D4D     		ldr	r5, .L624+20
1419:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 9802              		.loc 18 1419 0
 9803 0026 0024     		movs	r4, #0
1413:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 9804              		.loc 18 1413 0
 9805 0028 C7ED007A 		fsts	s15, [r7, #0]
1416:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateGyroRate();
 9806              		.loc 18 1416 0
 9807 002c FFF7FEFF 		bl	_Z16evaluateGyroRatev
1417:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateMetersPerSec();
 9808              		.loc 18 1417 0
 9809 0030 FFF7FEFF 		bl	_Z20evaluateMetersPerSecv
 9810              	.LVL404:
 9811              	.L622:
 9812              	.LBB245:
1420:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
 9813              		.loc 18 1420 0 discriminator 2
 9814 0034 1A4A     		ldr	r2, .L624+24
 9815 0036 56F8040F 		ldr	r0, [r6, #4]!	@ float
 9816 003a 6301     		lsls	r3, r4, #5
 9817 003c D118     		adds	r1, r2, r3
 9818 003e FFF7FEFF 		bl	_Z18computeFourthOrderfP15fourthOrderData
1419:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 9819              		.loc 18 1419 0 discriminator 2
 9820 0042 0134     		adds	r4, r4, #1
 9821              	.LVL405:
 9822 0044 032C     		cmp	r4, #3
1420:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
 9823              		.loc 18 1420 0 discriminator 2
 9824 0046 45F8040F 		str	r0, [r5, #4]!	@ float
1419:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 9825              		.loc 18 1419 0 discriminator 2
 9826 004a F3D1     		bne	.L622
 9827              	.LBE245:
1423:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   calculateKinematics(gyroRate[XAXIS], gyroRate[YAXIS], gyroRate[ZAXIS], filteredAccel[XAXIS], filt
 9828              		.loc 18 1423 0
 9829 004c 154B     		ldr	r3, .L624+28
 9830 004e 164A     		ldr	r2, .L624+32
 9831 0050 5968     		ldr	r1, [r3, #4]	@ float
 9832 0052 0091     		str	r1, [sp, #0]	@ float
 9833 0054 D3F808E0 		ldr	lr, [r3, #8]	@ float
 9834 0058 CDF804E0 		str	lr, [sp, #4]	@ float
 9835 005c D7F800C0 		ldr	ip, [r7, #0]	@ float
 9836 0060 CDF808C0 		str	ip, [sp, #8]	@ float
 9837 0064 1068     		ldr	r0, [r2, #0]	@ float
 9838 0066 5168     		ldr	r1, [r2, #4]	@ float
 9839 0068 1B68     		ldr	r3, [r3, #0]	@ float
 9840 006a 9268     		ldr	r2, [r2, #8]	@ float
 9841 006c FFF7FEFF 		bl	_Z19calculateKinematicsfffffff
1442:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   processFlightControl();
 9842              		.loc 18 1442 0
 9843 0070 FFF7FEFF 		bl	_Z20processFlightControlv
1461:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     moveCamera(kinematicsAngle[YAXIS],kinematicsAngle[XAXIS],kinematicsAngle[ZAXIS]);
 9844              		.loc 18 1461 0
 9845 0074 0D4A     		ldr	r2, .L624+36
 9846 0076 5068     		ldr	r0, [r2, #4]	@ float
 9847 0078 1168     		ldr	r1, [r2, #0]	@ float
 9848 007a 9268     		ldr	r2, [r2, #8]	@ float
 9849              	.LBE246:
1467:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 9850              		.loc 18 1467 0
 9851 007c 05B0     		add	sp, sp, #20
 9852 007e BDE8F040 		pop	{r4, r5, r6, r7, lr}
 9853              	.LBB247:
1461:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     moveCamera(kinematicsAngle[YAXIS],kinematicsAngle[XAXIS],kinematicsAngle[ZAXIS]);
 9854              		.loc 18 1461 0
 9855 0082 FFF7FEBF 		b	_Z10moveCamerafff
 9856              	.L625:
 9857 0086 00BF     		.align	2
 9858              	.L624:
 9859 0088 00000000 		.word	.LANCHOR103
 9860 008c 00000000 		.word	.LANCHOR7
 9861 0090 00000000 		.word	.LANCHOR48
 9862 0094 00247449 		.word	1232348160
 9863 0098 FCFFFFFF 		.word	.LANCHOR26-4
 9864 009c FCFFFFFF 		.word	.LANCHOR101-4
 9865 00a0 00000000 		.word	.LANCHOR10
 9866 00a4 00000000 		.word	.LANCHOR101
 9867 00a8 00000000 		.word	.LANCHOR19
 9868 00ac 00000000 		.word	.LANCHOR33
 9869              	.LBE247:
 9870              		.cfi_endproc
 9871              	.LFE240:
 9873              		.section	.text._Z15process50HzTaskv,"ax",%progbits
 9874              		.align	1
 9875              		.global	_Z15process50HzTaskv
 9876              		.thumb
 9877              		.thumb_func
 9879              	_Z15process50HzTaskv:
 9880              	.LFB241:
1472:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process50HzTask() {
 9881              		.loc 18 1472 0
 9882              		.cfi_startproc
 9883              		@ args = 0, pretend = 0, frame = 0
 9884              		@ frame_needed = 0, uses_anonymous_args = 0
 9885              		@ link register save eliminated.
1473:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 9886              		.loc 18 1473 0
 9887 0000 094B     		ldr	r3, .L627
 9888 0002 0A4A     		ldr	r2, .L627+4
 9889 0004 1968     		ldr	r1, [r3, #0]
 9890 0006 1268     		ldr	r2, [r2, #0]
 9891 0008 501A     		subs	r0, r2, r1
 9892 000a 00EE100A 		fmsr	s0, r0	@ int
 9893 000e DFED087A 		flds	s15, .L627+8
 9894 0012 B8EE407A 		fuitos	s14, s0
 9895 0016 0749     		ldr	r1, .L627+12
1474:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   fiftyHZpreviousTime = currentTime;
 9896              		.loc 18 1474 0
 9897 0018 1A60     		str	r2, [r3, #0]
1473:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 9898              		.loc 18 1473 0
 9899 001a C7EE277A 		fdivs	s15, s14, s15
 9900 001e C1ED007A 		fsts	s15, [r1, #0]
1492:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 9901              		.loc 18 1492 0
1477:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readPilotCommands(); 
 9902              		.loc 18 1477 0
 9903 0022 FFF7FEBF 		b	_Z17readPilotCommandsv
 9904              	.L628:
 9905 0026 00BF     		.align	2
 9906              	.L627:
 9907 0028 00000000 		.word	.LANCHOR104
 9908 002c 00000000 		.word	.LANCHOR7
 9909 0030 00247449 		.word	1232348160
 9910 0034 00000000 		.word	.LANCHOR48
 9911              		.cfi_endproc
 9912              	.LFE241:
 9914              		.section	.text._Z16process10HzTask1v,"ax",%progbits
 9915              		.align	1
 9916              		.global	_Z16process10HzTask1v
 9917              		.thumb
 9918              		.thumb_func
 9920              	_Z16process10HzTask1v:
 9921              	.LFB242:
1497:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask1() {
 9922              		.loc 18 1497 0
 9923              		.cfi_startproc
 9924              		@ args = 0, pretend = 0, frame = 0
 9925              		@ frame_needed = 0, uses_anonymous_args = 0
 9926              		@ link register save eliminated.
1509:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 9927              		.loc 18 1509 0
 9928 0000 7047     		bx	lr
 9929              		.cfi_endproc
 9930              	.LFE242:
 9932              		.section	.text._Z16process10HzTask2v,"ax",%progbits
 9933              		.align	1
 9934              		.global	_Z16process10HzTask2v
 9935              		.thumb
 9936              		.thumb_func
 9938              	_Z16process10HzTask2v:
 9939              	.LFB243:
1514:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask2() {
 9940              		.loc 18 1514 0
 9941              		.cfi_startproc
 9942              		@ args = 0, pretend = 0, frame = 0
 9943              		@ frame_needed = 0, uses_anonymous_args = 0
 9944 0000 08B5     		push	{r3, lr}
 9945              	.LCFI89:
 9946              		.cfi_def_cfa_offset 8
 9947              		.cfi_offset 14, -4
 9948              		.cfi_offset 3, -8
1515:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 9949              		.loc 18 1515 0
 9950 0002 0B4A     		ldr	r2, .L631
 9951 0004 0B4B     		ldr	r3, .L631+4
 9952 0006 1268     		ldr	r2, [r2, #0]
 9953 0008 1968     		ldr	r1, [r3, #0]
1516:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   lowPriorityTenHZpreviousTime = currentTime;
 9954              		.loc 18 1516 0
 9955 000a 1A60     		str	r2, [r3, #0]
1515:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 9956              		.loc 18 1515 0
 9957 000c 501A     		subs	r0, r2, r1
 9958 000e 00EE100A 		fmsr	s0, r0	@ int
 9959 0012 DFED097A 		flds	s15, .L631+8
 9960 0016 B8EE407A 		fuitos	s14, s0
 9961 001a 0849     		ldr	r1, .L631+12
 9962 001c C7EE277A 		fdivs	s15, s14, s15
 9963 0020 C1ED007A 		fsts	s15, [r1, #0]
1523:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readSerialCommand();
 9964              		.loc 18 1523 0
 9965 0024 FFF7FEFF 		bl	_Z17readSerialCommandv
1525:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 9966              		.loc 18 1525 0
 9967 0028 BDE80840 		pop	{r3, lr}
1524:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   sendSerialTelemetry();
 9968              		.loc 18 1524 0
 9969 002c FFF7FEBF 		b	_Z19sendSerialTelemetryv
 9970              	.L632:
 9971              		.align	2
 9972              	.L631:
 9973 0030 00000000 		.word	.LANCHOR7
 9974 0034 00000000 		.word	.LANCHOR105
 9975 0038 00247449 		.word	1232348160
 9976 003c 00000000 		.word	.LANCHOR48
 9977              		.cfi_endproc
 9978              	.LFE243:
 9980              		.section	.text._Z16process10HzTask3v,"ax",%progbits
 9981              		.align	1
 9982              		.global	_Z16process10HzTask3v
 9983              		.thumb
 9984              		.thumb_func
 9986              	_Z16process10HzTask3v:
 9987              	.LFB244:
1530:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask3() {
 9988              		.loc 18 1530 0
 9989              		.cfi_startproc
 9990              		@ args = 0, pretend = 0, frame = 0
 9991              		@ frame_needed = 0, uses_anonymous_args = 0
 9992              		@ link register save eliminated.
1531:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 9993              		.loc 18 1531 0
 9994 0000 084B     		ldr	r3, .L634
 9995 0002 094A     		ldr	r2, .L634+4
 9996 0004 1968     		ldr	r1, [r3, #0]
 9997 0006 1268     		ldr	r2, [r2, #0]
 9998 0008 501A     		subs	r0, r2, r1
 9999 000a 00EE100A 		fmsr	s0, r0	@ int
 10000 000e DFED077A 		flds	s15, .L634+8
 10001 0012 B8EE407A 		fuitos	s14, s0
 10002 0016 0649     		ldr	r1, .L634+12
1532:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     lowPriorityTenHZpreviousTime2 = currentTime;
 10003              		.loc 18 1532 0
 10004 0018 1A60     		str	r2, [r3, #0]
1531:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 10005              		.loc 18 1531 0
 10006 001a C7EE277A 		fdivs	s15, s14, s15
 10007 001e C1ED007A 		fsts	s15, [r1, #0]
1549:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 10008              		.loc 18 1549 0
 10009 0022 7047     		bx	lr
 10010              	.L635:
 10011              		.align	2
 10012              	.L634:
 10013 0024 00000000 		.word	.LANCHOR106
 10014 0028 00000000 		.word	.LANCHOR7
 10015 002c 00247449 		.word	1232348160
 10016 0030 00000000 		.word	.LANCHOR48
 10017              		.cfi_endproc
 10018              	.LFE244:
 10020              		.section	.text._Z14process1HzTaskv,"ax",%progbits
 10021              		.align	1
 10022              		.global	_Z14process1HzTaskv
 10023              		.thumb
 10024              		.thumb_func
 10026              	_Z14process1HzTaskv:
 10027              	.LFB245:
1554:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process1HzTask() {
 10028              		.loc 18 1554 0
 10029              		.cfi_startproc
 10030              		@ args = 0, pretend = 0, frame = 0
 10031              		@ frame_needed = 0, uses_anonymous_args = 0
 10032              		@ link register save eliminated.
1561:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 10033              		.loc 18 1561 0
 10034 0000 7047     		bx	lr
 10035              		.cfi_endproc
 10036              	.LFE245:
 10038              		.section	.text._Z4loopv,"ax",%progbits
 10039              		.align	1
 10040              		.global	_Z4loopv
 10041              		.thumb
 10042              		.thumb_func
 10044              	_Z4loopv:
 10045              	.LFB246:
1566:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void loop () {
 10046              		.loc 18 1566 0
 10047              		.cfi_startproc
 10048              		@ args = 0, pretend = 0, frame = 0
 10049              		@ frame_needed = 0, uses_anonymous_args = 0
 10050 0000 70B5     		push	{r4, r5, r6, lr}
 10051              	.LCFI90:
 10052              		.cfi_def_cfa_offset 16
 10053              		.cfi_offset 14, -4
 10054              		.cfi_offset 6, -8
 10055              		.cfi_offset 5, -12
 10056              		.cfi_offset 4, -16
1569:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 10057              		.loc 18 1569 0
 10058 0002 1F4C     		ldr	r4, .L643
1568:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   currentTime = micros();
 10059              		.loc 18 1568 0
 10060 0004 1F4D     		ldr	r5, .L643+4
1569:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 10061              		.loc 18 1569 0
 10062 0006 204E     		ldr	r6, .L643+8
1568:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   currentTime = micros();
 10063              		.loc 18 1568 0
 10064 0008 FFF7FEFF 		bl	_ZL6microsv
1569:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 10065              		.loc 18 1569 0
 10066 000c 2168     		ldr	r1, [r4, #0]
1568:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   currentTime = micros();
 10067              		.loc 18 1568 0
 10068 000e 2860     		str	r0, [r5, #0]
1569:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 10069              		.loc 18 1569 0
 10070 0010 401A     		subs	r0, r0, r1
 10071 0012 3060     		str	r0, [r6, #0]
1571:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   measureCriticalSensors();
 10072              		.loc 18 1571 0
 10073 0014 FFF7FEFF 		bl	_Z22measureCriticalSensorsv
1576:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (deltaTime >= 10000) {
 10074              		.loc 18 1576 0
 10075 0018 3268     		ldr	r2, [r6, #0]
 10076 001a 42F20F73 		movw	r3, #9999
 10077 001e 9A42     		cmp	r2, r3
 10078 0020 2646     		mov	r6, r4
 10079 0022 1A4C     		ldr	r4, .L643+12
 10080 0024 24D9     		bls	.L638
1578:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     frameCounter++;
 10081              		.loc 18 1578 0
 10082 0026 2068     		ldr	r0, [r4, #0]
 10083 0028 431C     		adds	r3, r0, #1
 10084 002a 2360     		str	r3, [r4, #0]
1580:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     process100HzTask();
 10085              		.loc 18 1580 0
 10086 002c FFF7FEFF 		bl	_Z16process100HzTaskv
1585:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_50HZ == 0) {  //  50 Hz tasks
 10087              		.loc 18 1585 0
 10088 0030 2268     		ldr	r2, [r4, #0]
 10089 0032 D207     		lsls	r2, r2, #31
 10090 0034 01D4     		bmi	.L639
1586:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process50HzTask();
 10091              		.loc 18 1586 0
 10092 0036 FFF7FEFF 		bl	_Z15process50HzTaskv
 10093              	.L639:
1592:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_10HZ == 0) {  //   10 Hz tasks
 10094              		.loc 18 1592 0
 10095 003a 2268     		ldr	r2, [r4, #0]
 10096 003c 0A23     		movs	r3, #10
 10097 003e B2FBF3F0 		udiv	r0, r2, r3
 10098 0042 03FB1021 		mls	r1, r3, r0, r2
 10099 0046 89B1     		cbz	r1, .L640
1595:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime) > 100000) {
 10100              		.loc 18 1595 0
 10101 0048 114B     		ldr	r3, .L643+16
 10102 004a 2A68     		ldr	r2, [r5, #0]
 10103 004c 1968     		ldr	r1, [r3, #0]
 10104 004e 114B     		ldr	r3, .L643+20
 10105 0050 C1EB020C 		rsb	ip, r1, r2
 10106 0054 9C45     		cmp	ip, r3
 10107 0056 02D9     		bls	.L641
1596:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask2();
 10108              		.loc 18 1596 0
 10109 0058 FFF7FEFF 		bl	_Z16process10HzTask2v
 10110 005c 06E0     		b	.L640
 10111              	.L641:
1598:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime2) > 100000) {
 10112              		.loc 18 1598 0
 10113 005e 0E48     		ldr	r0, .L643+24
 10114 0060 0168     		ldr	r1, [r0, #0]
 10115 0062 501A     		subs	r0, r2, r1
 10116 0064 9842     		cmp	r0, r3
 10117 0066 01D9     		bls	.L640
1599:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask3();
 10118              		.loc 18 1599 0
 10119 0068 FFF7FEFF 		bl	_Z16process10HzTask3v
 10120              	.L640:
1609:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     previousTime = currentTime;
 10121              		.loc 18 1609 0
 10122 006c 2A68     		ldr	r2, [r5, #0]
 10123 006e 3260     		str	r2, [r6, #0]
 10124              	.L638:
1612:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (frameCounter >= 100) {
 10125              		.loc 18 1612 0
 10126 0070 2368     		ldr	r3, [r4, #0]
 10127 0072 632B     		cmp	r3, #99
 10128 0074 02D9     		bls	.L637
1613:/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       frameCounter = 0;
 10129              		.loc 18 1613 0
 10130 0076 0548     		ldr	r0, .L643+12
 10131 0078 0021     		movs	r1, #0
 10132 007a 0160     		str	r1, [r0, #0]
 10133              	.L637:
 10134 007c 70BD     		pop	{r4, r5, r6, pc}
 10135              	.L644:
 10136 007e 00BF     		.align	2
 10137              	.L643:
 10138 0080 00000000 		.word	.LANCHOR102
 10139 0084 00000000 		.word	.LANCHOR7
 10140 0088 00000000 		.word	.LANCHOR107
 10141 008c 00000000 		.word	.LANCHOR93
 10142 0090 00000000 		.word	.LANCHOR105
 10143 0094 A0860100 		.word	100000
 10144 0098 00000000 		.word	.LANCHOR106
 10145              		.cfi_endproc
 10146              	.LFE246:
 10148              		.section	.text.startup.main,"ax",%progbits
 10149              		.align	1
 10150              		.global	main
 10151              		.thumb
 10152              		.thumb_func
 10154              	main:
 10155              	.LFB116:
  11:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** }
  12:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
  13:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** // Uncomment this if compiling on OS X
  14:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** /*extern "C"{
  15:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 	void _init(){}; // dummy _init function for support of GNU toolchain from https://launchpad.net/gc
  16:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** }*/
  17:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
  18:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** int main(void)
  19:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** {
 10156              		.loc 5 19 0
 10157              		.cfi_startproc
 10158              		@ args = 0, pretend = 0, frame = 0
 10159              		@ frame_needed = 0, uses_anonymous_args = 0
 10160 0000 08B5     		push	{r3, lr}
 10161              	.LCFI91:
 10162              		.cfi_def_cfa_offset 8
 10163              		.cfi_offset 14, -4
 10164              		.cfi_offset 3, -8
  20:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 	//init();
  21:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp ****   	setup();
 10165              		.loc 5 21 0
 10166 0002 FFF7FEFF 		bl	_Z5setupv
 10167              	.L646:
  22:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
  23:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 	for (;;)
  24:/home/james/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 		loop();
 10168              		.loc 5 24 0 discriminator 1
 10169 0006 FFF7FEFF 		bl	_Z4loopv
 10170 000a FCE7     		b	.L646
 10171              		.cfi_endproc
 10172              	.LFE116:
 10174              		.section	.text.startup._GLOBAL__sub_I__Z7premainv,"ax",%progbits
 10175              		.align	1
 10176              		.thumb
 10177              		.thumb_func
 10179              	_GLOBAL__sub_I__Z7premainv:
 10180              	.LFB248:
 10181              		.loc 18 1615 0
 10182              		.cfi_startproc
 10183              		@ args = 0, pretend = 0, frame = 0
 10184              		@ frame_needed = 0, uses_anonymous_args = 0
 10185              	.LVL406:
 10186 0000 08B5     		push	{r3, lr}
 10187              	.LCFI92:
 10188              		.cfi_def_cfa_offset 8
 10189              		.cfi_offset 14, -4
 10190              		.cfi_offset 3, -8
 10191              	.LBB250:
 10192              	.LBB251:
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   HardwareSPIExt spiMPU6000(4);
 10193              		.loc 10 116 0
 10194 0002 0421     		movs	r1, #4
 10195 0004 0348     		ldr	r0, .L648
 10196 0006 FFF7FEFF 		bl	_ZN14HardwareSPIExtC1Ej
  27:/home/james/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** unsigned long headingTime = micros();
 10197              		.loc 24 27 0
 10198 000a FFF7FEFF 		bl	_ZL6microsv
 10199 000e 024B     		ldr	r3, .L648+4
 10200 0010 1860     		str	r0, [r3, #0]
 10201              	.LBE251:
 10202              	.LBE250:
 10203              		.loc 18 1615 0
 10204 0012 08BD     		pop	{r3, pc}
 10205              	.L649:
 10206              		.align	2
 10207              	.L648:
 10208 0014 00000000 		.word	.LANCHOR11
 10209 0018 00000000 		.word	.LANCHOR92
 10210              		.cfi_endproc
 10211              	.LFE248:
 10213              		.section	.init_array,"aw",%init_array
 10214              		.align	2
 10215 0004 00000000 		.word	_GLOBAL__sub_I__Z7premainv(target1)
 10216              		.global	queryType
 10217              		.global	headingTime
 10218              		.global	setHeading
 10219              		.global	motorConfiguratorCommand
 10220              		.global	motorMinCommand
 10221              		.global	motorMaxCommand
 10222              		.global	motorAxisCommandYaw
 10223              		.global	motorAxisCommandPitch
 10224              		.global	motorAxisCommandRoll
 10225              		.global	servoMaxYaw
 10226              		.global	servoMaxRoll
 10227              		.global	servoMaxPitch
 10228              		.global	servoMinYaw
 10229              		.global	servoMinRoll
 10230              		.global	servoMinPitch
 10231              		.global	servoCenterYaw
 10232              		.global	servoCenterRoll
 10233              		.global	servoCenterPitch
 10234              		.global	mCameraYaw
 10235              		.global	mCameraRoll
 10236              		.global	mCameraPitch
 10237              		.global	cameraMode
 10238              		.global	motorCommand
 10239              		.global	numberOfMotors
 10240              		.global	PWM_in_handler
 10241              		.global	FrqData
 10242              		.global	previousEz
 10243              		.global	previousEy
 10244              		.global	previousEx
 10245              		.global	ezInt
 10246              		.global	eyInt
 10247              		.global	exInt
 10248              		.global	q3
 10249              		.global	q2
 10250              		.global	q1
 10251              		.global	q0
 10252              		.global	halfT
 10253              		.global	Ki
 10254              		.global	Kp
 10255              		.global	accelCutoff
 10256              		.global	earthAccel
 10257              		.global	correctedRateVector
 10258              		.global	gyroAngle
 10259              		.global	kinematicsAngle
 10260              		.global	kinematicsType
 10261              		.global	previousMeasureCriticalSensorsTime
 10262              		.global	accelSampleCount
 10263              		.global	accelSample
 10264              		.global	meterPerSecSec
 10265              		.global	accelOneG
 10266              		.global	runTimeAccelBias
 10267              		.global	accelScaleFactor
 10268              		.global	gyroSampleCount
 10269              		.global	gyroLastMesuredTime
 10270              		.global	gyroHeading
 10271              		.global	gyroScaleFactor
 10272              		.global	gyroSample
 10273              		.global	gyroZero
 10274              		.global	gyroRate
 10275              		.global	readMPU6000GyroCount
 10276              		.global	readMPU6000AccelCount
 10277              		.global	readMPU6000Count
 10278              		.global	initializeMPU6000SensorsDone
 10279              		.global	spiMPU6000
 10280              		.global	MPU6000
 10281              		.global	vehicleState
 10282              		.global	gyroRaw
 10283              		.global	Serial
 10284              		.global	fourthOrder
 10285              		.global	windupGuard
 10286              		.global	PID
 10287              		.global	fastTransfer
 10288              		.global	headingHoldState
 10289              		.global	relativeHeading
 10290              		.global	heading
 10291              		.global	headingHold
 10292              		.global	headingHoldConfig
 10293              		.global	aref
 10294              		.global	hundredHZpreviousTime
 10295              		.global	fiftyHZpreviousTime
 10296              		.global	lowPriorityTenHZpreviousTime2
 10297              		.global	lowPriorityTenHZpreviousTime
 10298              		.global	tenHZpreviousTime
 10299              		.global	oneHZpreviousTime
 10300              		.global	deltaTime
 10301              		.global	currentTime
 10302              		.global	previousTime
 10303              		.global	rotationSpeedFactor
 10304              		.global	inFlight
 10305              		.global	filteredAccel
 10306              		.global	minLimit
 10307              		.global	maxLimit
 10308              		.global	safetyCheck
 10309              		.global	motorArmed
 10310              		.global	throttle
 10311              		.global	G_Dt
 10312              		.global	minArmedThrottle
 10313              		.global	frameCounter
 10314              		.global	flightMode
 10315              		.global	previousFlightMode
 10316              		.global	testCommand
 10317              		.global	calibrateESC
 10318              		.global	channelCal
 10319              		.global	receiverSmoothFactor
 10320              		.global	receiverOffset
 10321              		.global	receiverSlope
 10322              		.global	receiverCommandSmooth
 10323              		.global	receiverCommand
 10324              		.global	receiverZero
 10325              		.global	receiverData
 10326              		.global	receiverXmitFactor
 10327              		.global	lastReceiverChannel
 10328              		.weak	_ZN14HardwareSPIExtC1Ej
 10329              		.thumb_set _ZN14HardwareSPIExtC1Ej,_ZN14HardwareSPIExtC2Ej
 10330              		.section	.bss.servoMinRoll,"aw",%nobits
 10331              		.align	2
 10332              		.set	.LANCHOR67,. + 0
 10335              	servoMinRoll:
 10336 0000 00000000 		.space	4
 10337              		.section	.bss.mCameraYaw,"aw",%nobits
 10338              		.align	2
 10339              		.set	.LANCHOR69,. + 0
 10342              	mCameraYaw:
 10343 0000 00000000 		.space	4
 10344              		.section	.bss.MPU6000,"aw",%nobits
 10345              		.align	1
 10346              		.set	.LANCHOR14,. + 0
 10349              	MPU6000:
 10350 0000 00000000 		.space	14
 10350      00000000 
 10350      00000000 
 10350      0000
 10351              		.section	.bss.receiverData,"aw",%nobits
 10352              		.align	2
 10353              		.set	.LANCHOR54,. + 0
 10356              	receiverData:
 10357 0000 00000000 		.space	40
 10357      00000000 
 10357      00000000 
 10357      00000000 
 10357      00000000 
 10358              		.section	.bss.motorArmed,"aw",%nobits
 10359              		.set	.LANCHOR94,. + 0
 10362              	motorArmed:
 10363 0000 00       		.space	1
 10364              		.section	.bss.mCameraPitch,"aw",%nobits
 10365              		.align	2
 10366              		.set	.LANCHOR61,. + 0
 10369              	mCameraPitch:
 10370 0000 00000000 		.space	4
 10371              		.section	.bss.servoMaxRoll,"aw",%nobits
 10372              		.align	2
 10373              		.set	.LANCHOR68,. + 0
 10376              	servoMaxRoll:
 10377 0000 00000000 		.space	4
 10378              		.section	.bss.motorMinCommand,"aw",%nobits
 10379              		.align	2
 10380              		.set	.LANCHOR84,. + 0
 10383              	motorMinCommand:
 10384 0000 00000000 		.space	16
 10384      00000000 
 10384      00000000 
 10384      00000000 
 10385              		.section	.bss.gyroHeading,"aw",%nobits
 10386              		.align	2
 10387              		.set	.LANCHOR20,. + 0
 10390              	gyroHeading:
 10391 0000 00000000 		.space	4
 10392              		.section	.bss.filteredAccel,"aw",%nobits
 10393              		.align	2
 10394              		.set	.LANCHOR101,. + 0
 10397              	filteredAccel:
 10398 0000 00000000 		.space	12
 10398      00000000 
 10398      00000000 
 10399              		.section	.data.PWM_in_handler,"aw",%progbits
 10400              		.align	2
 10401              		.set	.LANCHOR52,. + 0
 10404              	PWM_in_handler:
 10405 0000 00000000 		.word	_Z8PWM_in_0v
 10406 0004 00000000 		.word	_Z8PWM_in_1v
 10407 0008 00000000 		.word	_Z8PWM_in_2v
 10408 000c 00000000 		.word	_Z8PWM_in_3v
 10409 0010 00000000 		.word	_Z8PWM_in_4v
 10410 0014 00000000 		.word	_Z8PWM_in_5v
 10411 0018 00000000 		.word	_Z8PWM_in_6v
 10412 001c 00000000 		.word	_Z8PWM_in_7v
 10413              		.section	.data.rotationSpeedFactor,"aw",%progbits
 10414              		.align	2
 10415              		.set	.LANCHOR78,. + 0
 10418              	rotationSpeedFactor:
 10419 0000 0000803F 		.word	1065353216
 10420              		.section	.bss.motorAxisCommandPitch,"aw",%nobits
 10421              		.align	2
 10422              		.set	.LANCHOR74,. + 0
 10425              	motorAxisCommandPitch:
 10426 0000 00000000 		.space	4
 10427              		.section	.bss.receiverSmoothFactor,"aw",%nobits
 10428              		.align	2
 10429              		.set	.LANCHOR6,. + 0
 10432              	receiverSmoothFactor:
 10433 0000 00000000 		.space	40
 10433      00000000 
 10433      00000000 
 10433      00000000 
 10433      00000000 
 10434              		.section	.bss.FrqData,"aw",%nobits
 10435              		.align	2
 10436              		.set	.LANCHOR51,. + 0
 10439              	FrqData:
 10440 0000 00000000 		.space	384
 10440      00000000 
 10440      00000000 
 10440      00000000 
 10440      00000000 
 10441              		.section	.bss.readMPU6000Count,"aw",%nobits
 10442              		.align	2
 10443              		.set	.LANCHOR16,. + 0
 10446              	readMPU6000Count:
 10447 0000 00000000 		.space	4
 10448              		.section	.bss.tenHZpreviousTime,"aw",%nobits
 10449              		.align	2
 10452              	tenHZpreviousTime:
 10453 0000 00000000 		.space	4
 10454              		.section	.bss.previousEz,"aw",%nobits
 10455              		.align	2
 10456              		.set	.LANCHOR46,. + 0
 10459              	previousEz:
 10460 0000 00000000 		.space	4
 10461              		.section	.bss.servoCenterRoll,"aw",%nobits
 10462              		.align	2
 10463              		.set	.LANCHOR66,. + 0
 10466              	servoCenterRoll:
 10467 0000 00000000 		.space	4
 10468              		.section	.bss.previousMeasureCriticalSensorsTime,"aw",%nobits
 10469              		.align	2
 10470              		.set	.LANCHOR32,. + 0
 10473              	previousMeasureCriticalSensorsTime:
 10474 0000 00000000 		.space	4
 10475              		.section	.data.queryType,"aw",%progbits
 10476              		.set	.LANCHOR98,. + 0
 10479              	queryType:
 10480 0000 58       		.byte	88
 10481              		.section	.bss.servoCenterPitch,"aw",%nobits
 10482              		.align	2
 10483              		.set	.LANCHOR62,. + 0
 10486              	servoCenterPitch:
 10487 0000 00000000 		.space	4
 10488              		.section	.bss.safetyCheck,"aw",%nobits
 10489              		.set	.LANCHOR82,. + 0
 10492              	safetyCheck:
 10493 0000 00       		.space	1
 10494              		.section	.bss.motorCommand,"aw",%nobits
 10495              		.align	2
 10496              		.set	.LANCHOR56,. + 0
 10499              	motorCommand:
 10500 0000 00000000 		.space	32
 10500      00000000 
 10500      00000000 
 10500      00000000 
 10500      00000000 
 10501              		.section	.data.numberOfMotors,"aw",%progbits
 10504              	numberOfMotors:
 10505 0000 04       		.byte	4
 10506              		.section	.bss.accelOneG,"aw",%nobits
 10507              		.align	2
 10508              		.set	.LANCHOR31,. + 0
 10511              	accelOneG:
 10512 0000 00000000 		.space	4
 10513              		.section	.bss.ezInt,"aw",%nobits
 10514              		.align	2
 10515              		.set	.LANCHOR45,. + 0
 10518              	ezInt:
 10519 0000 00000000 		.space	4
 10520              		.section	.bss.servoMaxPitch,"aw",%nobits
 10521              		.align	2
 10522              		.set	.LANCHOR64,. + 0
 10525              	servoMaxPitch:
 10526 0000 00000000 		.space	4
 10527              		.section	.bss.headingHoldState,"aw",%nobits
 10528              		.set	.LANCHOR91,. + 0
 10531              	headingHoldState:
 10532 0000 00       		.space	1
 10533              		.section	.rodata._ZL18ReceiverChannelMap,"a",%progbits
 10534              		.set	.LANCHOR53,. + 0
 10537              	_ZL18ReceiverChannelMap:
 10538 0000 00       		.byte	0
 10539 0001 01       		.byte	1
 10540 0002 02       		.byte	2
 10541 0003 03       		.byte	3
 10542 0004 04       		.byte	4
 10543 0005 05       		.byte	5
 10544 0006 06       		.byte	6
 10545 0007 07       		.byte	7
 10546              		.section	.rodata._ZL19stm32_motor_mapping,"a",%progbits
 10547              		.set	.LANCHOR57,. + 0
 10550              	_ZL19stm32_motor_mapping:
 10551 0000 29       		.byte	41
 10552 0001 28       		.byte	40
 10553 0002 27       		.byte	39
 10554 0003 26       		.byte	38
 10555 0004 0F       		.byte	15
 10556 0005 13       		.byte	19
 10557 0006 14       		.byte	20
 10558 0007 15       		.byte	21
 10559              		.section	.bss.q0,"aw",%nobits
 10560              		.align	2
 10561              		.set	.LANCHOR38,. + 0
 10564              	q0:
 10565 0000 00000000 		.space	4
 10566              		.section	.bss.currentTime,"aw",%nobits
 10567              		.align	2
 10568              		.set	.LANCHOR7,. + 0
 10571              	currentTime:
 10572 0000 00000000 		.space	4
 10573              		.section	.bss.accelSampleCount,"aw",%nobits
 10574              		.set	.LANCHOR30,. + 0
 10577              	accelSampleCount:
 10578 0000 00       		.space	1
 10579              		.section	.bss.eyInt,"aw",%nobits
 10580              		.align	2
 10581              		.set	.LANCHOR43,. + 0
 10584              	eyInt:
 10585 0000 00000000 		.space	4
 10586              		.section	.bss.previousEx,"aw",%nobits
 10587              		.align	2
 10588              		.set	.LANCHOR42,. + 0
 10591              	previousEx:
 10592 0000 00000000 		.space	4
 10593              		.section	.bss.previousEy,"aw",%nobits
 10594              		.align	2
 10595              		.set	.LANCHOR44,. + 0
 10598              	previousEy:
 10599 0000 00000000 		.space	4
 10600              		.section	.bss.heading,"aw",%nobits
 10601              		.align	2
 10602              		.set	.LANCHOR87,. + 0
 10605              	heading:
 10606 0000 00000000 		.space	4
 10607              		.section	.bss.readMPU6000GyroCount,"aw",%nobits
 10608              		.align	2
 10609              		.set	.LANCHOR17,. + 0
 10612              	readMPU6000GyroCount:
 10613 0000 00000000 		.space	4
 10614              		.section	.rodata.Serial,"a",%progbits
 10615              		.align	2
 10618              	Serial:
 10619 0000 00000000 		.word	SerialUSB
 10620              		.section	.bss.fastTransfer,"aw",%nobits
 10621              		.set	.LANCHOR100,. + 0
 10624              	fastTransfer:
 10625 0000 00       		.space	1
 10626              		.section	.bss.fiftyHZpreviousTime,"aw",%nobits
 10627              		.align	2
 10628              		.set	.LANCHOR104,. + 0
 10631              	fiftyHZpreviousTime:
 10632 0000 00000000 		.space	4
 10633              		.section	.bss.oneHZpreviousTime,"aw",%nobits
 10634              		.align	2
 10637              	oneHZpreviousTime:
 10638 0000 00000000 		.space	4
 10639              		.section	.bss.deltaTime,"aw",%nobits
 10640              		.align	2
 10641              		.set	.LANCHOR107,. + 0
 10644              	deltaTime:
 10645 0000 00000000 		.space	4
 10646              		.section	.bss.servoCenterYaw,"aw",%nobits
 10647              		.align	2
 10648              		.set	.LANCHOR70,. + 0
 10651              	servoCenterYaw:
 10652 0000 00000000 		.space	4
 10653              		.section	.bss.accelCutoff,"aw",%nobits
 10654              		.align	2
 10657              	accelCutoff:
 10658 0000 00000000 		.space	4
 10659              		.section	.bss.minLimit,"aw",%nobits
 10662              	minLimit:
 10663 0000 00       		.space	1
 10664              		.section	.data.testCommand,"aw",%progbits
 10665              		.align	2
 10666              		.set	.LANCHOR80,. + 0
 10669              	testCommand:
 10670 0000 E8030000 		.word	1000
 10671              		.section	.rodata._ZL9servopins,"a",%progbits
 10672              		.set	.LANCHOR59,. + 0
 10675              	_ZL9servopins:
 10676 0000 02       		.byte	2
 10677 0001 01       		.byte	1
 10678 0002 00       		.byte	0
 10679              		.section	.bss.relativeHeading,"aw",%nobits
 10680              		.align	2
 10681              		.set	.LANCHOR89,. + 0
 10684              	relativeHeading:
 10685 0000 00000000 		.space	4
 10686              		.section	.rodata._ZL11receiverPin,"a",%progbits
 10687              		.set	.LANCHOR50,. + 0
 10690              	_ZL11receiverPin:
 10691 0000 3C       		.byte	60
 10692 0001 3D       		.byte	61
 10693 0002 3E       		.byte	62
 10694 0003 3F       		.byte	63
 10695 0004 49       		.byte	73
 10696 0005 4B       		.byte	75
 10697 0006 4D       		.byte	77
 10698 0007 4E       		.byte	78
 10699              		.section	.bss.q1,"aw",%nobits
 10700              		.align	2
 10701              		.set	.LANCHOR36,. + 0
 10704              	q1:
 10705 0000 00000000 		.space	4
 10706              		.section	.bss.q2,"aw",%nobits
 10707              		.align	2
 10708              		.set	.LANCHOR39,. + 0
 10711              	q2:
 10712 0000 00000000 		.space	4
 10713              		.section	.bss.q3,"aw",%nobits
 10714              		.align	2
 10715              		.set	.LANCHOR37,. + 0
 10718              	q3:
 10719 0000 00000000 		.space	4
 10720              		.section	.bss.accelSample,"aw",%nobits
 10721              		.align	2
 10722              		.set	.LANCHOR29,. + 0
 10725              	accelSample:
 10726 0000 00000000 		.space	12
 10726      00000000 
 10726      00000000 
 10727              		.section	.bss.aref,"aw",%nobits
 10728              		.align	2
 10729              		.set	.LANCHOR96,. + 0
 10732              	aref:
 10733 0000 00000000 		.space	4
 10734              		.section	.bss.receiverCommand,"aw",%nobits
 10735              		.align	2
 10736              		.set	.LANCHOR1,. + 0
 10739              	receiverCommand:
 10740 0000 00000000 		.space	40
 10740      00000000 
 10740      00000000 
 10740      00000000 
 10740      00000000 
 10741              		.section	.bss.accelScaleFactor,"aw",%nobits
 10742              		.align	2
 10743              		.set	.LANCHOR27,. + 0
 10746              	accelScaleFactor:
 10747 0000 00000000 		.space	12
 10747      00000000 
 10747      00000000 
 10748              		.section	.bss.setHeading,"aw",%nobits
 10749              		.align	2
 10750              		.set	.LANCHOR88,. + 0
 10753              	setHeading:
 10754 0000 00000000 		.space	4
 10755              		.section	.bss.halfT,"aw",%nobits
 10756              		.align	2
 10757              		.set	.LANCHOR35,. + 0
 10760              	halfT:
 10761 0000 00000000 		.space	4
 10762              		.section	.bss.headingHold,"aw",%nobits
 10763              		.align	2
 10764              		.set	.LANCHOR90,. + 0
 10767              	headingHold:
 10768 0000 00000000 		.space	4
 10769              		.section	.bss.correctedRateVector,"aw",%nobits
 10770              		.align	2
 10771              		.set	.LANCHOR49,. + 0
 10774              	correctedRateVector:
 10775 0000 00000000 		.space	12
 10775      00000000 
 10775      00000000 
 10776              		.section	.bss.maxLimit,"aw",%nobits
 10779              	maxLimit:
 10780 0000 00       		.space	1
 10781              		.section	.bss.frameCounter,"aw",%nobits
 10782              		.align	2
 10783              		.set	.LANCHOR93,. + 0
 10786              	frameCounter:
 10787 0000 00000000 		.space	4
 10788              		.section	.bss.Ki,"aw",%nobits
 10789              		.align	2
 10790              		.set	.LANCHOR41,. + 0
 10793              	Ki:
 10794 0000 00000000 		.space	4
 10795              		.section	.bss.receiverCommandSmooth,"aw",%nobits
 10796              		.align	2
 10797              		.set	.LANCHOR2,. + 0
 10800              	receiverCommandSmooth:
 10801 0000 00000000 		.space	40
 10801      00000000 
 10801      00000000 
 10801      00000000 
 10801      00000000 
 10802              		.section	.bss.minArmedThrottle,"aw",%nobits
 10803              		.align	2
 10804              		.set	.LANCHOR83,. + 0
 10807              	minArmedThrottle:
 10808 0000 00000000 		.space	4
 10809              		.section	.bss.Kp,"aw",%nobits
 10810              		.align	2
 10811              		.set	.LANCHOR47,. + 0
 10814              	Kp:
 10815 0000 00000000 		.space	4
 10816              		.section	.bss.readMPU6000AccelCount,"aw",%nobits
 10817              		.align	2
 10818              		.set	.LANCHOR15,. + 0
 10821              	readMPU6000AccelCount:
 10822 0000 00000000 		.space	4
 10823              		.section	.bss.headingTime,"aw",%nobits
 10824              		.align	2
 10825              		.set	.LANCHOR92,. + 0
 10828              	headingTime:
 10829 0000 00000000 		.space	4
 10830              		.section	.rodata.str1.1,"aMS",%progbits,1
 10831              	.LC0:
 10832 0000 3A2000   		.ascii	": \000"
 10833              	.LC1:
 10834 0003 4E6F7420 		.ascii	"Not \000"
 10834      00
 10835              	.LC2:
 10836 0008 536F6674 		.ascii	"Software Version: \000"
 10836      77617265 
 10836      20566572 
 10836      73696F6E 
 10836      3A2000
 10837              	.LC3:
 10838 001b 426F6172 		.ascii	"Board Type: \000"
 10838      64205479 
 10838      70653A20 
 10838      00
 10839              	.LC4:
 10840 0028 6165726F 		.ascii	"aeroquad32\000"
 10840      71756164 
 10840      333200
 10841              	.LC5:
 10842 0033 466C6967 		.ascii	"Flight Config: \000"
 10842      68742043 
 10842      6F6E6669 
 10842      673A2000 
 10843              	.LC6:
 10844 0043 51756164 		.ascii	"Quad X\000"
 10844      205800
 10845              	.LC7:
 10846 004a 52656365 		.ascii	"Receiver Channels: \000"
 10846      69766572 
 10846      20436861 
 10846      6E6E656C 
 10846      733A2000 
 10847              	.LC8:
 10848 005e 4D6F746F 		.ascii	"Motors: \000"
 10848      72733A20 
 10848      00
 10849              	.LC9:
 10850 0067 4779726F 		.ascii	"Gyroscope\000"
 10850      73636F70 
 10850      6500
 10851              	.LC10:
 10852 0071 44657465 		.ascii	"Detected\000"
 10852      63746564 
 10852      00
 10853              	.LC11:
 10854 007a 41636365 		.ascii	"Accelerometer\000"
 10854      6C65726F 
 10854      6D657465 
 10854      7200
 10855              	.LC12:
 10856 0088 4261726F 		.ascii	"Barometer\000"
 10856      6D657465 
 10856      7200
 10857              	.LC13:
 10858 0092 4D61676E 		.ascii	"Magnetometer\000"
 10858      65746F6D 
 10858      65746572 
 10858      00
 10859              	.LC14:
 10860 009f 48656164 		.ascii	"Heading Hold\000"
 10860      696E6720 
 10860      486F6C64 
 10860      00
 10861              	.LC15:
 10862 00ac 456E6162 		.ascii	"Enabled\000"
 10862      6C656400 
 10863              	.LC16:
 10864 00b4 416C7469 		.ascii	"Altitude Hold\000"
 10864      74756465 
 10864      20486F6C 
 10864      6400
 10865              	.LC17:
 10866 00c2 42617474 		.ascii	"Battery Monitor\000"
 10866      65727920 
 10866      4D6F6E69 
 10866      746F7200 
 10867              	.LC18:
 10868 00d2 43616D65 		.ascii	"Camera Stability\000"
 10868      72612053 
 10868      74616269 
 10868      6C697479 
 10868      00
 10869              	.LC19:
 10870 00e3 52616E67 		.ascii	"Range Detection\000"
 10870      65204465 
 10870      74656374 
 10870      696F6E00 
 10871              	.LC20:
 10872 00f3 4750533A 		.ascii	"GPS: Not Enabled\000"
 10872      204E6F74 
 10872      20456E61 
 10872      626C6564 
 10872      00
 10873              		.section	.bss.initializeMPU6000SensorsDone,"aw",%nobits
 10874              		.set	.LANCHOR12,. + 0
 10877              	initializeMPU6000SensorsDone:
 10878 0000 00       		.space	1
 10879              		.section	.bss.gyroRaw,"aw",%nobits
 10880              		.align	2
 10881              		.set	.LANCHOR22,. + 0
 10884              	gyroRaw:
 10885 0000 00000000 		.space	12
 10885      00000000 
 10885      00000000 
 10886              		.section	.data.throttle,"aw",%progbits
 10887              		.align	2
 10888              		.set	.LANCHOR73,. + 0
 10891              	throttle:
 10892 0000 E8030000 		.word	1000
 10893              		.section	.bss.gyroRate,"aw",%nobits
 10894              		.align	2
 10895              		.set	.LANCHOR19,. + 0
 10898              	gyroRate:
 10899 0000 00000000 		.space	12
 10899      00000000 
 10899      00000000 
 10900              		.section	.bss.PID,"aw",%nobits
 10901              		.align	2
 10902              		.set	.LANCHOR9,. + 0
 10905              	PID:
 10906 0000 00000000 		.space	224
 10906      00000000 
 10906      00000000 
 10906      00000000 
 10906      00000000 
 10907              		.section	.bss.kinematicsAngle,"aw",%nobits
 10908              		.align	2
 10909              		.set	.LANCHOR33,. + 0
 10912              	kinematicsAngle:
 10913 0000 00000000 		.space	12
 10913      00000000 
 10913      00000000 
 10914              		.section	.bss.lowPriorityTenHZpreviousTime2,"aw",%nobits
 10915              		.align	2
 10916              		.set	.LANCHOR106,. + 0
 10919              	lowPriorityTenHZpreviousTime2:
 10920 0000 00000000 		.space	4
 10921              		.section	.data.previousFlightMode,"aw",%progbits
 10922              		.set	.LANCHOR97,. + 0
 10925              	previousFlightMode:
 10926 0000 01       		.byte	1
 10927              		.section	.bss.calibrateESC,"aw",%nobits
 10928              		.set	.LANCHOR79,. + 0
 10931              	calibrateESC:
 10932 0000 00       		.space	1
 10933              		.section	.bss.servoMinPitch,"aw",%nobits
 10934              		.align	2
 10935              		.set	.LANCHOR63,. + 0
 10938              	servoMinPitch:
 10939 0000 00000000 		.space	4
 10940              		.section	.bss.spiMPU6000,"aw",%nobits
 10941              		.align	2
 10942              		.set	.LANCHOR11,. + 0
 10945              	spiMPU6000:
 10946 0000 00000000 		.space	12
 10946      00000000 
 10946      00000000 
 10947              		.section	.bss.fourthOrder,"aw",%nobits
 10948              		.align	2
 10949              		.set	.LANCHOR10,. + 0
 10952              	fourthOrder:
 10953 0000 00000000 		.space	128
 10953      00000000 
 10953      00000000 
 10953      00000000 
 10953      00000000 
 10954              		.section	.bss.headingHoldConfig,"aw",%nobits
 10955              		.set	.LANCHOR86,. + 0
 10958              	headingHoldConfig:
 10959 0000 00       		.space	1
 10960              		.section	.bss.inFlight,"aw",%nobits
 10961              		.set	.LANCHOR8,. + 0
 10964              	inFlight:
 10965 0000 00       		.space	1
 10966              		.section	.bss.exInt,"aw",%nobits
 10967              		.align	2
 10968              		.set	.LANCHOR40,. + 0
 10971              	exInt:
 10972 0000 00000000 		.space	4
 10973              		.section	.bss.receiverXmitFactor,"aw",%nobits
 10974              		.align	2
 10975              		.set	.LANCHOR55,. + 0
 10978              	receiverXmitFactor:
 10979 0000 00000000 		.space	4
 10980              		.section	.bss.gyroZero,"aw",%nobits
 10981              		.align	2
 10982              		.set	.LANCHOR23,. + 0
 10985              	gyroZero:
 10986 0000 00000000 		.space	12
 10986      00000000 
 10986      00000000 
 10987              		.section	.bss.servoMaxYaw,"aw",%nobits
 10988              		.align	2
 10989              		.set	.LANCHOR72,. + 0
 10992              	servoMaxYaw:
 10993 0000 00000000 		.space	4
 10994              		.section	.bss.earthAccel,"aw",%nobits
 10995              		.align	2
 10998              	earthAccel:
 10999 0000 00000000 		.space	12
 10999      00000000 
 10999      00000000 
 11000              		.section	.bss.gyroLastMesuredTime,"aw",%nobits
 11001              		.align	2
 11002              		.set	.LANCHOR21,. + 0
 11005              	gyroLastMesuredTime:
 11006 0000 00000000 		.space	4
 11007              		.section	.bss.gyroSampleCount,"aw",%nobits
 11008              		.set	.LANCHOR25,. + 0
 11011              	gyroSampleCount:
 11012 0000 00       		.space	1
 11013              		.section	.bss.motorConfiguratorCommand,"aw",%nobits
 11014              		.align	2
 11015              		.set	.LANCHOR81,. + 0
 11018              	motorConfiguratorCommand:
 11019 0000 00000000 		.space	16
 11019      00000000 
 11019      00000000 
 11019      00000000 
 11020              		.section	.bss.windupGuard,"aw",%nobits
 11021              		.align	2
 11022              		.set	.LANCHOR95,. + 0
 11025              	windupGuard:
 11026 0000 00000000 		.space	4
 11027              		.section	.bss.motorMaxCommand,"aw",%nobits
 11028              		.align	2
 11029              		.set	.LANCHOR85,. + 0
 11032              	motorMaxCommand:
 11033 0000 00000000 		.space	16
 11033      00000000 
 11033      00000000 
 11033      00000000 
 11034              		.section	.bss.receiverZero,"aw",%nobits
 11035              		.align	2
 11036              		.set	.LANCHOR3,. + 0
 11039              	receiverZero:
 11040 0000 00000000 		.space	12
 11040      00000000 
 11040      00000000 
 11041              		.section	.bss.motorAxisCommandYaw,"aw",%nobits
 11042              		.align	2
 11043              		.set	.LANCHOR76,. + 0
 11046              	motorAxisCommandYaw:
 11047 0000 00000000 		.space	4
 11048              		.section	.bss.lowPriorityTenHZpreviousTime,"aw",%nobits
 11049              		.align	2
 11050              		.set	.LANCHOR105,. + 0
 11053              	lowPriorityTenHZpreviousTime:
 11054 0000 00000000 		.space	4
 11055              		.section	.bss.channelCal,"aw",%nobits
 11056              		.align	2
 11057              		.set	.LANCHOR99,. + 0
 11060              	channelCal:
 11061 0000 00000000 		.space	4
 11062              		.section	.bss.gyroAngle,"aw",%nobits
 11063              		.align	2
 11064              		.set	.LANCHOR34,. + 0
 11067              	gyroAngle:
 11068 0000 00000000 		.space	8
 11068      00000000 
 11069              		.section	.bss.receiverOffset,"aw",%nobits
 11070              		.align	2
 11071              		.set	.LANCHOR5,. + 0
 11074              	receiverOffset:
 11075 0000 00000000 		.space	40
 11075      00000000 
 11075      00000000 
 11075      00000000 
 11075      00000000 
 11076              		.section	.bss.cameraMode,"aw",%nobits
 11077              		.align	2
 11078              		.set	.LANCHOR60,. + 0
 11081              	cameraMode:
 11082 0000 00000000 		.space	4
 11083              		.section	.bss.kinematicsType,"aw",%nobits
 11086              	kinematicsType:
 11087 0000 00       		.space	1
 11088              		.section	.bss.lastReceiverChannel,"aw",%nobits
 11089              		.align	2
 11090              		.set	.LANCHOR0,. + 0
 11093              	lastReceiverChannel:
 11094 0000 00000000 		.space	4
 11095              		.section	.bss.meterPerSecSec,"aw",%nobits
 11096              		.align	2
 11097              		.set	.LANCHOR26,. + 0
 11100              	meterPerSecSec:
 11101 0000 00000000 		.space	12
 11101      00000000 
 11101      00000000 
 11102              		.section	.bss.receiverSlope,"aw",%nobits
 11103              		.align	2
 11104              		.set	.LANCHOR4,. + 0
 11107              	receiverSlope:
 11108 0000 00000000 		.space	40
 11108      00000000 
 11108      00000000 
 11108      00000000 
 11108      00000000 
 11109              		.section	.bss.flightMode,"aw",%nobits
 11110              		.set	.LANCHOR77,. + 0
 11113              	flightMode:
 11114 0000 00       		.space	1
 11115              		.section	.bss.vehicleState,"aw",%nobits
 11116              		.align	2
 11117              		.set	.LANCHOR13,. + 0
 11120              	vehicleState:
 11121 0000 00000000 		.space	4
 11122              		.section	.bss.motorAxisCommandRoll,"aw",%nobits
 11123              		.align	2
 11124              		.set	.LANCHOR75,. + 0
 11127              	motorAxisCommandRoll:
 11128 0000 00000000 		.space	4
 11129              		.section	.bss.previousTime,"aw",%nobits
 11130              		.align	2
 11131              		.set	.LANCHOR102,. + 0
 11134              	previousTime:
 11135 0000 00000000 		.space	4
 11136              		.section	.data.G_Dt,"aw",%progbits
 11137              		.align	2
 11138              		.set	.LANCHOR48,. + 0
 11141              	G_Dt:
 11142 0000 6F12033B 		.word	990057071
 11143              		.section	.bss.hundredHZpreviousTime,"aw",%nobits
 11144              		.align	2
 11145              		.set	.LANCHOR103,. + 0
 11148              	hundredHZpreviousTime:
 11149 0000 00000000 		.space	4
 11150              		.section	.bss.servoMinYaw,"aw",%nobits
 11151              		.align	2
 11152              		.set	.LANCHOR71,. + 0
 11155              	servoMinYaw:
 11156 0000 00000000 		.space	4
 11157              		.section	.bss.gyroScaleFactor,"aw",%nobits
 11158              		.align	2
 11159              		.set	.LANCHOR18,. + 0
 11162              	gyroScaleFactor:
 11163 0000 00000000 		.space	4
 11164              		.section	.bss.gyroSample,"aw",%nobits
 11165              		.align	2
 11166              		.set	.LANCHOR24,. + 0
 11169              	gyroSample:
 11170 0000 00000000 		.space	12
 11170      00000000 
 11170      00000000 
 11171              		.section	.bss._ZL19_stm32_motor_number,"aw",%nobits
 11172              		.align	2
 11173              		.set	.LANCHOR58,. + 0
 11176              	_ZL19_stm32_motor_number:
 11177 0000 00000000 		.space	4
 11178              		.section	.bss.mCameraRoll,"aw",%nobits
 11179              		.align	2
 11180              		.set	.LANCHOR65,. + 0
 11183              	mCameraRoll:
 11184 0000 00000000 		.space	4
 11185              		.section	.bss.runTimeAccelBias,"aw",%nobits
 11186              		.align	2
 11187              		.set	.LANCHOR28,. + 0
 11190              	runTimeAccelBias:
 11191 0000 00000000 		.space	12
 11191      00000000 
 11191      00000000 
 11192              		.text
 11193              	.Letext0:
 11194              		.file 29 "/home/james/arm-2011.09/bin/../lib/gcc/arm-none-eabi/4.6.1/../../../../arm-none-eabi/inc
 11195              		.file 30 "../Libmaple/libmaple/libmaple/libmaple_types.h"
 11196              		.file 31 "../Libmaple/libmaple/libmaple/rccF2.h"
 11197              		.file 32 "../Libmaple/libmaple/libmaple/gpioF2.h"
 11198              		.file 33 "../Libmaple/libmaple/libmaple/adc.h"
 11199              		.file 34 "../Libmaple/libmaple/wirish/wirish_types.h"
 11200              		.file 35 "../Libmaple/libmaple/wirish/io.h"
 11201              		.file 36 "../Libmaple/libmaple/libmaple/spi.h"
 11202              		.file 37 "../Libmaple/libmaple/wirish/comm/HardwareSPI.h"
 11203              		.file 38 "../Libmaple/libmaple/wirish/wirish.h"
 11204              		.file 39 "../AeroQuad32/MapleCompatibility/WProgram.h"
 11205              		.file 40 "../AeroQuad32/MapleCompatibility/flash_stm32.h"
 11206              		.file 41 "../AeroQuad32/MapleCompatibility/EEPROM.h"
 11207              		.file 42 "../Libmaple/libmaple/libraries/Wire/Wire.h"
 11208              		.file 43 "../Libraries/AQ_Gps/GpsDataType.h"
 11209              		.file 44 "/home/james/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h"
 11210              		.file 45 "../Libmaple/libmaple/wirish/Print.h"
 11211              		.file 46 "../Libmaple/libmaple/wirish/boards.h"
 11212              		.file 47 "../AeroQuad32/AeroQuad_STM32.h"
 11213              		.file 48 "../Libraries/AQ_Defines/SensorsStatus.h"
 11214              		.file 49 "../Libraries/AQ_Gyroscope/Gyroscope.h"
 11215              		.file 50 "../Libraries/AQ_Accelerometer/Accelerometer.h"
 11216              		.file 51 "../Libraries/AQ_FlightControlProcessor/FlightControlVariable.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AeroQuadMain.cpp
     /tmp/ccxVmAlP.s:20     .text.systick_get_count:00000000 $t
     /tmp/ccxVmAlP.s:24     .text.systick_get_count:00000000 systick_get_count
     /tmp/ccxVmAlP.s:40     .text.systick_get_count:00000008 $d
     /tmp/ccxVmAlP.s:45     .text._ZL6millisv:00000000 $t
     /tmp/ccxVmAlP.s:49     .text._ZL6millisv:00000000 _ZL6millisv
     /tmp/ccxVmAlP.s:69     .text._ZL6millisv:00000008 $d
     /tmp/ccxVmAlP.s:74     .text._ZL6microsv:00000000 $t
     /tmp/ccxVmAlP.s:78     .text._ZL6microsv:00000000 _ZL6microsv
     /tmp/ccxVmAlP.s:148    .text._ZL6microsv:00000040 $d
     /tmp/ccxVmAlP.s:153    .text.timer_set_prescaler.isra.0:00000000 $t
     /tmp/ccxVmAlP.s:157    .text.timer_set_prescaler.isra.0:00000000 timer_set_prescaler.isra.0
     /tmp/ccxVmAlP.s:174    .text.timer_set_reload.isra.1:00000000 $t
     /tmp/ccxVmAlP.s:178    .text.timer_set_reload.isra.1:00000000 timer_set_reload.isra.1
     /tmp/ccxVmAlP.s:194    .text.timer_set_compare.isra.2:00000000 $t
     /tmp/ccxVmAlP.s:198    .text.timer_set_compare.isra.2:00000000 timer_set_compare.isra.2
     /tmp/ccxVmAlP.s:220    .text.timer_generate_update.isra.3:00000000 $t
     /tmp/ccxVmAlP.s:224    .text.timer_generate_update.isra.3:00000000 timer_generate_update.isra.3
     /tmp/ccxVmAlP.s:253    .text.startup._Z7premainv:00000000 $t
     /tmp/ccxVmAlP.s:258    .text.startup._Z7premainv:00000000 _Z7premainv
     /tmp/ccxVmAlP.s:273    .init_array:00000000 $d
     /tmp/ccxVmAlP.s:276    .text._init:00000000 $t
     /tmp/ccxVmAlP.s:281    .text._init:00000000 _init
     /tmp/ccxVmAlP.s:294    .text._Z23initializeReceiverParami:00000000 $t
     /tmp/ccxVmAlP.s:299    .text._Z23initializeReceiverParami:00000000 _Z23initializeReceiverParami
     /tmp/ccxVmAlP.s:449    .text._Z23initializeReceiverParami:00000098 $d
     /tmp/ccxVmAlP.s:460    .text._Z17getReceiverSIDatah:00000000 $t
     /tmp/ccxVmAlP.s:465    .text._Z17getReceiverSIDatah:00000000 _Z17getReceiverSIDatah
     /tmp/ccxVmAlP.s:492    .text._Z17getReceiverSIDatah:00000024 $d
     /tmp/ccxVmAlP.s:499    .text._Z9updatePIDffP7PIDdata:00000000 $t
     /tmp/ccxVmAlP.s:504    .text._Z9updatePIDffP7PIDdata:00000000 _Z9updatePIDffP7PIDdata
     /tmp/ccxVmAlP.s:601    .text._Z9updatePIDffP7PIDdata:000000ac $d
     /tmp/ccxVmAlP.s:609    .text._Z17zeroIntegralErrorv:00000000 $t
     /tmp/ccxVmAlP.s:614    .text._Z17zeroIntegralErrorv:00000000 _Z17zeroIntegralErrorv
     /tmp/ccxVmAlP.s:663    .text._Z17zeroIntegralErrorv:00000034 $d
     /tmp/ccxVmAlP.s:669    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 $t
     /tmp/ccxVmAlP.s:674    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 _Z18computeFourthOrderfP15fourthOrderData
     /tmp/ccxVmAlP.s:739    .text._Z18computeFourthOrderfP15fourthOrderData:00000088 $d
     /tmp/ccxVmAlP.s:750    .text._Z16setupFourthOrderv:00000000 $t
     /tmp/ccxVmAlP.s:755    .text._Z16setupFourthOrderv:00000000 _Z16setupFourthOrderv
     /tmp/ccxVmAlP.s:820    .text._Z16setupFourthOrderv:00000038 $d
     /tmp/ccxVmAlP.s:826    .text._ZN14HardwareSPIExt5SetCSEi:00000000 $t
     /tmp/ccxVmAlP.s:831    .text._ZN14HardwareSPIExt5SetCSEi:00000000 _ZN14HardwareSPIExt5SetCSEi
     /tmp/ccxVmAlP.s:848    .text._ZN14HardwareSPIExtC2Ej:00000000 $t
     /tmp/ccxVmAlP.s:853    .text._ZN14HardwareSPIExtC2Ej:00000000 _ZN14HardwareSPIExtC2Ej
     /tmp/ccxVmAlP.s:887    .text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj:00000000 $t
     /tmp/ccxVmAlP.s:892    .text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj:00000000 _ZN14HardwareSPIExt5beginE12SPIFrequencyjj
     /tmp/ccxVmAlP.s:939    .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 $t
     /tmp/ccxVmAlP.s:944    .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 _ZN14HardwareSPIExt4ReadEiPhi
     /tmp/ccxVmAlP.s:1009   .text._ZN14HardwareSPIExt4ReadEi:00000000 $t
     /tmp/ccxVmAlP.s:1014   .text._ZN14HardwareSPIExt4ReadEi:00000000 _ZN14HardwareSPIExt4ReadEi
     /tmp/ccxVmAlP.s:1042   .text._ZN14HardwareSPIExt5WriteEiPhi:00000000 $t
     /tmp/ccxVmAlP.s:1047   .text._ZN14HardwareSPIExt5WriteEiPhi:00000000 _ZN14HardwareSPIExt5WriteEiPhi
     /tmp/ccxVmAlP.s:1111   .text._ZN14HardwareSPIExt5WriteEih:00000000 $t
     /tmp/ccxVmAlP.s:1116   .text._ZN14HardwareSPIExt5WriteEih:00000000 _ZN14HardwareSPIExt5WriteEih
     /tmp/ccxVmAlP.s:1147   .text._Z19MPU6000_SpiLowSpeedv:00000000 $t
     /tmp/ccxVmAlP.s:1152   .text._Z19MPU6000_SpiLowSpeedv:00000000 _Z19MPU6000_SpiLowSpeedv
     /tmp/ccxVmAlP.s:1171   .text._Z19MPU6000_SpiLowSpeedv:0000000c $d
     /tmp/ccxVmAlP.s:1176   .text._Z20MPU6000_SpiHighSpeedv:00000000 $t
     /tmp/ccxVmAlP.s:1181   .text._Z20MPU6000_SpiHighSpeedv:00000000 _Z20MPU6000_SpiHighSpeedv
     /tmp/ccxVmAlP.s:1208   .text._Z20MPU6000_SpiHighSpeedv:0000001c $d
     /tmp/ccxVmAlP.s:1213   .text._Z16MPU6000_WriteRegih:00000000 $t
     /tmp/ccxVmAlP.s:1218   .text._Z16MPU6000_WriteRegih:00000000 _Z16MPU6000_WriteRegih
     /tmp/ccxVmAlP.s:1249   .text._Z16MPU6000_WriteRegih:00000018 $d
     /tmp/ccxVmAlP.s:1254   .text._Z15MPU6000_ReadRegi:00000000 $t
     /tmp/ccxVmAlP.s:1259   .text._Z15MPU6000_ReadRegi:00000000 _Z15MPU6000_ReadRegi
     /tmp/ccxVmAlP.s:1292   .text._Z15MPU6000_ReadRegi:00000018 $d
     /tmp/ccxVmAlP.s:1297   .text._Z24initializeMPU6000Sensorsv:00000000 $t
     /tmp/ccxVmAlP.s:1302   .text._Z24initializeMPU6000Sensorsv:00000000 _Z24initializeMPU6000Sensorsv
     /tmp/ccxVmAlP.s:1388   .text._Z24initializeMPU6000Sensorsv:0000007c $d
     /tmp/ccxVmAlP.s:1395   .text._Z15MPU6000SwapDataPhi:00000000 $t
     /tmp/ccxVmAlP.s:1400   .text._Z15MPU6000SwapDataPhi:00000000 _Z15MPU6000SwapDataPhi
     /tmp/ccxVmAlP.s:1444   .text._Z18readMPU6000Sensorsv:00000000 $t
     /tmp/ccxVmAlP.s:1449   .text._Z18readMPU6000Sensorsv:00000000 _Z18readMPU6000Sensorsv
     /tmp/ccxVmAlP.s:1477   .text._Z18readMPU6000Sensorsv:0000001c $d
     /tmp/ccxVmAlP.s:1483   .text._Z16readMPU6000Accelv:00000000 $t
     /tmp/ccxVmAlP.s:1488   .text._Z16readMPU6000Accelv:00000000 _Z16readMPU6000Accelv
     /tmp/ccxVmAlP.s:1527   .text._Z16readMPU6000Accelv:00000020 $d
     /tmp/ccxVmAlP.s:1533   .text._Z15readMPU6000Gyrov:00000000 $t
     /tmp/ccxVmAlP.s:1538   .text._Z15readMPU6000Gyrov:00000000 _Z15readMPU6000Gyrov
     /tmp/ccxVmAlP.s:1576   .text._Z15readMPU6000Gyrov:00000020 $d
     /tmp/ccxVmAlP.s:1582   .text._Z14initializeGyrov:00000000 $t
     /tmp/ccxVmAlP.s:1587   .text._Z14initializeGyrov:00000000 _Z14initializeGyrov
     /tmp/ccxVmAlP.s:1609   .text._Z14initializeGyrov:0000000c $d
     /tmp/ccxVmAlP.s:1616   .text._Z17gyroUpdateHeadingv:00000000 $t
     /tmp/ccxVmAlP.s:1621   .text._Z17gyroUpdateHeadingv:00000000 _Z17gyroUpdateHeadingv
     /tmp/ccxVmAlP.s:1670   .text._Z17gyroUpdateHeadingv:00000050 $d
     /tmp/ccxVmAlP.s:1680   .text._Z11measureGyrov:00000000 $t
     /tmp/ccxVmAlP.s:1685   .text._Z11measureGyrov:00000000 _Z11measureGyrov
     /tmp/ccxVmAlP.s:1769   .text._Z11measureGyrov:00000074 $d
     /tmp/ccxVmAlP.s:1779   .text._Z14measureGyroSumv:00000000 $t
     /tmp/ccxVmAlP.s:1784   .text._Z14measureGyroSumv:00000000 _Z14measureGyroSumv
     /tmp/ccxVmAlP.s:1830   .text._Z14measureGyroSumv:0000003c $d
     /tmp/ccxVmAlP.s:1838   .text._Z16evaluateGyroRatev:00000000 $t
     /tmp/ccxVmAlP.s:1843   .text._Z16evaluateGyroRatev:00000000 _Z16evaluateGyroRatev
     /tmp/ccxVmAlP.s:1940   .text._Z16evaluateGyroRatev:00000080 $d
     /tmp/ccxVmAlP.s:1950   .text._Z13calibrateGyrov:00000000 $t
     /tmp/ccxVmAlP.s:1955   .text._Z13calibrateGyrov:00000000 _Z13calibrateGyrov
     /tmp/ccxVmAlP.s:2062   .text._Z13calibrateGyrov:00000060 $d
     /tmp/ccxVmAlP.s:2068   .text._Z15initializeAccelv:00000000 $t
     /tmp/ccxVmAlP.s:2073   .text._Z15initializeAccelv:00000000 _Z15initializeAccelv
     /tmp/ccxVmAlP.s:2088   .text._Z12measureAccelv:00000000 $t
     /tmp/ccxVmAlP.s:2093   .text._Z12measureAccelv:00000000 _Z12measureAccelv
     /tmp/ccxVmAlP.s:2150   .text._Z12measureAccelv:00000064 $d
     /tmp/ccxVmAlP.s:2158   .text._Z15measureAccelSumv:00000000 $t
     /tmp/ccxVmAlP.s:2163   .text._Z15measureAccelSumv:00000000 _Z15measureAccelSumv
     /tmp/ccxVmAlP.s:2207   .text._Z15measureAccelSumv:00000038 $d
     /tmp/ccxVmAlP.s:2214   .text._Z20evaluateMetersPerSecv:00000000 $t
     /tmp/ccxVmAlP.s:2219   .text._Z20evaluateMetersPerSecv:00000000 _Z20evaluateMetersPerSecv
     /tmp/ccxVmAlP.s:2279   .text._Z20evaluateMetersPerSecv:00000048 $d
     /tmp/ccxVmAlP.s:2288   .text._Z16computeAccelBiasv:00000000 $t
     /tmp/ccxVmAlP.s:2293   .text._Z16computeAccelBiasv:00000000 _Z16computeAccelBiasv
     /tmp/ccxVmAlP.s:2397   .text._Z16computeAccelBiasv:000000a0 $d
     /tmp/ccxVmAlP.s:2410   .text._Z12initPlatformv:00000000 $t
     /tmp/ccxVmAlP.s:2415   .text._Z12initPlatformv:00000000 _Z12initPlatformv
     /tmp/ccxVmAlP.s:2528   .text._Z12initPlatformv:000000ac $d
     /tmp/ccxVmAlP.s:2534   .text._Z42initializePlatformSpecificAccelCalibrationv:00000000 $t
     /tmp/ccxVmAlP.s:2539   .text._Z42initializePlatformSpecificAccelCalibrationv:00000000 _Z42initializePlatformSpecificAccelCalibrationv
     /tmp/ccxVmAlP.s:2564   .text._Z42initializePlatformSpecificAccelCalibrationv:00000010 $d
     /tmp/ccxVmAlP.s:2572   .text._Z22measureCriticalSensorsv:00000000 $t
     /tmp/ccxVmAlP.s:2577   .text._Z22measureCriticalSensorsv:00000000 _Z22measureCriticalSensorsv
     /tmp/ccxVmAlP.s:2610   .text._Z22measureCriticalSensorsv:00000020 $d
     /tmp/ccxVmAlP.s:2616   .text._Z29initializeBaseKinematicsParamv:00000000 $t
     /tmp/ccxVmAlP.s:2621   .text._Z29initializeBaseKinematicsParamv:00000000 _Z29initializeBaseKinematicsParamv
     /tmp/ccxVmAlP.s:2657   .text._Z29initializeBaseKinematicsParamv:00000014 $d
     /tmp/ccxVmAlP.s:2663   .text._Z27kinematicsGetDegreesHeadingh:00000000 $t
     /tmp/ccxVmAlP.s:2668   .text._Z27kinematicsGetDegreesHeadingh:00000000 _Z27kinematicsGetDegreesHeadingh
     /tmp/ccxVmAlP.s:2700   .text._Z27kinematicsGetDegreesHeadingh:0000002c $d
     /tmp/ccxVmAlP.s:2709   .text._Z9argUpdatefffffff:00000000 $t
     /tmp/ccxVmAlP.s:2714   .text._Z9argUpdatefffffff:00000000 _Z9argUpdatefffffff
     /tmp/ccxVmAlP.s:3030   .text._Z9argUpdatefffffff:0000024c $d
     /tmp/ccxVmAlP.s:3047   .text._Z11eulerAnglesv:00000000 $t
     /tmp/ccxVmAlP.s:3052   .text._Z11eulerAnglesv:00000000 _Z11eulerAnglesv
     /tmp/ccxVmAlP.s:3157   .text._Z11eulerAnglesv:000000f8 $d
     /tmp/ccxVmAlP.s:3166   .text._Z20initializeKinematicsv:00000000 $t
     /tmp/ccxVmAlP.s:3171   .text._Z20initializeKinematicsv:00000000 _Z20initializeKinematicsv
     /tmp/ccxVmAlP.s:3241   .text._Z20initializeKinematicsv:00000044 $d
     /tmp/ccxVmAlP.s:3259   .text._Z19calculateKinematicsfffffff:00000000 $t
     /tmp/ccxVmAlP.s:3264   .text._Z19calculateKinematicsfffffff:00000000 _Z19calculateKinematicsfffffff
     /tmp/ccxVmAlP.s:3298   .text._Z19calculateKinematicsfffffff:00000028 $d
     /tmp/ccxVmAlP.s:3303   .text._Z13getGyroUnbiash:00000000 $t
     /tmp/ccxVmAlP.s:3308   .text._Z13getGyroUnbiash:00000000 _Z13getGyroUnbiash
     /tmp/ccxVmAlP.s:3326   .text._Z13getGyroUnbiash:0000000c $d
     /tmp/ccxVmAlP.s:3331   .text._Z19calibrateKinematicsv:00000000 $t
     /tmp/ccxVmAlP.s:3336   .text._Z19calibrateKinematicsv:00000000 _Z19calibrateKinematicsv
     /tmp/ccxVmAlP.s:3349   .text._Z7FrqInitiiPV8tFrqDataP9timer_devi:00000000 $t
     /tmp/ccxVmAlP.s:3354   .text._Z7FrqInitiiPV8tFrqDataP9timer_devi:00000000 _Z7FrqInitiiPV8tFrqDataP9timer_devi
     /tmp/ccxVmAlP.s:3488   .text._Z7FrqInitiiPV8tFrqDataP9timer_devi:000000a8 $d
     /tmp/ccxVmAlP.s:3493   .text._Z18InitFrqMeasurementv:00000000 $t
     /tmp/ccxVmAlP.s:3498   .text._Z18InitFrqMeasurementv:00000000 _Z18InitFrqMeasurementv
     /tmp/ccxVmAlP.s:3570   .text._Z18InitFrqMeasurementv:0000004c $d
     /tmp/ccxVmAlP.s:3578   .text._Z17PWMInvertPolarityPV8tFrqData:00000000 $t
     /tmp/ccxVmAlP.s:3583   .text._Z17PWMInvertPolarityPV8tFrqData:00000000 _Z17PWMInvertPolarityPV8tFrqData
     /tmp/ccxVmAlP.s:3603   .text._Z9FrqChangePV8tFrqData:00000000 $t
     /tmp/ccxVmAlP.s:3608   .text._Z9FrqChangePV8tFrqData:00000000 _Z9FrqChangePV8tFrqData
     /tmp/ccxVmAlP.s:3702   .text._Z14IrqChangeValuei:00000000 $t
     /tmp/ccxVmAlP.s:3707   .text._Z14IrqChangeValuei:00000000 _Z14IrqChangeValuei
     /tmp/ccxVmAlP.s:3726   .text._Z14IrqChangeValuei:0000000c $d
     /tmp/ccxVmAlP.s:3731   .text._Z8PWM_in_7v:00000000 $t
     /tmp/ccxVmAlP.s:3736   .text._Z8PWM_in_7v:00000000 _Z8PWM_in_7v
     /tmp/ccxVmAlP.s:3750   .text._Z8PWM_in_6v:00000000 $t
     /tmp/ccxVmAlP.s:3755   .text._Z8PWM_in_6v:00000000 _Z8PWM_in_6v
     /tmp/ccxVmAlP.s:3769   .text._Z8PWM_in_5v:00000000 $t
     /tmp/ccxVmAlP.s:3774   .text._Z8PWM_in_5v:00000000 _Z8PWM_in_5v
     /tmp/ccxVmAlP.s:3788   .text._Z8PWM_in_4v:00000000 $t
     /tmp/ccxVmAlP.s:3793   .text._Z8PWM_in_4v:00000000 _Z8PWM_in_4v
     /tmp/ccxVmAlP.s:3807   .text._Z8PWM_in_3v:00000000 $t
     /tmp/ccxVmAlP.s:3812   .text._Z8PWM_in_3v:00000000 _Z8PWM_in_3v
     /tmp/ccxVmAlP.s:3826   .text._Z8PWM_in_2v:00000000 $t
     /tmp/ccxVmAlP.s:3831   .text._Z8PWM_in_2v:00000000 _Z8PWM_in_2v
     /tmp/ccxVmAlP.s:3845   .text._Z8PWM_in_1v:00000000 $t
     /tmp/ccxVmAlP.s:3850   .text._Z8PWM_in_1v:00000000 _Z8PWM_in_1v
     /tmp/ccxVmAlP.s:3864   .text._Z8PWM_in_0v:00000000 $t
     /tmp/ccxVmAlP.s:3869   .text._Z8PWM_in_0v:00000000 _Z8PWM_in_0v
     /tmp/ccxVmAlP.s:3883   .text._Z18initializeReceiveri:00000000 $t
     /tmp/ccxVmAlP.s:3888   .text._Z18initializeReceiveri:00000000 _Z18initializeReceiveri
     /tmp/ccxVmAlP.s:3911   .text._Z18getRawChannelValueh:00000000 $t
     /tmp/ccxVmAlP.s:3916   .text._Z18getRawChannelValueh:00000000 _Z18getRawChannelValueh
     /tmp/ccxVmAlP.s:3958   .text._Z18getRawChannelValueh:0000001c $d
     /tmp/ccxVmAlP.s:3964   .text._Z12readReceiverv:00000000 $t
     /tmp/ccxVmAlP.s:3969   .text._Z12readReceiverv:00000000 _Z12readReceiverv
     /tmp/ccxVmAlP.s:4103   .text._Z12readReceiverv:000000cc $d
     /tmp/ccxVmAlP.s:4116   .text._Z15setChannelValuehi:00000000 $t
     /tmp/ccxVmAlP.s:4121   .text._Z15setChannelValuehi:00000000 _Z15setChannelValuehi
     /tmp/ccxVmAlP.s:4135   .text._Z11writeMotorsv:00000000 $t
     /tmp/ccxVmAlP.s:4140   .text._Z11writeMotorsv:00000000 _Z11writeMotorsv
     /tmp/ccxVmAlP.s:4191   .text._Z11writeMotorsv:00000030 $d
     /tmp/ccxVmAlP.s:4199   .text._Z16commandAllMotorsi:00000000 $t
     /tmp/ccxVmAlP.s:4204   .text._Z16commandAllMotorsi:00000000 _Z16commandAllMotorsi
     /tmp/ccxVmAlP.s:4254   .text._Z16commandAllMotorsi:0000002c $d
     /tmp/ccxVmAlP.s:4261   .text._Z16initializeMotors9NB_Motors:00000000 $t
     /tmp/ccxVmAlP.s:4266   .text._Z16initializeMotors9NB_Motors:00000000 _Z16initializeMotors9NB_Motors
     /tmp/ccxVmAlP.s:4380   .text._Z16initializeMotors9NB_Motors:00000078 $d
     /tmp/ccxVmAlP.s:4389   .text._Z11pulseMotorsh:00000000 $t
     /tmp/ccxVmAlP.s:4394   .text._Z11pulseMotorsh:00000000 _Z11pulseMotorsh
     /tmp/ccxVmAlP.s:4445   .text._Z17cameraControlMoveiii:00000000 $t
     /tmp/ccxVmAlP.s:4450   .text._Z17cameraControlMoveiii:00000000 _Z17cameraControlMoveiii
     /tmp/ccxVmAlP.s:4501   .text._Z17cameraControlMoveiii:00000034 $d
     /tmp/ccxVmAlP.s:4506   .text._Z23initializeCameraControlv:00000000 $t
     /tmp/ccxVmAlP.s:4511   .text._Z23initializeCameraControlv:00000000 _Z23initializeCameraControlv
     /tmp/ccxVmAlP.s:4608   .text._Z23initializeCameraControlv:00000070 $d
     /tmp/ccxVmAlP.s:4616   .text._Z10moveCamerafff:00000000 $t
     /tmp/ccxVmAlP.s:4621   .text._Z10moveCamerafff:00000000 _Z10moveCamerafff
     /tmp/ccxVmAlP.s:4800   .text._Z10moveCamerafff:00000148 $d
     /tmp/ccxVmAlP.s:4817   .text._Z29initializeCameraStabilizationv:00000000 $t
     /tmp/ccxVmAlP.s:4822   .text._Z29initializeCameraStabilizationv:00000000 _Z29initializeCameraStabilizationv
     /tmp/ccxVmAlP.s:4847   .text._Z17applyMotorCommandv:00000000 $t
     /tmp/ccxVmAlP.s:4852   .text._Z17applyMotorCommandv:00000000 _Z17applyMotorCommandv
     /tmp/ccxVmAlP.s:4910   .text._Z17applyMotorCommandv:00000038 $d
     /tmp/ccxVmAlP.s:4919   .text._Z20calculateFlightErrorv:00000000 $t
     /tmp/ccxVmAlP.s:4924   .text._Z20calculateFlightErrorv:00000000 _Z20calculateFlightErrorv
     /tmp/ccxVmAlP.s:5053   .text._Z20calculateFlightErrorv:00000100 $d
     /tmp/ccxVmAlP.s:5072   .text._Z19processCalibrateESCv:00000000 $t
     /tmp/ccxVmAlP.s:5077   .text._Z19processCalibrateESCv:00000000 _Z19processCalibrateESCv
     /tmp/ccxVmAlP.s:5179   .text._Z19processCalibrateESCv:00000070 $d
     /tmp/ccxVmAlP.s:5189   .text._Z25processThrottleCorrectionv:00000000 $t
     /tmp/ccxVmAlP.s:5194   .text._Z25processThrottleCorrectionv:00000000 _Z25processThrottleCorrectionv
     /tmp/ccxVmAlP.s:5226   .text._Z25processThrottleCorrectionv:00000020 $d
     /tmp/ccxVmAlP.s:5231   .text._Z20processHardManueversv:00000000 $t
     /tmp/ccxVmAlP.s:5236   .text._Z20processHardManueversv:00000000 _Z20processHardManueversv
     /tmp/ccxVmAlP.s:5290   .text._Z20processHardManueversv:00000040 $d
     /tmp/ccxVmAlP.s:5300   .text._Z20processMinMaxCommandv:00000000 $t
     /tmp/ccxVmAlP.s:5305   .text._Z20processMinMaxCommandv:00000000 _Z20processMinMaxCommandv
     /tmp/ccxVmAlP.s:5393   .text._Z20processMinMaxCommandv:00000058 $d
     /tmp/ccxVmAlP.s:5401   .text._Z14processHeadingv:00000000 $t
     /tmp/ccxVmAlP.s:5406   .text._Z14processHeadingv:00000000 _Z14processHeadingv
     /tmp/ccxVmAlP.s:5621   .text._Z14processHeadingv:00000174 $d
     /tmp/ccxVmAlP.s:5649   .text._Z20processFlightControlv:00000000 $t
     /tmp/ccxVmAlP.s:5654   .text._Z20processFlightControlv:00000000 _Z20processFlightControlv
     /tmp/ccxVmAlP.s:5801   .text._Z20processFlightControlv:000000b0 $d
     /tmp/ccxVmAlP.s:5817   .text._Z12nvrReadFloati:00000000 $t
     /tmp/ccxVmAlP.s:5822   .text._Z12nvrReadFloati:00000000 _Z12nvrReadFloati
     /tmp/ccxVmAlP.s:5864   .text._Z12nvrReadFloati:00000024 $d
     /tmp/ccxVmAlP.s:5869   .text._Z13nvrWriteFloatfi:00000000 $t
     /tmp/ccxVmAlP.s:5874   .text._Z13nvrWriteFloatfi:00000000 _Z13nvrWriteFloatfi
     /tmp/ccxVmAlP.s:5917   .text._Z13nvrWriteFloatfi:00000020 $d
     /tmp/ccxVmAlP.s:5924   .text._Z11nvrReadLongi:00000000 $t
     /tmp/ccxVmAlP.s:5929   .text._Z11nvrReadLongi:00000000 _Z11nvrReadLongi
     /tmp/ccxVmAlP.s:5969   .text._Z11nvrReadLongi:00000024 $d
     /tmp/ccxVmAlP.s:5974   .text._Z12nvrWriteLongli:00000000 $t
     /tmp/ccxVmAlP.s:5979   .text._Z12nvrWriteLongli:00000000 _Z12nvrWriteLongli
     /tmp/ccxVmAlP.s:6021   .text._Z12nvrWriteLongli:00000020 $d
     /tmp/ccxVmAlP.s:6028   .text._Z10nvrReadPIDhj:00000000 $t
     /tmp/ccxVmAlP.s:6033   .text._Z10nvrReadPIDhj:00000000 _Z10nvrReadPIDhj
     /tmp/ccxVmAlP.s:6089   .text._Z10nvrReadPIDhj:00000030 $d
     /tmp/ccxVmAlP.s:6094   .text._Z11nvrWritePIDhj:00000000 $t
     /tmp/ccxVmAlP.s:6099   .text._Z11nvrWritePIDhj:00000000 _Z11nvrWritePIDhj
     /tmp/ccxVmAlP.s:6144   .text._Z11nvrWritePIDhj:00000028 $d
     /tmp/ccxVmAlP.s:6150   .text._Z16initializeEEPROMv:00000000 $t
     /tmp/ccxVmAlP.s:6155   .text._Z16initializeEEPROMv:00000000 _Z16initializeEEPROMv
     /tmp/ccxVmAlP.s:6389   .text._Z16initializeEEPROMv:00000110 $d
     /tmp/ccxVmAlP.s:6432   .text._Z10readEEPROMv:00000000 $t
     /tmp/ccxVmAlP.s:6437   .text._Z10readEEPROMv:00000000 _Z10readEEPROMv
     /tmp/ccxVmAlP.s:6653   .text._Z10readEEPROMv:000001d8 $d
     /tmp/ccxVmAlP.s:6678   .text._Z11writeEEPROMv:00000000 $t
     /tmp/ccxVmAlP.s:6683   .text._Z11writeEEPROMv:00000000 _Z11writeEEPROMv
     /tmp/ccxVmAlP.s:6965   .text._Z11writeEEPROMv:00000270 $d
     /tmp/ccxVmAlP.s:6999   .text._Z25initSensorsZeroFromEEPROMv:00000000 $t
     /tmp/ccxVmAlP.s:7004   .text._Z25initSensorsZeroFromEEPROMv:00000000 _Z25initSensorsZeroFromEEPROMv
     /tmp/ccxVmAlP.s:7055   .text._Z25initSensorsZeroFromEEPROMv:00000050 $d
     /tmp/ccxVmAlP.s:7062   .text._Z24storeSensorsZeroToEEPROMv:00000000 $t
     /tmp/ccxVmAlP.s:7067   .text._Z24storeSensorsZeroToEEPROMv:00000000 _Z24storeSensorsZeroToEEPROMv
     /tmp/ccxVmAlP.s:7121   .text._Z24storeSensorsZeroToEEPROMv:00000054 $d
     /tmp/ccxVmAlP.s:7128   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:00000000 $t
     /tmp/ccxVmAlP.s:7133   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:00000000 _Z46processZeroThrottleFunctionFromReceiverCommandv
     /tmp/ccxVmAlP.s:7252   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:00000098 $d
     /tmp/ccxVmAlP.s:7262   .text._Z17readPilotCommandsv:00000000 $t
     /tmp/ccxVmAlP.s:7267   .text._Z17readPilotCommandsv:00000000 _Z17readPilotCommandsv
     /tmp/ccxVmAlP.s:7338   .text._Z17readPilotCommandsv:0000005c $d
     /tmp/ccxVmAlP.s:7348   .text._Z22initReceiverFromEEPROMv:00000000 $t
     /tmp/ccxVmAlP.s:7353   .text._Z22initReceiverFromEEPROMv:00000000 _Z22initReceiverFromEEPROMv
     /tmp/ccxVmAlP.s:7407   .text._Z22initReceiverFromEEPROMv:00000044 $d
     /tmp/ccxVmAlP.s:7415   .text._Z17initCommunicationv:00000000 $t
     /tmp/ccxVmAlP.s:7420   .text._Z17initCommunicationv:00000000 _Z17initCommunicationv
     /tmp/ccxVmAlP.s:7434   .text._Z10getHeadingv:00000000 $t
     /tmp/ccxVmAlP.s:7439   .text._Z10getHeadingv:00000000 _Z10getHeadingv
     /tmp/ccxVmAlP.s:7453   .text._Z10getHeadingv:00000008 $d
     /tmp/ccxVmAlP.s:7458   .text._Z15readValueSerialPch:00000000 $t
     /tmp/ccxVmAlP.s:7463   .text._Z15readValueSerialPch:00000000 _Z15readValueSerialPch
     /tmp/ccxVmAlP.s:7548   .text._Z15readValueSerialPch:0000004c $d
     /tmp/ccxVmAlP.s:7553   .text._Z15readFloatSerialv:00000000 $t
     /tmp/ccxVmAlP.s:7558   .text._Z15readFloatSerialv:00000000 _Z15readFloatSerialv
     /tmp/ccxVmAlP.s:7596   .text._Z16skipSerialValuesh:00000000 $t
     /tmp/ccxVmAlP.s:7601   .text._Z16skipSerialValuesh:00000000 _Z16skipSerialValuesh
     /tmp/ccxVmAlP.s:7641   .text._Z13readSerialPIDh:00000000 $t
     /tmp/ccxVmAlP.s:7646   .text._Z13readSerialPIDh:00000000 _Z13readSerialPIDh
     /tmp/ccxVmAlP.s:7691   .text._Z13readSerialPIDh:00000024 $d
     /tmp/ccxVmAlP.s:7696   .text._Z24validateCalibrateCommandh:00000000 $t
     /tmp/ccxVmAlP.s:7701   .text._Z24validateCalibrateCommandh:00000000 _Z24validateCalibrateCommandh
     /tmp/ccxVmAlP.s:7746   .text._Z24validateCalibrateCommandh:00000038 $d
     /tmp/ccxVmAlP.s:7754   .text._Z17readSerialCommandv:00000000 $t
     /tmp/ccxVmAlP.s:7759   .text._Z17readSerialCommandv:00000000 _Z17readSerialCommandv
     /tmp/ccxVmAlP.s:7791   .text._Z17readSerialCommandv:00000024 $d
     /tmp/ccxVmAlP.s:7838   .text._Z17readSerialCommandv:00000078 $t
     /tmp/ccxVmAlP.s:8104   .text._Z17readSerialCommandv:00000274 $d
     /tmp/ccxVmAlP.s:8132   .text._Z17readSerialCommandv:000002dc $t
     /tmp/ccxVmAlP.s:8264   .text._Z17readSerialCommandv:00000388 $d
     /tmp/ccxVmAlP.s:8276   .text._Z17readIntegerSerialv:00000000 $t
     /tmp/ccxVmAlP.s:8281   .text._Z17readIntegerSerialv:00000000 _Z17readIntegerSerialv
     /tmp/ccxVmAlP.s:8318   .text._Z5commav:00000000 $t
     /tmp/ccxVmAlP.s:8323   .text._Z5commav:00000000 _Z5commav
     /tmp/ccxVmAlP.s:8339   .text._Z5commav:00000008 $d
     /tmp/ccxVmAlP.s:8344   .text._Z15PrintValueCommal:00000000 $t
     /tmp/ccxVmAlP.s:8349   .text._Z15PrintValueCommal:00000000 _Z15PrintValueCommal
     /tmp/ccxVmAlP.s:8376   .text._Z15PrintValueCommal:00000014 $d
     /tmp/ccxVmAlP.s:8381   .text._Z15PrintValueCommah:00000000 $t
     /tmp/ccxVmAlP.s:8386   .text._Z15PrintValueCommah:00000000 _Z15PrintValueCommah
     /tmp/ccxVmAlP.s:8412   .text._Z15PrintValueCommah:00000014 $d
     /tmp/ccxVmAlP.s:8417   .text._Z15PrintValueCommam:00000000 $t
     /tmp/ccxVmAlP.s:8422   .text._Z15PrintValueCommam:00000000 _Z15PrintValueCommam
     /tmp/ccxVmAlP.s:8449   .text._Z15PrintValueCommam:00000014 $d
     /tmp/ccxVmAlP.s:8454   .text._Z15PrintValueCommai:00000000 $t
     /tmp/ccxVmAlP.s:8459   .text._Z15PrintValueCommai:00000000 _Z15PrintValueCommai
     /tmp/ccxVmAlP.s:8486   .text._Z15PrintValueCommai:00000014 $d
     /tmp/ccxVmAlP.s:8491   .text._Z16PrintDummyValuesh:00000000 $t
     /tmp/ccxVmAlP.s:8496   .text._Z16PrintDummyValuesh:00000000 _Z16PrintDummyValuesh
     /tmp/ccxVmAlP.s:8537   .text._Z15PrintValueCommac:00000000 $t
     /tmp/ccxVmAlP.s:8542   .text._Z15PrintValueCommac:00000000 _Z15PrintValueCommac
     /tmp/ccxVmAlP.s:8567   .text._Z15PrintValueCommac:00000014 $d
     /tmp/ccxVmAlP.s:8572   .text._Z15PrintValueCommad:00000000 $t
     /tmp/ccxVmAlP.s:8577   .text._Z15PrintValueCommad:00000000 _Z15PrintValueCommad
     /tmp/ccxVmAlP.s:8608   .text._Z15PrintValueCommad:0000001c $d
     /tmp/ccxVmAlP.s:8613   .text._Z15PrintValueCommaf:00000000 $t
     /tmp/ccxVmAlP.s:8618   .text._Z15PrintValueCommaf:00000000 _Z15PrintValueCommaf
     /tmp/ccxVmAlP.s:8649   .text._Z15PrintValueCommaf:00000020 $d
     /tmp/ccxVmAlP.s:8654   .text._Z8PrintPIDh:00000000 $t
     /tmp/ccxVmAlP.s:8659   .text._Z8PrintPIDh:00000000 _Z8PrintPIDh
     /tmp/ccxVmAlP.s:8692   .text._Z8PrintPIDh:00000020 $d
     /tmp/ccxVmAlP.s:8697   .text._Z17printVehicleStatePKcmS0_:00000000 $t
     /tmp/ccxVmAlP.s:8702   .text._Z17printVehicleStatePKcmS0_:00000000 _Z17printVehicleStatePKcmS0_
     /tmp/ccxVmAlP.s:8754   .text._Z17printVehicleStatePKcmS0_:00000034 $d
     /tmp/ccxVmAlP.s:8762   .text._Z18reportVehicleStatev:00000000 $t
     /tmp/ccxVmAlP.s:8767   .text._Z18reportVehicleStatev:00000000 _Z18reportVehicleStatev
     /tmp/ccxVmAlP.s:8886   .text._Z18reportVehicleStatev:000000d8 $d
     /tmp/ccxVmAlP.s:8912   .text._Z19sendSerialTelemetryv:00000000 $t
     /tmp/ccxVmAlP.s:8917   .text._Z19sendSerialTelemetryv:00000000 _Z19sendSerialTelemetryv
     /tmp/ccxVmAlP.s:9314   .text._Z19sendSerialTelemetryv:000002a8 $d
     /tmp/ccxVmAlP.s:9333   .text._Z19sendSerialTelemetryv:000002ec $t
     /tmp/ccxVmAlP.s:9605   .text._Z19sendSerialTelemetryv:00000488 $d
     /tmp/ccxVmAlP.s:9631   .text._Z5setupv:00000000 $t
     /tmp/ccxVmAlP.s:9636   .text._Z5setupv:00000000 _Z5setupv
     /tmp/ccxVmAlP.s:9748   .text._Z5setupv:000000b4 $d
     /tmp/ccxVmAlP.s:9758   .text._Z16process100HzTaskv:00000000 $t
     /tmp/ccxVmAlP.s:9763   .text._Z16process100HzTaskv:00000000 _Z16process100HzTaskv
     /tmp/ccxVmAlP.s:9859   .text._Z16process100HzTaskv:00000088 $d
     /tmp/ccxVmAlP.s:9874   .text._Z15process50HzTaskv:00000000 $t
     /tmp/ccxVmAlP.s:9879   .text._Z15process50HzTaskv:00000000 _Z15process50HzTaskv
     /tmp/ccxVmAlP.s:9907   .text._Z15process50HzTaskv:00000028 $d
     /tmp/ccxVmAlP.s:9915   .text._Z16process10HzTask1v:00000000 $t
     /tmp/ccxVmAlP.s:9920   .text._Z16process10HzTask1v:00000000 _Z16process10HzTask1v
     /tmp/ccxVmAlP.s:9933   .text._Z16process10HzTask2v:00000000 $t
     /tmp/ccxVmAlP.s:9938   .text._Z16process10HzTask2v:00000000 _Z16process10HzTask2v
     /tmp/ccxVmAlP.s:9973   .text._Z16process10HzTask2v:00000030 $d
     /tmp/ccxVmAlP.s:9981   .text._Z16process10HzTask3v:00000000 $t
     /tmp/ccxVmAlP.s:9986   .text._Z16process10HzTask3v:00000000 _Z16process10HzTask3v
     /tmp/ccxVmAlP.s:10013  .text._Z16process10HzTask3v:00000024 $d
     /tmp/ccxVmAlP.s:10021  .text._Z14process1HzTaskv:00000000 $t
     /tmp/ccxVmAlP.s:10026  .text._Z14process1HzTaskv:00000000 _Z14process1HzTaskv
     /tmp/ccxVmAlP.s:10039  .text._Z4loopv:00000000 $t
     /tmp/ccxVmAlP.s:10044  .text._Z4loopv:00000000 _Z4loopv
     /tmp/ccxVmAlP.s:10138  .text._Z4loopv:00000080 $d
     /tmp/ccxVmAlP.s:10149  .text.startup.main:00000000 $t
     /tmp/ccxVmAlP.s:10154  .text.startup.main:00000000 main
     /tmp/ccxVmAlP.s:10175  .text.startup._GLOBAL__sub_I__Z7premainv:00000000 $t
     /tmp/ccxVmAlP.s:10179  .text.startup._GLOBAL__sub_I__Z7premainv:00000000 _GLOBAL__sub_I__Z7premainv
     /tmp/ccxVmAlP.s:853    .text._ZN14HardwareSPIExtC2Ej:00000000 _ZN14HardwareSPIExtC1Ej
     /tmp/ccxVmAlP.s:10208  .text.startup._GLOBAL__sub_I__Z7premainv:00000014 $d
     /tmp/ccxVmAlP.s:10479  .data.queryType:00000000 queryType
     /tmp/ccxVmAlP.s:10828  .bss.headingTime:00000000 headingTime
     /tmp/ccxVmAlP.s:10753  .bss.setHeading:00000000 setHeading
     /tmp/ccxVmAlP.s:11018  .bss.motorConfiguratorCommand:00000000 motorConfiguratorCommand
     /tmp/ccxVmAlP.s:10383  .bss.motorMinCommand:00000000 motorMinCommand
     /tmp/ccxVmAlP.s:11032  .bss.motorMaxCommand:00000000 motorMaxCommand
     /tmp/ccxVmAlP.s:11046  .bss.motorAxisCommandYaw:00000000 motorAxisCommandYaw
     /tmp/ccxVmAlP.s:10425  .bss.motorAxisCommandPitch:00000000 motorAxisCommandPitch
     /tmp/ccxVmAlP.s:11127  .bss.motorAxisCommandRoll:00000000 motorAxisCommandRoll
     /tmp/ccxVmAlP.s:10992  .bss.servoMaxYaw:00000000 servoMaxYaw
     /tmp/ccxVmAlP.s:10376  .bss.servoMaxRoll:00000000 servoMaxRoll
     /tmp/ccxVmAlP.s:10525  .bss.servoMaxPitch:00000000 servoMaxPitch
     /tmp/ccxVmAlP.s:11155  .bss.servoMinYaw:00000000 servoMinYaw
     /tmp/ccxVmAlP.s:10335  .bss.servoMinRoll:00000000 servoMinRoll
     /tmp/ccxVmAlP.s:10938  .bss.servoMinPitch:00000000 servoMinPitch
     /tmp/ccxVmAlP.s:10651  .bss.servoCenterYaw:00000000 servoCenterYaw
     /tmp/ccxVmAlP.s:10466  .bss.servoCenterRoll:00000000 servoCenterRoll
     /tmp/ccxVmAlP.s:10486  .bss.servoCenterPitch:00000000 servoCenterPitch
     /tmp/ccxVmAlP.s:10342  .bss.mCameraYaw:00000000 mCameraYaw
     /tmp/ccxVmAlP.s:11183  .bss.mCameraRoll:00000000 mCameraRoll
     /tmp/ccxVmAlP.s:10369  .bss.mCameraPitch:00000000 mCameraPitch
     /tmp/ccxVmAlP.s:11081  .bss.cameraMode:00000000 cameraMode
     /tmp/ccxVmAlP.s:10499  .bss.motorCommand:00000000 motorCommand
     /tmp/ccxVmAlP.s:10504  .data.numberOfMotors:00000000 numberOfMotors
     /tmp/ccxVmAlP.s:10404  .data.PWM_in_handler:00000000 PWM_in_handler
     /tmp/ccxVmAlP.s:10439  .bss.FrqData:00000000 FrqData
     /tmp/ccxVmAlP.s:10459  .bss.previousEz:00000000 previousEz
     /tmp/ccxVmAlP.s:10598  .bss.previousEy:00000000 previousEy
     /tmp/ccxVmAlP.s:10591  .bss.previousEx:00000000 previousEx
     /tmp/ccxVmAlP.s:10518  .bss.ezInt:00000000 ezInt
     /tmp/ccxVmAlP.s:10584  .bss.eyInt:00000000 eyInt
     /tmp/ccxVmAlP.s:10971  .bss.exInt:00000000 exInt
     /tmp/ccxVmAlP.s:10718  .bss.q3:00000000 q3
     /tmp/ccxVmAlP.s:10711  .bss.q2:00000000 q2
     /tmp/ccxVmAlP.s:10704  .bss.q1:00000000 q1
     /tmp/ccxVmAlP.s:10564  .bss.q0:00000000 q0
     /tmp/ccxVmAlP.s:10760  .bss.halfT:00000000 halfT
     /tmp/ccxVmAlP.s:10793  .bss.Ki:00000000 Ki
     /tmp/ccxVmAlP.s:10814  .bss.Kp:00000000 Kp
     /tmp/ccxVmAlP.s:10657  .bss.accelCutoff:00000000 accelCutoff
     /tmp/ccxVmAlP.s:10998  .bss.earthAccel:00000000 earthAccel
     /tmp/ccxVmAlP.s:10774  .bss.correctedRateVector:00000000 correctedRateVector
     /tmp/ccxVmAlP.s:11067  .bss.gyroAngle:00000000 gyroAngle
     /tmp/ccxVmAlP.s:10912  .bss.kinematicsAngle:00000000 kinematicsAngle
     /tmp/ccxVmAlP.s:11086  .bss.kinematicsType:00000000 kinematicsType
     /tmp/ccxVmAlP.s:10473  .bss.previousMeasureCriticalSensorsTime:00000000 previousMeasureCriticalSensorsTime
     /tmp/ccxVmAlP.s:10577  .bss.accelSampleCount:00000000 accelSampleCount
     /tmp/ccxVmAlP.s:10725  .bss.accelSample:00000000 accelSample
     /tmp/ccxVmAlP.s:11100  .bss.meterPerSecSec:00000000 meterPerSecSec
     /tmp/ccxVmAlP.s:10511  .bss.accelOneG:00000000 accelOneG
     /tmp/ccxVmAlP.s:11190  .bss.runTimeAccelBias:00000000 runTimeAccelBias
     /tmp/ccxVmAlP.s:10746  .bss.accelScaleFactor:00000000 accelScaleFactor
     /tmp/ccxVmAlP.s:11011  .bss.gyroSampleCount:00000000 gyroSampleCount
     /tmp/ccxVmAlP.s:11005  .bss.gyroLastMesuredTime:00000000 gyroLastMesuredTime
     /tmp/ccxVmAlP.s:10390  .bss.gyroHeading:00000000 gyroHeading
     /tmp/ccxVmAlP.s:11162  .bss.gyroScaleFactor:00000000 gyroScaleFactor
     /tmp/ccxVmAlP.s:11169  .bss.gyroSample:00000000 gyroSample
     /tmp/ccxVmAlP.s:10985  .bss.gyroZero:00000000 gyroZero
     /tmp/ccxVmAlP.s:10898  .bss.gyroRate:00000000 gyroRate
     /tmp/ccxVmAlP.s:10612  .bss.readMPU6000GyroCount:00000000 readMPU6000GyroCount
     /tmp/ccxVmAlP.s:10821  .bss.readMPU6000AccelCount:00000000 readMPU6000AccelCount
     /tmp/ccxVmAlP.s:10446  .bss.readMPU6000Count:00000000 readMPU6000Count
     /tmp/ccxVmAlP.s:10877  .bss.initializeMPU6000SensorsDone:00000000 initializeMPU6000SensorsDone
     /tmp/ccxVmAlP.s:10945  .bss.spiMPU6000:00000000 spiMPU6000
     /tmp/ccxVmAlP.s:10349  .bss.MPU6000:00000000 MPU6000
     /tmp/ccxVmAlP.s:11120  .bss.vehicleState:00000000 vehicleState
     /tmp/ccxVmAlP.s:10884  .bss.gyroRaw:00000000 gyroRaw
     /tmp/ccxVmAlP.s:10618  .rodata.Serial:00000000 Serial
     /tmp/ccxVmAlP.s:10952  .bss.fourthOrder:00000000 fourthOrder
     /tmp/ccxVmAlP.s:11025  .bss.windupGuard:00000000 windupGuard
     /tmp/ccxVmAlP.s:10905  .bss.PID:00000000 PID
     /tmp/ccxVmAlP.s:10624  .bss.fastTransfer:00000000 fastTransfer
     /tmp/ccxVmAlP.s:10531  .bss.headingHoldState:00000000 headingHoldState
     /tmp/ccxVmAlP.s:10684  .bss.relativeHeading:00000000 relativeHeading
     /tmp/ccxVmAlP.s:10605  .bss.heading:00000000 heading
     /tmp/ccxVmAlP.s:10767  .bss.headingHold:00000000 headingHold
     /tmp/ccxVmAlP.s:10958  .bss.headingHoldConfig:00000000 headingHoldConfig
     /tmp/ccxVmAlP.s:10732  .bss.aref:00000000 aref
     /tmp/ccxVmAlP.s:11148  .bss.hundredHZpreviousTime:00000000 hundredHZpreviousTime
     /tmp/ccxVmAlP.s:10631  .bss.fiftyHZpreviousTime:00000000 fiftyHZpreviousTime
     /tmp/ccxVmAlP.s:10919  .bss.lowPriorityTenHZpreviousTime2:00000000 lowPriorityTenHZpreviousTime2
     /tmp/ccxVmAlP.s:11053  .bss.lowPriorityTenHZpreviousTime:00000000 lowPriorityTenHZpreviousTime
     /tmp/ccxVmAlP.s:10452  .bss.tenHZpreviousTime:00000000 tenHZpreviousTime
     /tmp/ccxVmAlP.s:10637  .bss.oneHZpreviousTime:00000000 oneHZpreviousTime
     /tmp/ccxVmAlP.s:10644  .bss.deltaTime:00000000 deltaTime
     /tmp/ccxVmAlP.s:10571  .bss.currentTime:00000000 currentTime
     /tmp/ccxVmAlP.s:11134  .bss.previousTime:00000000 previousTime
     /tmp/ccxVmAlP.s:10418  .data.rotationSpeedFactor:00000000 rotationSpeedFactor
     /tmp/ccxVmAlP.s:10964  .bss.inFlight:00000000 inFlight
     /tmp/ccxVmAlP.s:10397  .bss.filteredAccel:00000000 filteredAccel
     /tmp/ccxVmAlP.s:10662  .bss.minLimit:00000000 minLimit
     /tmp/ccxVmAlP.s:10779  .bss.maxLimit:00000000 maxLimit
     /tmp/ccxVmAlP.s:10492  .bss.safetyCheck:00000000 safetyCheck
     /tmp/ccxVmAlP.s:10362  .bss.motorArmed:00000000 motorArmed
     /tmp/ccxVmAlP.s:10891  .data.throttle:00000000 throttle
     /tmp/ccxVmAlP.s:11141  .data.G_Dt:00000000 G_Dt
     /tmp/ccxVmAlP.s:10807  .bss.minArmedThrottle:00000000 minArmedThrottle
     /tmp/ccxVmAlP.s:10786  .bss.frameCounter:00000000 frameCounter
     /tmp/ccxVmAlP.s:11113  .bss.flightMode:00000000 flightMode
     /tmp/ccxVmAlP.s:10925  .data.previousFlightMode:00000000 previousFlightMode
     /tmp/ccxVmAlP.s:10669  .data.testCommand:00000000 testCommand
     /tmp/ccxVmAlP.s:10931  .bss.calibrateESC:00000000 calibrateESC
     /tmp/ccxVmAlP.s:11060  .bss.channelCal:00000000 channelCal
     /tmp/ccxVmAlP.s:10432  .bss.receiverSmoothFactor:00000000 receiverSmoothFactor
     /tmp/ccxVmAlP.s:11074  .bss.receiverOffset:00000000 receiverOffset
     /tmp/ccxVmAlP.s:11107  .bss.receiverSlope:00000000 receiverSlope
     /tmp/ccxVmAlP.s:10800  .bss.receiverCommandSmooth:00000000 receiverCommandSmooth
     /tmp/ccxVmAlP.s:10739  .bss.receiverCommand:00000000 receiverCommand
     /tmp/ccxVmAlP.s:11039  .bss.receiverZero:00000000 receiverZero
     /tmp/ccxVmAlP.s:10356  .bss.receiverData:00000000 receiverData
     /tmp/ccxVmAlP.s:10978  .bss.receiverXmitFactor:00000000 receiverXmitFactor
     /tmp/ccxVmAlP.s:11093  .bss.lastReceiverChannel:00000000 lastReceiverChannel
     /tmp/ccxVmAlP.s:10331  .bss.servoMinRoll:00000000 $d
     /tmp/ccxVmAlP.s:10338  .bss.mCameraYaw:00000000 $d
     /tmp/ccxVmAlP.s:10345  .bss.MPU6000:00000000 $d
     /tmp/ccxVmAlP.s:10352  .bss.receiverData:00000000 $d
     /tmp/ccxVmAlP.s:10363  .bss.motorArmed:00000000 $d
     /tmp/ccxVmAlP.s:10365  .bss.mCameraPitch:00000000 $d
     /tmp/ccxVmAlP.s:10372  .bss.servoMaxRoll:00000000 $d
     /tmp/ccxVmAlP.s:10379  .bss.motorMinCommand:00000000 $d
     /tmp/ccxVmAlP.s:10386  .bss.gyroHeading:00000000 $d
     /tmp/ccxVmAlP.s:10393  .bss.filteredAccel:00000000 $d
     /tmp/ccxVmAlP.s:10400  .data.PWM_in_handler:00000000 $d
     /tmp/ccxVmAlP.s:10414  .data.rotationSpeedFactor:00000000 $d
     /tmp/ccxVmAlP.s:10421  .bss.motorAxisCommandPitch:00000000 $d
     /tmp/ccxVmAlP.s:10428  .bss.receiverSmoothFactor:00000000 $d
     /tmp/ccxVmAlP.s:10435  .bss.FrqData:00000000 $d
     /tmp/ccxVmAlP.s:10442  .bss.readMPU6000Count:00000000 $d
     /tmp/ccxVmAlP.s:10449  .bss.tenHZpreviousTime:00000000 $d
     /tmp/ccxVmAlP.s:10455  .bss.previousEz:00000000 $d
     /tmp/ccxVmAlP.s:10462  .bss.servoCenterRoll:00000000 $d
     /tmp/ccxVmAlP.s:10469  .bss.previousMeasureCriticalSensorsTime:00000000 $d
     /tmp/ccxVmAlP.s:10482  .bss.servoCenterPitch:00000000 $d
     /tmp/ccxVmAlP.s:10493  .bss.safetyCheck:00000000 $d
     /tmp/ccxVmAlP.s:10495  .bss.motorCommand:00000000 $d
     /tmp/ccxVmAlP.s:10507  .bss.accelOneG:00000000 $d
     /tmp/ccxVmAlP.s:10514  .bss.ezInt:00000000 $d
     /tmp/ccxVmAlP.s:10521  .bss.servoMaxPitch:00000000 $d
     /tmp/ccxVmAlP.s:10532  .bss.headingHoldState:00000000 $d
     /tmp/ccxVmAlP.s:10537  .rodata._ZL18ReceiverChannelMap:00000000 _ZL18ReceiverChannelMap
     /tmp/ccxVmAlP.s:10550  .rodata._ZL19stm32_motor_mapping:00000000 _ZL19stm32_motor_mapping
     /tmp/ccxVmAlP.s:10560  .bss.q0:00000000 $d
     /tmp/ccxVmAlP.s:10567  .bss.currentTime:00000000 $d
     /tmp/ccxVmAlP.s:10578  .bss.accelSampleCount:00000000 $d
     /tmp/ccxVmAlP.s:10580  .bss.eyInt:00000000 $d
     /tmp/ccxVmAlP.s:10587  .bss.previousEx:00000000 $d
     /tmp/ccxVmAlP.s:10594  .bss.previousEy:00000000 $d
     /tmp/ccxVmAlP.s:10601  .bss.heading:00000000 $d
     /tmp/ccxVmAlP.s:10608  .bss.readMPU6000GyroCount:00000000 $d
     /tmp/ccxVmAlP.s:10615  .rodata.Serial:00000000 $d
     /tmp/ccxVmAlP.s:10625  .bss.fastTransfer:00000000 $d
     /tmp/ccxVmAlP.s:10627  .bss.fiftyHZpreviousTime:00000000 $d
     /tmp/ccxVmAlP.s:10634  .bss.oneHZpreviousTime:00000000 $d
     /tmp/ccxVmAlP.s:10640  .bss.deltaTime:00000000 $d
     /tmp/ccxVmAlP.s:10647  .bss.servoCenterYaw:00000000 $d
     /tmp/ccxVmAlP.s:10654  .bss.accelCutoff:00000000 $d
     /tmp/ccxVmAlP.s:10663  .bss.minLimit:00000000 $d
     /tmp/ccxVmAlP.s:10665  .data.testCommand:00000000 $d
     /tmp/ccxVmAlP.s:10675  .rodata._ZL9servopins:00000000 _ZL9servopins
     /tmp/ccxVmAlP.s:10680  .bss.relativeHeading:00000000 $d
     /tmp/ccxVmAlP.s:10690  .rodata._ZL11receiverPin:00000000 _ZL11receiverPin
     /tmp/ccxVmAlP.s:10700  .bss.q1:00000000 $d
     /tmp/ccxVmAlP.s:10707  .bss.q2:00000000 $d
     /tmp/ccxVmAlP.s:10714  .bss.q3:00000000 $d
     /tmp/ccxVmAlP.s:10721  .bss.accelSample:00000000 $d
     /tmp/ccxVmAlP.s:10728  .bss.aref:00000000 $d
     /tmp/ccxVmAlP.s:10735  .bss.receiverCommand:00000000 $d
     /tmp/ccxVmAlP.s:10742  .bss.accelScaleFactor:00000000 $d
     /tmp/ccxVmAlP.s:10749  .bss.setHeading:00000000 $d
     /tmp/ccxVmAlP.s:10756  .bss.halfT:00000000 $d
     /tmp/ccxVmAlP.s:10763  .bss.headingHold:00000000 $d
     /tmp/ccxVmAlP.s:10770  .bss.correctedRateVector:00000000 $d
     /tmp/ccxVmAlP.s:10780  .bss.maxLimit:00000000 $d
     /tmp/ccxVmAlP.s:10782  .bss.frameCounter:00000000 $d
     /tmp/ccxVmAlP.s:10789  .bss.Ki:00000000 $d
     /tmp/ccxVmAlP.s:10796  .bss.receiverCommandSmooth:00000000 $d
     /tmp/ccxVmAlP.s:10803  .bss.minArmedThrottle:00000000 $d
     /tmp/ccxVmAlP.s:10810  .bss.Kp:00000000 $d
     /tmp/ccxVmAlP.s:10817  .bss.readMPU6000AccelCount:00000000 $d
     /tmp/ccxVmAlP.s:10824  .bss.headingTime:00000000 $d
     /tmp/ccxVmAlP.s:10878  .bss.initializeMPU6000SensorsDone:00000000 $d
     /tmp/ccxVmAlP.s:10880  .bss.gyroRaw:00000000 $d
     /tmp/ccxVmAlP.s:10887  .data.throttle:00000000 $d
     /tmp/ccxVmAlP.s:10894  .bss.gyroRate:00000000 $d
     /tmp/ccxVmAlP.s:10901  .bss.PID:00000000 $d
     /tmp/ccxVmAlP.s:10908  .bss.kinematicsAngle:00000000 $d
     /tmp/ccxVmAlP.s:10915  .bss.lowPriorityTenHZpreviousTime2:00000000 $d
     /tmp/ccxVmAlP.s:10932  .bss.calibrateESC:00000000 $d
     /tmp/ccxVmAlP.s:10934  .bss.servoMinPitch:00000000 $d
     /tmp/ccxVmAlP.s:10941  .bss.spiMPU6000:00000000 $d
     /tmp/ccxVmAlP.s:10948  .bss.fourthOrder:00000000 $d
     /tmp/ccxVmAlP.s:10959  .bss.headingHoldConfig:00000000 $d
     /tmp/ccxVmAlP.s:10965  .bss.inFlight:00000000 $d
     /tmp/ccxVmAlP.s:10967  .bss.exInt:00000000 $d
     /tmp/ccxVmAlP.s:10974  .bss.receiverXmitFactor:00000000 $d
     /tmp/ccxVmAlP.s:10981  .bss.gyroZero:00000000 $d
     /tmp/ccxVmAlP.s:10988  .bss.servoMaxYaw:00000000 $d
     /tmp/ccxVmAlP.s:10995  .bss.earthAccel:00000000 $d
     /tmp/ccxVmAlP.s:11001  .bss.gyroLastMesuredTime:00000000 $d
     /tmp/ccxVmAlP.s:11012  .bss.gyroSampleCount:00000000 $d
     /tmp/ccxVmAlP.s:11014  .bss.motorConfiguratorCommand:00000000 $d
     /tmp/ccxVmAlP.s:11021  .bss.windupGuard:00000000 $d
     /tmp/ccxVmAlP.s:11028  .bss.motorMaxCommand:00000000 $d
     /tmp/ccxVmAlP.s:11035  .bss.receiverZero:00000000 $d
     /tmp/ccxVmAlP.s:11042  .bss.motorAxisCommandYaw:00000000 $d
     /tmp/ccxVmAlP.s:11049  .bss.lowPriorityTenHZpreviousTime:00000000 $d
     /tmp/ccxVmAlP.s:11056  .bss.channelCal:00000000 $d
     /tmp/ccxVmAlP.s:11063  .bss.gyroAngle:00000000 $d
     /tmp/ccxVmAlP.s:11070  .bss.receiverOffset:00000000 $d
     /tmp/ccxVmAlP.s:11077  .bss.cameraMode:00000000 $d
     /tmp/ccxVmAlP.s:11087  .bss.kinematicsType:00000000 $d
     /tmp/ccxVmAlP.s:11089  .bss.lastReceiverChannel:00000000 $d
     /tmp/ccxVmAlP.s:11096  .bss.meterPerSecSec:00000000 $d
     /tmp/ccxVmAlP.s:11103  .bss.receiverSlope:00000000 $d
     /tmp/ccxVmAlP.s:11114  .bss.flightMode:00000000 $d
     /tmp/ccxVmAlP.s:11116  .bss.vehicleState:00000000 $d
     /tmp/ccxVmAlP.s:11123  .bss.motorAxisCommandRoll:00000000 $d
     /tmp/ccxVmAlP.s:11130  .bss.previousTime:00000000 $d
     /tmp/ccxVmAlP.s:11137  .data.G_Dt:00000000 $d
     /tmp/ccxVmAlP.s:11144  .bss.hundredHZpreviousTime:00000000 $d
     /tmp/ccxVmAlP.s:11151  .bss.servoMinYaw:00000000 $d
     /tmp/ccxVmAlP.s:11158  .bss.gyroScaleFactor:00000000 $d
     /tmp/ccxVmAlP.s:11165  .bss.gyroSample:00000000 $d
     /tmp/ccxVmAlP.s:11172  .bss._ZL19_stm32_motor_number:00000000 $d
     /tmp/ccxVmAlP.s:11176  .bss._ZL19_stm32_motor_number:00000000 _ZL19_stm32_motor_number
     /tmp/ccxVmAlP.s:11179  .bss.mCameraRoll:00000000 $d
     /tmp/ccxVmAlP.s:11186  .bss.runTimeAccelBias:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 _ZN14HardwareSPIExtC5Ej

UNDEFINED SYMBOLS
systick_uptime_millis
_Z4initv
_ZN11HardwareSPIC2Ej
_ZN11HardwareSPI6nssPinEv
_Z12digitalWritehh
_Z7pinModeh13WiringPinMode
_ZN11HardwareSPI5beginE12SPIFrequencyjj
_ZN11HardwareSPI8transferEh
_ZN11HardwareSPI3endEv
_Z5delaym
_Z21findMedianIntWithDiffPiiS_
_Z17delayMicrosecondsj
_ZN7TwoWire5beginEhh
Wire
__aeabi_f2d
__aeabi_d2f
sqrt
_Z10isSwitchedff
atan2
asin
rcc_dev_timer_clk_speed
gpio_set_mode
timer_attach_interrupt
PIN_MAP
_Z12filterSmoothfff
_ZN11EEPROMClass4readEt
EEPROM
_ZN11EEPROMClass5writeEtt
_ZN9USBSerial9availableEv
_ZN9USBSerial4readEv
SerialUSB
memset
atof
atol
_ZN5Print5printEc
_ZN5Print5printEli
_ZN5Print5printEhi
_ZN5Print5printEmi
_ZN5Print5printEii
_ZN5Print5printEdi
_ZN5Print5printEPKc
_ZN5Print7printlnEPKc
_ZN5Print7printlnEii
_ZN5Print7printlnEdi
_ZN5Print7printlnEmi
_ZN5Print7printlnEv
_ZN9USBSerial5beginEi
